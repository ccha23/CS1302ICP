%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]


\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Lecture notes}}

\usepackage{sphinxmessages}




\title{CS1302 Introduction to Computer Programming}
\date{Dec 01, 2020}
\release{}
\author{Chung Chan}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{README::doc}}


This is a jupyter book for the course \sphinxstyleemphasis{CS1302 Introduction to Computer Programming} at City University of Hong Kong.
The course aims to introduce key concepts, techniques, and good practices of programming using a high\sphinxhyphen{}level programming language Python.

\sphinxstylestrong{Course Intended Learning Outcomes (CILOs):}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Explain the structure of a computer program.

\item {} 
Analyze, test and debug computer programs.

\item {} 
Apply proper programming techniques to solve a task.

\item {} 
Construct well\sphinxhyphen{}structured programs.

\end{enumerate}


\chapter{Introduction to Computer Programming}
\label{\detokenize{Lecture1/Introduction to Computer Programming:introduction-to-computer-programming}}\label{\detokenize{Lecture1/Introduction to Computer Programming::doc}}

\section{Computer}
\label{\detokenize{Lecture1/Introduction to Computer Programming:computer}}

\subsection{What is a computer?}
\label{\detokenize{Lecture1/Introduction to Computer Programming:what-is-a-computer}}
Is computer a calculator that is bigger and more advanced?



If computer is a calculator, then, is \sphinxhref{https://en.wikipedia.org/wiki/Abacus}{abacus} the first computer invented?



Is your \sphinxhref{https://en.wikipedia.org/wiki/Samsung\_DeX}{smartphone} a computer?What defines a computer?
\begin{itemize}
\item {} 
In addition to performing arithmetic calculations, a computer is designed in such a way that

\item {} 
we can write different programs (in a process called \sphinxstylestrong{programming} or \sphinxstylestrong{software development})

\item {} 
for the computer to execute to perform different tasks.

\end{itemize}


\subsection{What is the architecture of a computer?}
\label{\detokenize{Lecture1/Introduction to Computer Programming:what-is-the-architecture-of-a-computer}}
A computer contains three main hardware components:
\begin{itemize}
\item {} 
Input device

\item {} 
Processing unit

\item {} 
Output device

\end{itemize}


\subsubsection{Peripherals}
\label{\detokenize{Lecture1/Introduction to Computer Programming:peripherals}}


Input and output devices connected to a computer are called \sphinxstyleemphasis{peripherals}.They allow users to interact with the computer in different ways.

\sphinxstylestrong{Exercise} Some examples of output devices are:
\begin{itemize}
\item {} 
Monitor

\item {} 
Speaker

\end{itemize}

Can you give an awesome example in the following box?
\begin{itemize}
\item {} 
3D printer available at \sphinxhref{https://www.cityu.edu.hk/lib/create/3dprint.htm}{CityU}

\end{itemize}

\sphinxstylestrong{Exercise} Some examples of input devices are:
\begin{itemize}
\item {} 
Keyboard

\item {} 
Mouse

\end{itemize}

Can you give an awesome example?
\begin{itemize}
\item {} 
3D scanner available at \sphinxhref{https://www.cityu.edu.hk/lib/create/3dscan.htm}{CityU}

\end{itemize}

\sphinxstylestrong{Exercise} Many devices are both input and output device. Can you give at least 3 examples?
\begin{itemize}
\item {} 
hard disk

\item {} 
CD/DVD Rom (writable)

\item {} 
touch screen

\end{itemize}


\subsubsection{Central Processing Unit}
\label{\detokenize{Lecture1/Introduction to Computer Programming:central-processing-unit}}


The brain of a computer is its processor unit, or the \sphinxhref{https://en.wikipedia.org/wiki/Central\_processing\_unit}{\sphinxstylestrong{C}entral \sphinxstylestrong{P}rocesisng \sphinxstylestrong{U}nit (CPU)}.It is located on the \sphinxhref{https://en.wikipedia.org/wiki/Motherboard}{\sphinxstyleemphasis{motherboard}} and connects to different peripherals using different \sphinxhref{https://en.wikipedia.org/wiki/Category:Computer\_connectors}{\sphinxstyleemphasis{connectors}}.

Two important components in the CPU are:
\begin{itemize}
\item {} 
\sphinxstylestrong{A}rithmetic and \sphinxstylestrong{L}ogic \sphinxstylestrong{U}nit (\sphinxstylestrong{ALU}): Performs arithmetics like a calculator (but for binary numbers)

\item {} 
\sphinxstylestrong{C}ontrol \sphinxstylestrong{U}nit (\sphinxstylestrong{CU}): Directs the operations of the processor in executing a program.

\end{itemize}

Let’s run a CPU Simulator below from a \sphinxhref{https://github.com/pddring/cpu-simulator}{GitHub project}.
\begin{itemize}
\item {} 
Note that all values are zeros in the RAM (\sphinxstylestrong{R}andom \sphinxstylestrong{A}cess \sphinxstylestrong{M}emory) initially.

\item {} 
Under Settings, click \sphinxcode{\sphinxupquote{Examples\sphinxhyphen{}>Add two numbers}}. Observe that the values in the RAM have changed.

\item {} 
Click \sphinxcode{\sphinxupquote{Run}} at the bottom right\sphinxhyphen{}hand corner.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}html}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{iframe} \PYG{n+na}{src}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}https://tools.withcode.uk/cpu\PYGZdq{}} \PYG{n+na}{width}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}800\PYGZdq{}} \PYG{n+na}{height}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}800\PYGZdq{}}\PYG{p}{\PYGZgt{}}
\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{iframe}\PYG{p}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}


\section{Programming}
\label{\detokenize{Lecture1/Introduction to Computer Programming:programming}}

\subsection{What is programming?}
\label{\detokenize{Lecture1/Introduction to Computer Programming:what-is-programming}}
Programming is the process of writing programs.But what is a program?

\sphinxstylestrong{Exercise} You have just seen a program written in \sphinxhref{https://en.wikipedia.org/wiki/Machine\_code}{machine language}. Where is it?

The first six lines of binary sequences in the RAM. The last line \sphinxcode{\sphinxupquote{Ends}} the program.
\begin{itemize}
\item {} 
The CPU is capable of carrying out
\begin{itemize}
\item {} 
a set of instructions such as \sphinxstyleemphasis{addition}, \sphinxstyleemphasis{negation}, \sphinxstyleemphasis{Copy}, etc.

\item {} 
some numbers stored in the RAM.

\end{itemize}

\item {} 
Both the instructions and the numbers are represented as binary sequences.

\item {} 
E.g., in Intel\sphinxhyphen{}based CPU, the command for addition is like \sphinxstylestrong{00000011 00000100}

\end{itemize}


\subsection{Why computer uses binary representation?}
\label{\detokenize{Lecture1/Introduction to Computer Programming:why-computer-uses-binary-representation}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}html}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{iframe} \PYG{n+na}{width}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}912\PYGZdq{}} \PYG{n+na}{height}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}513\PYGZdq{}} \PYG{n+na}{src}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}https://www.youtube.com/embed/Xpk67YzOn5w\PYGZdq{}} \PYG{n+na}{allowfullscreen}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{iframe}\PYG{p}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} The first electronic computer, called \sphinxhref{https://en.wikipedia.org/wiki/ENIAC}{Electronic Numerical Integrator and Computer (ENIAC)}, was programmed using binary circuitries, namely \sphinxstyleemphasis{switches} that can be either \sphinxcode{\sphinxupquote{On}} or \sphinxcode{\sphinxupquote{Off}}.



However, it did not represent values efficiently in binary. 10 binary digits (bits) was used to represent a decimal number 0 to 9.Indeed, how many decimals can be represented by 10 bits?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{10} \PYG{c+c1}{\PYGZsh{} because there are that many binary sequences of length 10.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1024
\end{sphinxVerbatim}

As mentioned in the video, there are \sphinxstyleemphasis{International Standards} for representing characters:
\begin{itemize}
\item {} 
\sphinxhref{https://en.wikipedia.org/wiki/ASCII}{ASCII} (American Standard Code for Information Interchange) maps English letters and some other symbols to 8\sphinxhyphen{}bits (8 binary digits, also called a byte). E.g., \sphinxcode{\sphinxupquote{A}} is \sphinxcode{\sphinxupquote{01000001}}.

\item {} 
\sphinxhref{https://en.wikipedia.org/wiki/Unicode}{Unicode} can also represent characters in different languages such as Chinese, Japanese…etc.

\end{itemize}

There are additional standards to represent numbers other than non\sphinxhyphen{}negative integers:
\begin{itemize}
\item {} 
\sphinxhref{https://en.wikipedia.org/wiki/Two\%27s\_complement}{2’s complement format} for negative integers (e.g. \sphinxhyphen{}123)

\item {} 
\sphinxhref{https://en.wikipedia.org/wiki/IEEE\_754}{IEEE floating point format} for floating point numbers such as \(1.23 x 10^{-4}\).

\end{itemize}

\sphinxstylestrong{Why define different standards?}
\begin{itemize}
\item {} 
Different standards have different benefits. ASCII requires less storage for a character, but it represents less characters.

\item {} 
Although digits are also represented in ASCII, the 2’s complement format is designed for arithmetic operations.

\end{itemize}


\section{Different generations of programming languages}
\label{\detokenize{Lecture1/Introduction to Computer Programming:different-generations-of-programming-languages}}
Machine language is known as the \sphinxstylestrong{1st Generation Programming Language}.

\sphinxstylestrong{Are we going to start with machine language?}
Start with learning 2’s complement and the binary codes for different instructions?

No. Programmers do not write machine codes directly because it is too hard to think in binary representations.

Instead, programmers write human\sphinxhyphen{}readable \sphinxstylestrong{mnemonics} such as \sphinxstylestrong{ADD}, \sphinxstylestrong{SUB}…,called \sphinxstylestrong{Assembly language}, or the \sphinxstylestrong{2nd Generation Programming Language}.



\sphinxstylestrong{Are you going to learn an assembly language?}

Both machine language and assembly language are low\sphinxhyphen{}level language which
\begin{itemize}
\item {} 
are difficult to write for complicated tasks (requiring many lines of code), and

\item {} 
are platform specific:
\begin{itemize}
\item {} 
the sets of instructions and their binary codes can be different for different \sphinxhref{https://en.wikipedia.org/wiki/Comparison\_of\_CPU\_microarchitectures}{types of CPUs}, and

\item {} 
different operating systems use \sphinxhref{https://en.wikipedia.org/wiki/X86\_assembly\_language}{different assembly languages/styles}.

\end{itemize}

\end{itemize}

Anyone want to learn assembly languages, and write a program in many versions to support different platforms?

Probably for programmers who need to write fast or energy\sphinxhyphen{}efficient code such as
\begin{itemize}
\item {} 
a driver that controls a 3D graphics card, and

\item {} 
a program that control a microprocessor with limited power supply.

\end{itemize}

But even in the above cases, there are often better alternatives. Play with the following microprocessor simulator:
\begin{itemize}
\item {} 
Click \sphinxcode{\sphinxupquote{CHOOSE A DEMO\sphinxhyphen{}>LED}}.

\item {} 
Click \sphinxcode{\sphinxupquote{RUN SCRIPT}} and observes the LED of the board.

\item {} 
Run the demos \sphinxcode{\sphinxupquote{ASSEMBLY}} and \sphinxcode{\sphinxupquote{MATH}} respectively and compare their capabilities.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZpc{}\PYGZpc{}html
\PYGZlt{}iframe width=\PYGZdq{}900\PYGZdq{}, height=\PYGZdq{}1000\PYGZdq{} src=\PYGZdq{}https://micropython.org/unicorn/\PYGZdq{}\PYGZgt{}\PYGZlt{}/iframe\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}


\section{High\sphinxhyphen{}level Language}
\label{\detokenize{Lecture1/Introduction to Computer Programming:high-level-language}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}html}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{iframe} \PYG{n+na}{width}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}912\PYGZdq{}} \PYG{n+na}{height}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}513\PYGZdq{}} \PYG{n+na}{src}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}https://www.youtube.com/embed/QdVFvsCWXrA\PYGZdq{}} \PYG{n+na}{allowfullscreen}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{iframe}\PYG{p}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

Programmer nowadays use human\sphinxhyphen{}readable language known as the \sphinxstylestrong{3rd generation language (3GL)} or \sphinxstylestrong{high\sphinxhyphen{}level language.}
\begin{itemize}
\item {} 
Examples includes: C, C++, Java, JavaScript, Basic, Python, PHP, …

\end{itemize}


\subsection{What is a high\sphinxhyphen{}level language?}
\label{\detokenize{Lecture1/Introduction to Computer Programming:what-is-a-high-level-language}}\begin{itemize}
\item {} 
A code written in high\sphinxhyphen{}level language gets converted automatically to a low\sphinxhyphen{}level machine code for the desired platform.

\item {} 
Hence, it \sphinxstyleemphasis{abstracts} away details that can be handled by the computer (low\sphinxhyphen{}level code) itself.

\end{itemize}

For instance, a programmer needs not care where a value should be physically stored if the computer can find a free location automatically to store the value.

Different high\sphinxhyphen{}level languages can have different implementations of the conversion processes:
\begin{itemize}
\item {} 
\sphinxstylestrong{Compilation} means converting a program well before executing of the program. E.g., C++ and Java programs are compiled.

\item {} 
\sphinxstylestrong{Interpretation} means converting a program on\sphinxhyphen{}the\sphinxhyphen{}fly during the execution of a program. E.g., JavaScript and Python programs are often interpreted.

\end{itemize}

Roughly speaking, compiled programs run faster but interpreted programs are more flexible and can be modified at run time.(The \sphinxhref{https://finematics.com/compiled-vs-interpreted-programming-languages/}{truth} is indeed more complicated than required for this course.)


\subsection{What programming language will you learn?}
\label{\detokenize{Lecture1/Introduction to Computer Programming:what-programming-language-will-you-learn}}
You will learn to program using \sphinxstylestrong{Python}. The course covers:
\begin{itemize}
\item {} 
Basic topics including \sphinxstyleemphasis{values}, \sphinxstyleemphasis{variables}, \sphinxstyleemphasis{conditional}, \sphinxstyleemphasis{iterations}, \sphinxstyleemphasis{functions}, \sphinxstyleemphasis{composite data types}.

\item {} 
Advanced topics that touch on functional and object\sphinxhyphen{}oriented programming.

\item {} 
Engineering topics such as \sphinxstyleemphasis{numerical methods}, \sphinxstyleemphasis{optimizations}, and \sphinxstyleemphasis{machine learning}.

\end{itemize}

See the \sphinxhref{https://canvas.cityu.edu.hk/courses/36768}{course homepage} for details.

\sphinxstylestrong{Why Python?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}html}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{iframe} \PYG{n+na}{width}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}912\PYGZdq{}} \PYG{n+na}{height}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}513\PYGZdq{}} \PYG{n+na}{src}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}https://www.youtube.com/embed/Y8Tko2YC5hA?end=200\PYGZdq{}} \PYG{n+na}{allowfullscreen}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{iframe}\PYG{p}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

In summary:
\begin{itemize}
\item {} 
Python is expressive and can get things done with fewer lines of code as compared to other languages.

\item {} 
Python is one of the most commonly used languages. It has an extensive set of libraries for Mathematics, graphics, AI, Machine Learning, etc.

\item {} 
Python is Free and Open Source, so you get to see everything and use it without restrictions.

\item {} 
Python is portable. The same code runs in different platforms without modifications.

\end{itemize}

\sphinxstylestrong{How does a Python program look like?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} for step\PYGZhy{}by\PYGZhy{}step execution using mytutor}
\PYG{o}{\PYGZpc{}}\PYG{k}{reload\PYGZus{}ext} mytutor
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 400
\PYGZsh{} The program here reads the cohort and reports which year the user is in
\PYGZsh{} Assumption: Input is integer no greater than 2020
import datetime  \PYGZsh{} load a library to tell the current year
cohort = input(\PYGZdq{}In which year did you join CityU? \PYGZdq{})
year = datetime.datetime.now().year \PYGZhy{} int(cohort) + 1
print(\PYGZdq{}So you are a year\PYGZdq{}, year, \PYGZdq{}student.\PYGZdq{})
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f7f2c675d68\PYGZgt{}
\end{sphinxVerbatim}

A Python program contains \sphinxstyleemphasis{statements} just like sentences in natural languages.E.g., \sphinxcode{\sphinxupquote{cohort = input("In which year did you join CityU? ")}} is a statement that gives some value a name called \sphinxcode{\sphinxupquote{cohort}}.

For the purpose of computations, a statement often contains \sphinxstyleemphasis{expressions} that evaluate to certain values.E.g., \sphinxcode{\sphinxupquote{input("In which year did you join CityU? ")}} is an expression with the value equal to what you input to the prompt.That value is then given the name \sphinxcode{\sphinxupquote{cohort}}.

Expressions can be composed of:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Functions} such as \sphinxcode{\sphinxupquote{input}}, \sphinxcode{\sphinxupquote{now}}, and \sphinxcode{\sphinxupquote{int}}, etc., which are like math functions the return some values based on its arguments, if any.

\item {} 
\sphinxstyleemphasis{Literals} such as the string \sphinxcode{\sphinxupquote{"In which year did you join CityU? "}} and the integer \sphinxcode{\sphinxupquote{1}}. They are values you type out literally.

\item {} 
\sphinxstyleemphasis{Variables} such as \sphinxcode{\sphinxupquote{cohort}} and \sphinxcode{\sphinxupquote{year}}, which are meaningful names to values.

\end{itemize}

To help others understand the code, there are also \sphinxstyleemphasis{comments} that start with \sphinxcode{\sphinxupquote{\#}}.These are descriptions meant for human to read but not to be executed by the computer.

\sphinxstylestrong{Exercise} What do you think the next generation programmimng should be?

Perhaps programming using natural languages. Write programs that people enjoy reading, like \sphinxhref{https://www.youtube.com/watch?v=bTkXg2LZIMQ}{literate programming}.Indeed, Jupyter notebook is arguably a step towards this direction. See \sphinxhref{https://github.com/fastai/nbdev}{nbdev}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}html}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{iframe} \PYG{n+na}{width}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}912\PYGZdq{}} \PYG{n+na}{height}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}513\PYGZdq{}} \PYG{n+na}{src}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}https://www.youtube.com/embed/bTkXg2LZIMQ\PYGZdq{}} \PYG{n+na}{allowfullscreen}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{iframe}\PYG{p}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}


\chapter{Values and Variables}
\label{\detokenize{Lecture2/Values and Variables:values-and-variables}}\label{\detokenize{Lecture2/Values and Variables::doc}}

\section{Integers}
\label{\detokenize{Lecture2/Values and Variables:integers}}
\sphinxstylestrong{How to enter an \sphinxhref{https://docs.python.org/3/reference/lexical\_analysis.html\#integer-literals}{integer} in a program?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{15}  \PYG{c+c1}{\PYGZsh{} an integer in decimal}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
15
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mb}{0b1111}  \PYG{c+c1}{\PYGZsh{} a binary number}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
15
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mh}{0xF}  \PYG{c+c1}{\PYGZsh{} hexadecimal (base 16) with possible digits 0, 1,2,3,4,5,6,7,8,9,A,B,C,D,E,F}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
15
\end{sphinxVerbatim}

\sphinxstylestrong{Why all outputs are the same?}
\begin{itemize}
\item {} 
What you have entered are \sphinxstyleemphasis{integer literals}, which are integers written out literally.

\item {} 
All the literals have the same integer value in decimal.

\item {} 
By default, if the last line of a code cell has a value, the jupyter notebook (\sphinxstyleemphasis{IPython}) will store and display the value as an output.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{3}  \PYG{c+c1}{\PYGZsh{} not the output of this cell}
\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{l+m+mi}{5} \PYG{o}{+} \PYG{l+m+mi}{6}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
15
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
The last line above also has the same value, \sphinxcode{\sphinxupquote{15}}.

\item {} 
It is an \sphinxstyleemphasis{expression} (but not a literal) that \sphinxstyleemphasis{evaluates} to the integer value.

\end{itemize}

\sphinxstylestrong{Exercise} Enter an expression that evaluates to an integer value, as big as possible.(You may need to interrupt the kernel if the expression takes too long to evaluate.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} There is no maximum for an integer for Python3. }
\PYG{c+c1}{\PYGZsh{} See https://docs.python.org/3.1/whatsnew/3.0.html\PYGZsh{}integers}
\PYG{l+m+mi}{11} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{100000}
\end{sphinxVerbatim}


\section{Strings}
\label{\detokenize{Lecture2/Values and Variables:strings}}
\sphinxstylestrong{How to enter a \sphinxhref{https://docs.python.org/3/reference/lexical\_analysis.html\#string-and-bytes-literals}{string} in a program?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}U0001f600}\PYG{l+s+s1}{: I am a string.}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{} a sequence of characters delimited by single quotes.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}😀: I am a string.\PYGZsq{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}N\PYGZob{}grinning face\PYGZcb{}}\PYG{l+s+s2}{: I am a string.}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{c+c1}{\PYGZsh{} delimited by double quotes.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}😀: I am a string.\PYGZsq{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}\PYGZbs{}N\PYGZob{}grinning face\PYGZcb{}: I am a string.\PYGZdq{}\PYGZdq{}\PYGZdq{}}  \PYG{c+c1}{\PYGZsh{} delimited by triple single/double quotes.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}😀: I am a string.\PYGZsq{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}}} is called the \sphinxstyleemphasis{escape symbol}.

\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}U0001f600}} and \sphinxcode{\sphinxupquote{\textbackslash{}N\{grinning face\}}} are \sphinxstyleemphasis{escape sequences}.

\item {} 
These sequences represent the same grinning face emoji by its Unicode in hexadecimal and its name.

\end{itemize}

\sphinxstylestrong{Why use different quotes?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I}\PYG{l+s+se}{\PYGZbs{}\PYGZsq{}}\PYG{l+s+s1}{m line \PYGZsh{}1.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{I}\PYG{l+s+se}{\PYGZbs{}\PYGZsq{}}\PYG{l+s+s1}{m line \PYGZsh{}2.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} \PYGZbs{}n is a control code for line feed}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{m line \PYGZsh{}3.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{I}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{m line \PYGZsh{}4.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} no need to escape single quote.}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+s1}{I}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{m line \PYGZsh{}5.}
\PYG{l+s+s1}{I}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{m line \PYGZsh{}6.}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} multi\PYGZhy{}line string}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
I\PYGZsq{}m line \PYGZsh{}1.
I\PYGZsq{}m line \PYGZsh{}2.
I\PYGZsq{}m line \PYGZsh{}3.
I\PYGZsq{}m line \PYGZsh{}4.
I\PYGZsq{}m line \PYGZsh{}5.
I\PYGZsq{}m line \PYGZsh{}6.
\end{sphinxVerbatim}

Note that:
\begin{itemize}
\item {} 
The escape sequence \sphinxcode{\sphinxupquote{\textbackslash{}n}} does not represent any symbol.

\item {} 
It is a \sphinxstyleemphasis{control code} that creates a new line when printing the string.

\item {} 
Another common control code is \sphinxcode{\sphinxupquote{\textbackslash{}t}} for tab.

\end{itemize}

Using double quotes, we need not escape the single quote in \sphinxcode{\sphinxupquote{I'm}}.

Triple quotes delimit a multi\sphinxhyphen{}line string, so there is no need to use \sphinxcode{\sphinxupquote{\textbackslash{}n}}.(You can copy and paste a multi\sphinxhyphen{}line string from elsewhere.)

In programming, there are often many ways to do the same thing.The following is a one\sphinxhyphen{}line code (\sphinxhref{https://en.wikipedia.org/wiki/One-liner\_program}{one\sphinxhyphen{}liner}) that prints multiple lines of strings without using \sphinxcode{\sphinxupquote{\textbackslash{}n}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{m line \PYGZsh{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{m line \PYGZsh{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{m line \PYGZsh{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} one liner}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
I\PYGZsq{}m line \PYGZsh{}1
I\PYGZsq{}m line \PYGZsh{}2
I\PYGZsq{}m line \PYGZsh{}3
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{sep='\textbackslash{}n'}} is a \sphinxstyleemphasis{keyword argument} that specifies the separator of the list of strings.

\item {} 
By default, \sphinxcode{\sphinxupquote{sep=' '}}, a single space character.

\end{itemize}

In IPython, we can get the \sphinxstyleemphasis{docstring} (documentation) of a function conveniently using the symbol \sphinxcode{\sphinxupquote{?}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{?}print
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
print\PYG{o}{?}
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Print a cool multi\sphinxhyphen{}line string below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{ (ง •̀\PYGZus{}•́)ง }
\PYG{l+s+s1}{ ╰(●’◡’●)╮ }
\PYG{l+s+s1}{ (..•˘\PYGZus{}˘•..)}
\PYG{l+s+s1}{ (づ￣ 3￣)づ}
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} See also https://github.com/glamp/bashplotlib}
\PYG{c+c1}{\PYGZsh{} Star Wars via Telnet http://asciimation.co.nz/}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 (ง •̀\PYGZus{}•́)ง 
 ╰(●’◡’●)╮ 
 (..•˘\PYGZus{}˘•..)
 (づ￣ 3￣)づ
\end{sphinxVerbatim}


\section{Variables and Assignment}
\label{\detokenize{Lecture2/Values and Variables:variables-and-assignment}}
It is useful to store a value and retrieve it later.To do so, we assign the value to a variable:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{15}
\PYG{n}{x}  \PYG{c+c1}{\PYGZsh{} output the value of x}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
15
\end{sphinxVerbatim}

\sphinxstylestrong{Is assignment the same as equality?}

No because:
\begin{itemize}
\item {} 
you cannot write \sphinxcode{\sphinxupquote{15 = x}}, but

\item {} 
you can write \sphinxcode{\sphinxupquote{x = x + 1}}, which increases the value of \sphinxcode{\sphinxupquote{x}} by \sphinxcode{\sphinxupquote{1}}.

\end{itemize}

\sphinxstylestrong{Exercise} Try out the above code yourself.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{n}{x}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
16
\end{sphinxVerbatim}

Let’s see the effect of assignment step\sphinxhyphen{}by\sphinxhyphen{}step:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Run the following cell.

\item {} 
Click \sphinxcode{\sphinxupquote{Next >}} to see the next step of the execution.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 200
x = 15
x = x + 1
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7ff9204f8390\PYGZgt{}
\end{sphinxVerbatim}

The following \sphinxstyleemphasis{tuple assignment} syntax can assign multiple variables in one line.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 200
x, y, z = \PYGZsq{}15\PYGZsq{}, \PYGZsq{}30\PYGZsq{}, 15
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7ff9204f86d8\PYGZgt{}
\end{sphinxVerbatim}

One can also use \sphinxstyleemphasis{chained assignment} to set different variables to the same value.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 250
x = y = z = 0
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7ff9204f89b0\PYGZgt{}
\end{sphinxVerbatim}

Variables can be deleted using \sphinxcode{\sphinxupquote{del}}. Accessing a variable before assignment raises a Name error.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{del} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}
\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{NameError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}\PYG{n}{a8db3f963f3}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{k}{del} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}

\PYG{n+ne}{NameError}: name \PYGZsq{}y\PYGZsq{} is not defined
\end{sphinxVerbatim}


\section{Identifiers}
\label{\detokenize{Lecture2/Values and Variables:identifiers}}
\sphinxstyleemphasis{Identifiers} such as variable names are case sensitive and follow certain rules.

\sphinxstylestrong{What is the syntax for variable names?}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Must start with a letter or \sphinxcode{\sphinxupquote{\_}} (an underscore) followed by letters, digits, or \sphinxcode{\sphinxupquote{\_}}.

\item {} 
Must not be a \sphinxhref{https://docs.python.org/3.7/reference/lexical\_analysis.html\#keywords}{keyword} (identifier reserved by Python):

\end{enumerate}



\sphinxstylestrong{Exercise} Evaluate the following cell and check if any of the rules above is violated.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{ipywidgets} \PYG{k+kn}{import} \PYG{n}{interact}
\PYG{n+nd}{@interact}
\PYG{k}{def} \PYG{n+nf}{identifier\PYGZus{}syntax}\PYG{p}{(}\PYG{n}{assignment}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a\PYGZhy{}number = 15}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a\PYGZus{}number = 15}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{15 = 15}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}15 = 15}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{del = 15}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Del = 15}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{type = print}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{print = type}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{input = print}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{exec}\PYG{p}{(}\PYG{n}{assignment}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ok.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(Dropdown(description=\PYGZsq{}assignment\PYGZsq{}, options=(\PYGZsq{}a\PYGZhy{}number = 15\PYGZsq{}, \PYGZsq{}a\PYGZus{}number = 15\PYGZsq{}, \PYGZsq{}15 = 15\PYGZsq{},…
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxcode{\sphinxupquote{a\sphinxhyphen{}number = 15}} violates Rule 1 because \sphinxcode{\sphinxupquote{\sphinxhyphen{}}} is not allowed. \sphinxcode{\sphinxupquote{\sphinxhyphen{}}} is interpreted as an operator.

\item {} 
\sphinxcode{\sphinxupquote{15 = 15}} violates Rule 1 because \sphinxcode{\sphinxupquote{15}} starts with a digit instead of letter or \_.

\item {} 
\sphinxcode{\sphinxupquote{del = 15}} violates Rule 2 because \sphinxcode{\sphinxupquote{del}} is a keyword.

\end{enumerate}

What can we learn from the above examples?
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{del}} is a keyword and \sphinxcode{\sphinxupquote{Del}} is not because identifiers are case sensitive.

\item {} 
Function/method/type names \sphinxcode{\sphinxupquote{print}}/\sphinxcode{\sphinxupquote{input}}/\sphinxcode{\sphinxupquote{type}} are not keywords and can be reassigned.This can useful if you want to modify the default implementations without changing their source code.

\end{itemize}

To help make code more readable, additional style guides such as \sphinxhref{https://www.python.org/dev/peps/pep-0008/\#function-and-variable-names}{PEP 8} are available:
\begin{itemize}
\item {} 
Function names should be lowercase, with words separated by underscores as necessary to improve readability.

\item {} 
Variable names follow the same convention as function names.

\end{itemize}


\section{User Input}
\label{\detokenize{Lecture2/Values and Variables:user-input}}
\sphinxstylestrong{How to let the user input a value at \sphinxstyleemphasis{runtime},i.e., as the program executes?}

We can use the method \sphinxcode{\sphinxupquote{input}}:
\begin{itemize}
\item {} 
There is no need to delimit the input string by quotation marks.

\item {} 
Simply press \sphinxcode{\sphinxupquote{enter}} after typing a string.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Your name is}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Please input your name: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{input}} method prints its argument, if any, as a \sphinxhref{https://en.wikipedia.org/wiki/Command-line\_interface\#Command\_prompt}{prompt}.

\item {} 
It takes user’s input and \sphinxstyleemphasis{return} it as its value. \sphinxcode{\sphinxupquote{print}} takes in that value and prints it.

\end{itemize}

\sphinxstylestrong{Exercise} Explain whether the following code prints \sphinxcode{\sphinxupquote{'My name is Python'}}. Does \sphinxcode{\sphinxupquote{print}} return a value?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{My name is}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Python}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Python
My name is None
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Unlike \sphinxcode{\sphinxupquote{input}}, the function \sphinxcode{\sphinxupquote{print}} does not return the string it is trying to print. Printing a string is, therefore, different from returning a string.

\item {} 
\sphinxcode{\sphinxupquote{print}} actually returns a \sphinxcode{\sphinxupquote{None}} object that gets printed as \sphinxcode{\sphinxupquote{None}}.

\end{itemize}


\section{Type Conversion}
\label{\detokenize{Lecture2/Values and Variables:type-conversion}}
The following program tries to compute the sum of two numbers from user inputs:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num1} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Please input an integer: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{num2} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Please input another integer: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{num1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{num2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is equal to}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{num1} \PYG{o}{+} \PYG{n}{num2}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} There is a \sphinxhref{https://en.wikipedia.org/wiki/Software\_bug}{bug} in the above code. Can you locate the error?

The two numbers are concatenated instead of added together.

\sphinxcode{\sphinxupquote{input}} \sphinxstyleemphasis{returns} user input as a string.E.g., if the user enters \sphinxcode{\sphinxupquote{12}}, the input is
\begin{itemize}
\item {} 
not treated as the integer twelve, but rather

\item {} 
treated as a string containing two characters, one followed by two.

\end{itemize}

To see this, we can use \sphinxcode{\sphinxupquote{type}} to return the data type of an expression.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num1} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Please input an integer: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Your input is}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{num1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{with type}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{num1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} \sphinxcode{\sphinxupquote{type}} applies to any expressions. Try it out below on \sphinxcode{\sphinxupquote{15}}, \sphinxcode{\sphinxupquote{print}}, \sphinxcode{\sphinxupquote{print()}}, \sphinxcode{\sphinxupquote{input}}, and even \sphinxcode{\sphinxupquote{type}} itself and \sphinxcode{\sphinxupquote{type(type)}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{type}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n+nb}{print}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(int, builtin\PYGZus{}function\PYGZus{}or\PYGZus{}method, NoneType, method, type, type)
\end{sphinxVerbatim}

\sphinxstylestrong{So what happens when we add strings together?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{6}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}456\PYGZsq{}
\end{sphinxVerbatim}

\sphinxstylestrong{How to fix the bug then?}

We can convert a string to an integer using \sphinxcode{\sphinxupquote{int}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n+nb}{int}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{+} \PYG{n+nb}{int}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
15
\end{sphinxVerbatim}

We can also convert an integer to a string using \sphinxcode{\sphinxupquote{str}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}456\PYGZsq{}
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Fix the bug in the following cell.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num1} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Please input an integer: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{num2} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Please input another integer: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} print(num1, \PYGZsq{}+\PYGZsq{}, num2, \PYGZsq{}is equal to\PYGZsq{}, num1 + num2)  \PYGZsh{} fix this line below}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{num1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{num2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is equal to}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{num1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{num2}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}


\section{Error}
\label{\detokenize{Lecture2/Values and Variables:error}}
In addition to writing code, a programmer spends significant time in \sphinxstyleemphasis{debugging} code that contains errors.

\sphinxstylestrong{Can an error be automatically detected by the computer?}
\begin{itemize}
\item {} 
You have just seen an example of \sphinxstyleemphasis{logical error}, which is due to an error in the logic.

\item {} 
The ability to debug or even detect such error is, unfortunately, beyond Python’s intelligence.

\end{itemize}

Other kinds of error may be detected automatically.As an example, note that we can omit \sphinxcode{\sphinxupquote{+}} for string concatenation, but we cannot omit it for integer summation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Skipping + for string concatenation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5}\PYG{l+s+s1}{\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{6}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Skipping + for string concatenation
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}456\PYGZsq{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Skipping + for integer summation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{6}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{  File}\PYG{n+nn}{ \PYGZdq{}\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}32\PYGZhy{}234998ea6ba8\PYGZgt{}\PYGZdq{}}\PYG{g+gt}{, line }\PYG{l+m+mi}{2}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{6}
      \PYG{o}{\PYGZca{}}
\PYG{n+ne}{SyntaxError}: invalid syntax
\end{sphinxVerbatim}

Python interpreter detects the bug and raises a \sphinxstyleemphasis{syntax} error.

\sphinxstylestrong{Why Syntax error can be detected automatically?Why is the print statement before the error not executed?}
\begin{itemize}
\item {} 
The Python interpreter can easily detect syntax error even before executing the code simply because

\item {} 
the interpreter fails to interpret the code, i.e., translates the code to lower\sphinxhyphen{}level executable code.

\end{itemize}

The following code raises a different kind of error.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Evaluating }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ + }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{5}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ + 6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+m+mi}{6}  \PYG{c+c1}{\PYGZsh{} summing string with integer}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Evaluating \PYGZsq{}4\PYGZsq{} + \PYGZsq{}5\PYGZsq{} + 6
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{33}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{67}\PYG{n}{f2880d2e89}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Evaluating }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{4}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ + }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{5}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ + 6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{2} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+m+mi}{6}  \PYG{c+c1}{\PYGZsh{} summing string with integer}

\PYG{n+ne}{TypeError}: can only concatenate str (not \PYGZdq{}int\PYGZdq{}) to str
\end{sphinxVerbatim}

\sphinxstylestrong{Why Python throws a TypeError when evaluating \sphinxcode{\sphinxupquote{'4' + '5' + 6}}?}

There is no default implementation of \sphinxcode{\sphinxupquote{+}} operation on a value of type \sphinxcode{\sphinxupquote{str}} and a value of type \sphinxcode{\sphinxupquote{int}}.
\begin{itemize}
\item {} 
Unlike syntax error, the Python interpreter can only detect type error at runtime (when executing the code.)

\item {} 
Hence, such error is called a \sphinxstyleemphasis{runtime error}.

\end{itemize}

\sphinxstylestrong{Why is TypeError a runtime error?}

The short answer is that Python is a \sphinxhref{https://en.wikipedia.org/wiki/Strong\_and\_weak\_typing}{strongly\sphinxhyphen{}and\sphinxhyphen{}dynamically\sphinxhyphen{}typed} language:
\begin{itemize}
\item {} 
Strongly\sphinxhyphen{}typed: Python does not force a type conversion to avoid a type error.

\item {} 
Dynamically\sphinxhyphen{}typed: Python allow data type to change at runtime.

\end{itemize}

The underlying details are more complicated than required for this course. It helps if you already know the following languages:
\begin{itemize}
\item {} 
JavaScript, which is a \sphinxstyleemphasis{weakly\sphinxhyphen{}typed} language that forces a type conversion to avoid a type error.

\item {} 
C, which is a \sphinxstyleemphasis{statically\sphinxhyphen{}typed} language that does not allow data type to change at runtime.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}javascript}
\PYG{n+nx}{alert}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}4\PYGZsq{}} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}5\PYGZsq{}} \PYG{o}{+} \PYG{l+m+mi}{6}\PYG{p}{)}  \PYG{c+c1}{// no error because 6 is converted to a str automatically}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

A weakly\sphinxhyphen{}typed language may seem more robust, but it can lead to \sphinxhref{https://www.oreilly.com/library/view/fluent-conference-javascript/9781449339203/oreillyvideos1220106.html}{more logical errors}.To improve readability, \sphinxhref{https://www.typescriptlang.org/}{typescript} is a strongly\sphinxhyphen{}typed replacement of javascript.

\sphinxstylestrong{Exercise} Not all the strings can be converted into integers. Try breaking the following code by providing invalid inputs and record them in the subsequent cell. Explain whether the errors are runtime errors.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num1} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Please input an integer: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{num2} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Please input another integer: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{num1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{num2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is equal to}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{num1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{num2}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

The possible invalid inputs are:
\begin{quote}

\sphinxcode{\sphinxupquote{4 + 5 + 6}}, \sphinxcode{\sphinxupquote{15.0}}, \sphinxcode{\sphinxupquote{fifteen}}
\end{quote}

It raises a value error, which is a runtime error detected during execution.

Note that the followings are okay
\begin{quote}

int(‘\sphinxhyphen{}1’), eval(‘4 + 5 + 6’)
\end{quote}


\section{Floating Point Numbers}
\label{\detokenize{Lecture2/Values and Variables:floating-point-numbers}}
Not all numbers are integers. In Enginnering, we often need to use fractions.

\sphinxstylestrong{How to enter fractions in a program?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1} \PYG{c+c1}{\PYGZsh{} decimal number}
\PYG{n}{y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0e\PYGZhy{}1} \PYG{c+c1}{\PYGZsh{} scientific notation}
\PYG{n}{z} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{10} \PYG{c+c1}{\PYGZsh{} fraction}
\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.1, \PYGZhy{}0.1, \PYGZhy{}0.1, float, float, float)
\end{sphinxVerbatim}

\sphinxstylestrong{What is the type \sphinxcode{\sphinxupquote{float}}?}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{float}} corresponds to the \sphinxhref{https://en.wikipedia.org/wiki/Floating-point\_arithmetic\#Floating-point\_numbers}{\sphinxstyleemphasis{floating point} representation}.

\item {} 
A \sphinxcode{\sphinxupquote{float}} in stored exactly the way we write it in scientific notation:

\end{itemize}
\begin{equation*}
\begin{split}
\overbrace{-}^{\text{sign}} \underbrace{1.0}_{\text{mantissa}\kern-1em}e\overbrace{-1}^{\text{exponent}\kern-1em}=-1\times 10^{-1}
\end{split}
\end{equation*}\begin{itemize}
\item {} 
The \sphinxhref{https://www.h-schmidt.net/FloatConverter/IEEE754.html}{truth} is more complicated than required for the course.

\end{itemize}

Integers in mathematics may be regarded as a \sphinxcode{\sphinxupquote{float}} instead of \sphinxcode{\sphinxupquote{int}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{type}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{(}\PYG{l+m+mf}{1e2}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(float, float)
\end{sphinxVerbatim}

You can also convert an \sphinxcode{\sphinxupquote{int}} or a \sphinxcode{\sphinxupquote{str}} to a \sphinxcode{\sphinxupquote{float}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{float}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{float}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(1.0, 1.0)
\end{sphinxVerbatim}

\sphinxstylestrong{Is it better to store an integer as \sphinxcode{\sphinxupquote{float}}?}

Python stores a \sphinxhref{https://docs.python.org/3/library/sys.html\#sys.float\_info}{floating point} with finite precision (usually as a 64bit binary fraction):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{float\PYGZus{}info}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sys.float\PYGZus{}info(max=1.7976931348623157e+308, max\PYGZus{}exp=1024, max\PYGZus{}10\PYGZus{}exp=308, min=2.2250738585072014e\PYGZhy{}308, min\PYGZus{}exp=\PYGZhy{}1021, min\PYGZus{}10\PYGZus{}exp=\PYGZhy{}307, dig=15, mant\PYGZus{}dig=53, epsilon=2.220446049250313e\PYGZhy{}16, radix=2, rounds=1)
\end{sphinxVerbatim}

It cannot represent a number larger than the \sphinxcode{\sphinxupquote{max}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{float\PYGZus{}info}\PYG{o}{.}\PYG{n}{max} \PYG{o}{*} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
inf
\end{sphinxVerbatim}

The precision also affects the check for equality.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{==} \PYG{l+m+mf}{1.0} \PYG{o}{+} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{float\PYGZus{}info}\PYG{o}{.}\PYG{n}{epsilon} \PYG{o}{*} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} returns true if equal}
 \PYG{l+m+mf}{1.0} \PYG{o}{==} \PYG{l+m+mf}{1.0} \PYG{o}{+} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{float\PYGZus{}info}\PYG{o}{.}\PYG{n}{epsilon} \PYG{o}{*} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{float\PYGZus{}info}\PYG{o}{.}\PYG{n}{max} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{==} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{float\PYGZus{}info}\PYG{o}{.}\PYG{n}{max}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(True, False, True)
\end{sphinxVerbatim}

Another issue with float is that it may keep more decimal places than desired.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0.3333333333333333
\end{sphinxVerbatim}

\sphinxstylestrong{How to \sphinxhref{https://docs.python.org/3/library/functions.html\#round}{round} a floating point number to the desired number of decimal places?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{round}\PYG{p}{(}\PYG{l+m+mf}{2.665}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{round}\PYG{p}{(}\PYG{l+m+mf}{2.675}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(2.67, 2.67)
\end{sphinxVerbatim}

\sphinxstylestrong{Why 2.675 rounds to 2.67 instead of 2.68?}
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{float}} is actually represented in binary.

\item {} 
A decimal fraction \sphinxhref{https://docs.python.org/3/tutorial/floatingpoint.html\#tut-fp-issues}{may not be represented exactly in binary}.

\end{itemize}

The \sphinxcode{\sphinxupquote{round}} function can also be applied to an integer.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{round}\PYG{p}{(}\PYG{l+m+mi}{150}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{round}\PYG{p}{(}\PYG{l+m+mi}{250}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(200, 200)
\end{sphinxVerbatim}

\sphinxstylestrong{Why 250 rounds to 200 instead of 300?}
\begin{itemize}
\item {} 
Python 3 implements the default rounding method in \sphinxhref{https://en.wikipedia.org/w/index.php?title=IEEE\_754\#Rounding\_rules}{IEEE 754}.

\end{itemize}


\section{String Formatting}
\label{\detokenize{Lecture2/Values and Variables:string-formatting}}
\sphinxstylestrong{Can we round a \sphinxcode{\sphinxupquote{float}} or \sphinxcode{\sphinxupquote{int}} for printing but not calculation?}

This is possible with \sphinxhref{https://docs.python.org/3/library/string.html\#format-specification-mini-language}{\sphinxstyleemphasis{format specifications}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{10000}\PYG{o}{/}\PYG{l+m+mi}{3}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x ≈ }\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s1}{ (rounded to 2 decimal places)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{x}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
x ≈ 3333.33 (rounded to 2 decimal places)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
3333.3333333333335
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\{:.2f\}}} is a \sphinxstyleemphasis{format specification}

\item {} 
that gets replaced by a string

\item {} 
that represents the argument \sphinxcode{\sphinxupquote{x}} of \sphinxcode{\sphinxupquote{format}}

\item {} 
as a decimal floating point number rounded to 2 decimal places.

\end{itemize}

\sphinxstylestrong{Exercise} Play with the following widget to learn the effect of different format specifications. In particular, print \sphinxcode{\sphinxupquote{10000/3}} as \sphinxcode{\sphinxupquote{3,333.33}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{ipywidgets} \PYG{k+kn}{import} \PYG{n}{interact}
\PYG{n+nd}{@interact}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10000/3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
          \PYG{n}{align}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{None}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZca{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZca{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
          \PYG{n}{sign}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{None}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SPACE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
          \PYG{n}{width}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{,}
          \PYG{n}{grouping}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{None}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
          \PYG{n}{precision}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}float}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{sign}\PYG{p}{,}\PYG{n}{align}\PYG{p}{,}\PYG{n}{grouping}\PYG{p}{,}\PYG{n}{width}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{precision}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{format\PYGZus{}spec} \PYG{o}{=} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZob{}\PYGZob{}}\PYG{l+s+s2}{:}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{align}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sign}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{if} \PYG{n}{width}\PYG{o}{==}\PYG{l+m+mi}{0} \PYG{k}{else} \PYG{n}{width}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{grouping}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{.}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{precision}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{f}\PYG{l+s+se}{\PYGZcb{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Format spec:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{format\PYGZus{}spec}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x ≈}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{format\PYGZus{}spec}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n+nb}{eval}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(Text(value=\PYGZsq{}10000/3\PYGZsq{}, description=\PYGZsq{}x\PYGZsq{}), Dropdown(description=\PYGZsq{}sign\PYGZsq{}, options=\PYGZob{}\PYGZsq{}None\PYGZsq{}: \PYGZsq{}\PYGZsq{}…
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}:,.2f\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+m+mi}{10000}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
3,333.33
\end{sphinxVerbatim}

String formatting is useful for different data types other than \sphinxcode{\sphinxupquote{float}}.E.g., consider the following program that prints a time specified by some variables.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Some specified time}
\PYG{n}{hour} \PYG{o}{=} \PYG{l+m+mi}{12}
\PYG{n}{minute} \PYG{o}{=} \PYG{l+m+mi}{34}
\PYG{n}{second} \PYG{o}{=} \PYG{l+m+mi}{56}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The time is }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{hour}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{minute}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{second}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
The time is 12:34:56.
\end{sphinxVerbatim}

Imagine you have to show also the date in different formats.The code can become very hard to read/write because
\begin{itemize}
\item {} 
the message is a concatenation of multiple strings and

\item {} 
the integer variables need to be converted to strings.

\end{itemize}

Omitting \sphinxcode{\sphinxupquote{+}} leads to syntax error. Removing \sphinxcode{\sphinxupquote{str}} as follows also does not give the desired format.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The time is }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{hour}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{minute}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{second}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} note the extra spaces}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
The time is  12 : 34 : 56 .
\end{sphinxVerbatim}

To make the code more readable, we can use the \sphinxcode{\sphinxupquote{format}} function as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{message} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The time is }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{:}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{:}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{.}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{message}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{hour}\PYG{p}{,}\PYG{n}{minute}\PYG{p}{,}\PYG{n}{second}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
The time is 12:34:56.
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
We can have multiple \sphinxstyleemphasis{place\sphinxhyphen{}holders} \sphinxcode{\sphinxupquote{\{\}}} inside a string.

\item {} 
We can then provide the contents (any type: numbers, strings..) using the \sphinxcode{\sphinxupquote{format}} function, which

\item {} 
substitutes the place\sphinxhyphen{}holders by the function arguments from left to right.

\end{itemize}

According to the \sphinxhref{https://docs.python.org/3/library/string.html\#format-string-syntax}{string formatting syntax}, we can change the order of substitution using
\begin{itemize}
\item {} 
indices \sphinxstyleemphasis{(0 is the first item)} or

\item {} 
names inside the placeholder \sphinxcode{\sphinxupquote{\{\}}}:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{You should }\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}1\PYGZcb{}}\PYG{l+s+s2}{ what I say instead of what I }\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s2}{.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{do}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{only}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The surname of }\PYG{l+s+si}{\PYGZob{}first\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}last\PYGZcb{}}\PYG{l+s+s2}{ is }\PYG{l+s+si}{\PYGZob{}last\PYGZcb{}}\PYG{l+s+s2}{.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{first}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{John}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{last}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Doe}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
You should do only what I say instead of what I do.
The surname of John Doe is Doe.
\end{sphinxVerbatim}

You can even put variables inside the format specification directly and have a nested string formatting.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{align}\PYG{p}{,} \PYG{n}{width} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZca{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{5}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZob{}\PYGZob{}}\PYG{l+s+s2}{:*}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{align}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{width}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZcb{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} note the syntax f\PYGZdq{}...\PYGZdq{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
3333.3333333333335
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Play with the following widget to learn more about the formating specification.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
What happens when \sphinxcode{\sphinxupquote{align}} is none but \sphinxcode{\sphinxupquote{fill}} is \sphinxcode{\sphinxupquote{*}}?

\item {} 
What happens when the \sphinxcode{\sphinxupquote{expression}} is a multi\sphinxhyphen{}line string?

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{ipywidgets} \PYG{k+kn}{import} \PYG{n}{interact}
\PYG{n+nd}{@interact}\PYG{p}{(}\PYG{n}{expression}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ABC}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
          \PYG{n}{fill}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
          \PYG{n}{align}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{None}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZca{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZca{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
          \PYG{n}{width}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}objectt}\PYG{p}{(}\PYG{n}{expression}\PYG{p}{,}\PYG{n}{fill}\PYG{p}{,}\PYG{n}{align}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZca{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{width}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{format\PYGZus{}spec} \PYG{o}{=} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZob{}\PYGZob{}}\PYG{l+s+s2}{:}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{fill}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{align}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{if} \PYG{n}{width}\PYG{o}{==}\PYG{l+m+mi}{0} \PYG{k}{else} \PYG{n}{width}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZcb{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Format spec:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{format\PYGZus{}spec}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Print:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{format\PYGZus{}spec}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n+nb}{eval}\PYG{p}{(}\PYG{n}{expression}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(Text(value=\PYGZdq{}\PYGZsq{}ABC\PYGZsq{}\PYGZdq{}, description=\PYGZsq{}expression\PYGZsq{}), Text(value=\PYGZsq{}*\PYGZsq{}, description=\PYGZsq{}fill\PYGZsq{}), Drop…
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
It returns a ValueError because align must be specified when fill is.

\item {} 
The newline character is simply regarded a character. The formatting is not applied line\sphinxhyphen{}by\sphinxhyphen{}line. E.g., try ‘ABC\textbackslash{}nDEF’.

\end{enumerate}


\chapter{Expressions and Arithmetic}
\label{\detokenize{Lecture2/Expressions and Arithmetic:expressions-and-arithmetic}}\label{\detokenize{Lecture2/Expressions and Arithmetic::doc}}

\section{Operators}
\label{\detokenize{Lecture2/Expressions and Arithmetic:operators}}
The followings are common operators you can use to form an expression in Python:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Operator
&\sphinxstyletheadfamily 
Operation
&\sphinxstyletheadfamily 
Example
\\
\hline
unary \sphinxcode{\sphinxupquote{\sphinxhyphen{}}}
&
Negation
&
\sphinxcode{\sphinxupquote{\sphinxhyphen{}y}}
\\
\hline
\sphinxcode{\sphinxupquote{+}}
&
Addition
&
\sphinxcode{\sphinxupquote{x + y}}
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}}}
&
Subtraction
&
\sphinxcode{\sphinxupquote{x \sphinxhyphen{} y}}
\\
\hline
\sphinxcode{\sphinxupquote{*}}
&
Multiplication
&
\sphinxcode{\sphinxupquote{x*y}}
\\
\hline
\sphinxcode{\sphinxupquote{/}}
&
Division
&
\sphinxcode{\sphinxupquote{x/y}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}} in the examples are called the \sphinxstyleemphasis{left and right operands} respectively.

\item {} 
The first operator is a \sphinxstyleemphasis{unary operator}, which operates on just one operand.(\sphinxcode{\sphinxupquote{+}} can also be used as a unary operator, but that is not useful.)

\item {} 
All other operators are \sphinxstyleemphasis{binary operators}, which operate on two operands.

\end{itemize}

Python also supports some more operators such as the followings:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Operator
&\sphinxstyletheadfamily 
Operation
&\sphinxstyletheadfamily 
Example
\\
\hline
\sphinxcode{\sphinxupquote{//}}
&
Integer division
&
\sphinxcode{\sphinxupquote{x//y}}
\\
\hline
\sphinxcode{\sphinxupquote{\%}}
&
Modulo
&
\sphinxcode{\sphinxupquote{x\%y}}
\\
\hline
\sphinxcode{\sphinxupquote{**}}
&
Exponentiation
&
\sphinxcode{\sphinxupquote{x**y}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} ipywidgets to demonstrate the operations of binary operators}
\PYG{k+kn}{from} \PYG{n+nn}{ipywidgets} \PYG{k+kn}{import} \PYG{n}{interact}
\PYG{n}{binary\PYGZus{}operators} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ + }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ \PYGZhy{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{//}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{//}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{**}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{**}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{n+nd}{@interact}\PYG{p}{(}\PYG{n}{operand1}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
          \PYG{n}{operator}\PYG{o}{=}\PYG{n}{binary\PYGZus{}operators}\PYG{p}{,}
          \PYG{n}{operand2}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{binary\PYGZus{}operation}\PYG{p}{(}\PYG{n}{operand1}\PYG{p}{,}\PYG{n}{operator}\PYG{p}{,}\PYG{n}{operand2}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{expression} \PYG{o}{=} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{operand1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{operator}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{operand2}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{value} \PYG{o}{=} \PYG{n+nb}{eval}\PYG{p}{(}\PYG{n}{expression}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Expression:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{:}\PYG{l+s+s2}{\PYGZgt{}11}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{expression}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Value:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{:}\PYG{l+s+s2}{\PYGZgt{}11}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{value}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Type:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{:}\PYG{l+s+s2}{\PYGZgt{}11}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(Text(value=\PYGZsq{}10\PYGZsq{}, description=\PYGZsq{}operand1\PYGZsq{}), Dropdown(description=\PYGZsq{}operator\PYGZsq{}, options=\PYGZob{}\PYGZsq{}+\PYGZsq{}:…
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} What is the difference between \sphinxcode{\sphinxupquote{/}} and \sphinxcode{\sphinxupquote{//}}?
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{/}} is the usual division, and so \sphinxcode{\sphinxupquote{10/3}} returns the floating\sphinxhyphen{}point number \(3.\dot{3}\).

\item {} 
\sphinxcode{\sphinxupquote{//}} is integer division, and so \sphinxcode{\sphinxupquote{10//3}} gives the integer quotient 3.

\end{itemize}

\sphinxstylestrong{What does the modulo operator \sphinxcode{\sphinxupquote{\%}} do?}

You can think of it as computing the remainder, but the \sphinxhref{https://docs.python.org/3/reference/expressions.html\#binary-arithmetic-operations}{truth} is more complicated than required for the course.

\sphinxstylestrong{Exercise} What does \sphinxcode{\sphinxupquote{'abc' * 3}} mean? What about \sphinxcode{\sphinxupquote{10 * 'a'}}?
\begin{itemize}
\item {} 
The first expression means concatenating \sphinxcode{\sphinxupquote{'abc'}} three times.

\item {} 
The second means concatenating \sphinxcode{\sphinxupquote{'a'}} ten times.

\end{itemize}

\sphinxstylestrong{Exercise} How can you change the default operands (\sphinxcode{\sphinxupquote{10}} and \sphinxcode{\sphinxupquote{3}}) for different operators so that the overall expression has type \sphinxcode{\sphinxupquote{float}}.Do you need to change all the operands to \sphinxcode{\sphinxupquote{float}}?
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{/}} already returns a \sphinxcode{\sphinxupquote{float}}.

\item {} 
For all other operators, changing at least one of the operands to \sphinxcode{\sphinxupquote{float}} will return a \sphinxcode{\sphinxupquote{float}}.

\end{itemize}


\section{Operator Precedence and Associativity}
\label{\detokenize{Lecture2/Expressions and Arithmetic:operator-precedence-and-associativity}}
An expression can consist of a sequence of operations performed in a row such as \sphinxcode{\sphinxupquote{x + y*z}}.

\sphinxstylestrong{How to determine which operation should be performed first?}

Like arithmetics, the order of operations is decided based on the following rules applied sequentially:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxstyleemphasis{grouping} by parentheses: inner grouping first

\item {} 
operator \sphinxstyleemphasis{precedence/priority}: higher precedence first

\item {} 
operator \sphinxstyleemphasis{associativity}:
\begin{itemize}
\item {} 
left associativity: left operand first

\item {} 
right associativity: right operand first

\end{itemize}

\end{enumerate}

\sphinxstylestrong{What are the operator precedence and associativity?}

The following table gives a concise summary:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Operators
&\sphinxstyletheadfamily 
Associativity
\\
\hline
\sphinxcode{\sphinxupquote{**}}
&
right
\\
\hline
\sphinxcode{\sphinxupquote{\sphinxhyphen{}}} (unary)
&
right
\\
\hline
\sphinxcode{\sphinxupquote{*}},\sphinxcode{\sphinxupquote{/}},\sphinxcode{\sphinxupquote{//}},\sphinxcode{\sphinxupquote{\%}}
&
left
\\
\hline
\sphinxcode{\sphinxupquote{+}},\sphinxcode{\sphinxupquote{\sphinxhyphen{}}}
&
left
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstylestrong{Exercise} Play with the following widget to understand the precedence and associativity of different operators.In particular, explain whether the expression \sphinxcode{\sphinxupquote{\sphinxhyphen{}10 ** 2*3}} gives \((-10)^{2\times 3}= 10^6 = 1000000\).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{ipywidgets} \PYG{k+kn}{import} \PYG{n}{fixed}
\PYG{n+nd}{@interact}\PYG{p}{(}\PYG{n}{operator1}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{None}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{unary \PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
          \PYG{n}{operand1}\PYG{o}{=}\PYG{n}{fixed}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
          \PYG{n}{operator2}\PYG{o}{=}\PYG{n}{binary\PYGZus{}operators}\PYG{p}{,}
          \PYG{n}{operand2}\PYG{o}{=}\PYG{n}{fixed}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
          \PYG{n}{operator3}\PYG{o}{=}\PYG{n}{binary\PYGZus{}operators}\PYG{p}{,}
          \PYG{n}{operand3}\PYG{o}{=}\PYG{n}{fixed}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
          \PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{three\PYGZus{}operators}\PYG{p}{(}\PYG{n}{operator1}\PYG{p}{,}\PYG{n}{operand1}\PYG{p}{,}\PYG{n}{operator2}\PYG{p}{,}\PYG{n}{operand2}\PYG{p}{,}\PYG{n}{operator3}\PYG{p}{,}\PYG{n}{operand3}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{expression} \PYG{o}{=} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{operator1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{operand1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{operator2}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{operand2}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{operator3}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{operand3}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{value} \PYG{o}{=} \PYG{n+nb}{eval}\PYG{p}{(}\PYG{n}{expression}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Expression:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{:}\PYG{l+s+s2}{\PYGZgt{}11}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{expression}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Value:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{:}\PYG{l+s+s2}{\PYGZgt{}11}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{value}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Type:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{:}\PYG{l+s+s2}{\PYGZgt{}11}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(Dropdown(description=\PYGZsq{}operator1\PYGZsq{}, options=\PYGZob{}\PYGZsq{}None\PYGZsq{}: \PYGZsq{}\PYGZsq{}, \PYGZsq{}unary \PYGZhy{}\PYGZsq{}: \PYGZsq{}\PYGZhy{}\PYGZsq{}\PYGZcb{}, value=\PYGZsq{}\PYGZsq{}), Dropd…
\end{sphinxVerbatim}

The expression evaluates to \((-(10^2))\times 3=-300\) instead because the exponentiation operator \sphinxcode{\sphinxupquote{**}} has higher precedence than both the multiplication \sphinxcode{\sphinxupquote{*}} and the negation operators \sphinxcode{\sphinxupquote{\sphinxhyphen{}}}.

\sphinxstylestrong{Exercise} To avoid confusion in the order of operations, we should follow the \sphinxhref{https://www.python.org/dev/peps/pep-0008/\#other-recommendations}{style guide} when writing expression.What is the proper way to write \sphinxcode{\sphinxupquote{\sphinxhyphen{}10 ** 2*3}}?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} can use use code\PYGZhy{}prettify extension to fix incorrect styles}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}300
\end{sphinxVerbatim}


\section{Augmented Assignment Operators}
\label{\detokenize{Lecture2/Expressions and Arithmetic:augmented-assignment-operators}}\begin{itemize}
\item {} 
For convenience, Python defines the \sphinxhref{https://docs.python.org/3/reference/simple\_stmts.html\#grammar-token-augmented-assignment-stmt}{augmented assignment operators} such as \sphinxcode{\sphinxupquote{+=}}, where

\item {} 
\sphinxcode{\sphinxupquote{x += 1}} means \sphinxcode{\sphinxupquote{x = x + 1}}.

\end{itemize}

The following widgets demonstrate other augmented assignment operators.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{ipywidgets} \PYG{k+kn}{import} \PYG{n}{interact}\PYG{p}{,} \PYG{n}{fixed}
\PYG{n+nd}{@interact}\PYG{p}{(}\PYG{n}{initial\PYGZus{}value}\PYG{o}{=}\PYG{n}{fixed}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
          \PYG{n}{operator}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{//=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{**=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
          \PYG{n}{operand}\PYG{o}{=}\PYG{n}{fixed}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{binary\PYGZus{}operation}\PYG{p}{(}\PYG{n}{initial\PYGZus{}value}\PYG{p}{,}\PYG{n}{operator}\PYG{p}{,}\PYG{n}{operand}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{assignment} \PYG{o}{=} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{initial\PYGZus{}value}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{x }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{operator}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{operand}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{\PYGZus{}locals} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{n}{exec}\PYG{p}{(}\PYG{n}{assignment}\PYG{p}{,}\PYG{k+kc}{None}\PYG{p}{,}\PYG{n}{\PYGZus{}locals}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s+s2}{Assignments:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{assignment}\PYG{l+s+si}{:}\PYG{l+s+s2}{\PYGZgt{}10}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{x: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{\PYGZus{}locals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ (}\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{\PYGZus{}locals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{)}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(Dropdown(description=\PYGZsq{}operator\PYGZsq{}, options=(\PYGZsq{}+=\PYGZsq{}, \PYGZsq{}\PYGZhy{}=\PYGZsq{}, \PYGZsq{}*=\PYGZsq{}, \PYGZsq{}/=\PYGZsq{}, \PYGZsq{}//=\PYGZsq{}, \PYGZsq{}\PYGZpc{}=\PYGZsq{}, \PYGZsq{}**=\PYGZsq{}), v…
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Can we create an expression using (augmented) assignment operators? Try running the code to see the effect.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{p}{(}\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{15}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{  File}\PYG{n+nn}{ \PYGZdq{}\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}62\PYGZhy{}566073d2d63b\PYGZgt{}\PYGZdq{}}\PYG{g+gt}{, line }\PYG{l+m+mi}{1}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{p}{(}\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{15}\PYG{p}{)}
         \PYG{o}{\PYGZca{}}
\PYG{n+ne}{SyntaxError}: invalid syntax
\end{sphinxVerbatim}

Assignment operators are used in assignment statements, which are not expressions because they cannot be evaluated.


\chapter{Conditional Execution}
\label{\detokenize{Lecture3/Conditional Execution:conditional-execution}}\label{\detokenize{Lecture3/Conditional Execution::doc}}

\section{Motivation}
\label{\detokenize{Lecture3/Conditional Execution:motivation}}
Conditional execution means running different pieces of code based on different conditions. Why?

For instance, when trying to compute \sphinxcode{\sphinxupquote{a/b}}, \sphinxcode{\sphinxupquote{b}} may be \sphinxcode{\sphinxupquote{0}} and division by \sphinxcode{\sphinxupquote{0}} is invalid.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{multiply\PYGZus{}or\PYGZus{}divide}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a:}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{, b:}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{, a*b:}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{, a/b:}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a} \PYG{o}{/} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}


\PYG{n}{multiply\PYGZus{}or\PYGZus{}divide}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{multiply\PYGZus{}or\PYGZus{}divide}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} multiplication is valid but not shown}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
a:1, b:2, a*b:2, a/b:0.5
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{ZeroDivisionError}\PYG{g+gWhitespace}{                         }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c6f0ad2b2b09}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{4} 
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{5} \PYG{n}{multiply\PYGZus{}or\PYGZus{}divide}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{6} \PYG{n}{multiply\PYGZus{}or\PYGZus{}divide}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} multiplication is valid but not shown}

\PYG{n+nn}{\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}2\PYGZhy{}c6f0ad2b2b09\PYGZgt{}} in \PYG{n+ni}{multiply\PYGZus{}or\PYGZus{}divide}\PYG{n+nt}{(a, b)}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{k}{def} \PYG{n+nf}{multiply\PYGZus{}or\PYGZus{}divide}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{2}     \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a:}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{, b:}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{, a*b:}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{, a/b:}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a} \PYG{o}{/} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{3} 
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{4} 
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{5} \PYG{n}{multiply\PYGZus{}or\PYGZus{}divide}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n+ne}{ZeroDivisionError}: division by zero
\end{sphinxVerbatim}

Can we skip only the division but not multiplication when \sphinxcode{\sphinxupquote{b}} is \sphinxcode{\sphinxupquote{0}}?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{multiply\PYGZus{}or\PYGZus{}divide}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fix} \PYG{o}{=} \PYG{n}{a} \PYG{o}{/} \PYG{n}{b} \PYG{k}{if} \PYG{n}{b} \PYG{k}{else} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{undefined}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a:}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{, b:}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{, a*b:}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{, a/b:}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}\PYG{p}{,} \PYG{n}{fix}\PYG{p}{)}\PYG{p}{)}


\PYG{n}{multiply\PYGZus{}or\PYGZus{}divide}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{multiply\PYGZus{}or\PYGZus{}divide}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} multiplication is valid but not shown}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
a:1, b:2, a*b:2, a/b:0.5
a:1, b:0, a*b:0, a/b:undefined
\end{sphinxVerbatim}

The above solution involve:
\begin{itemize}
\item {} 
a \sphinxstyleemphasis{boolean expression} \sphinxcode{\sphinxupquote{fix}} that checks whether a condition holds, and

\item {} 
a \sphinxstyleemphasis{conditional construct} \sphinxcode{\sphinxupquote{... if ... else ...}} that specify which code block should be executed under what condition.

\end{itemize}


\section{Boolean expressions}
\label{\detokenize{Lecture3/Conditional Execution:boolean-expressions}}

\subsection{Comparison Operators}
\label{\detokenize{Lecture3/Conditional Execution:comparison-operators}}
\sphinxstylestrong{How to compare different values?}

Like the equality and inequality relationships in mathematics,Python also have binary \sphinxhref{https://docs.python.org/3/reference/expressions.html\#comparisons}{\sphinxstyleemphasis{comparison/relational operators}}:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Expression
&\sphinxstyletheadfamily 
True iff
\\
\hline
\sphinxcode{\sphinxupquote{x == y}}
&
\(x=y\).
\\
\hline
\sphinxcode{\sphinxupquote{x < y}}
&
\(x<y\).
\\
\hline
\sphinxcode{\sphinxupquote{x <= y}}
&
\(x\leq y\).
\\
\hline
\sphinxcode{\sphinxupquote{x > y}}
&
\(x>y\).
\\
\hline
\sphinxcode{\sphinxupquote{x >= y}}
&
\(x\geq y\).
\\
\hline
\sphinxcode{\sphinxupquote{x != y}}
&
\(x\neq y\).
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Explore these operators using the widgets below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Comparisons}
\PYG{k+kn}{from} \PYG{n+nn}{ipywidgets} \PYG{k+kn}{import} \PYG{n}{interact}
\PYG{n}{comparison\PYGZus{}operators} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZgt{}=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n+nd}{@interact}\PYG{p}{(}\PYG{n}{operand1}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
          \PYG{n}{operator}\PYG{o}{=}\PYG{n}{comparison\PYGZus{}operators}\PYG{p}{,}
          \PYG{n}{operand2}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{comparison}\PYG{p}{(}\PYG{n}{operand1}\PYG{p}{,}\PYG{n}{operator}\PYG{p}{,}\PYG{n}{operand2}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{expression} \PYG{o}{=} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{operand1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{operator}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{operand2}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{value} \PYG{o}{=} \PYG{n+nb}{eval}\PYG{p}{(}\PYG{n}{expression}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Expression:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{:}\PYG{l+s+s2}{\PYGZgt{}11}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{expression}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Value:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{:}\PYG{l+s+s2}{\PYGZgt{}11}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{value}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Type:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{:}\PYG{l+s+s2}{\PYGZgt{}11}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(Text(value=\PYGZsq{}10\PYGZsq{}, description=\PYGZsq{}operand1\PYGZsq{}), Dropdown(description=\PYGZsq{}operator\PYGZsq{}, options=(\PYGZsq{}==\PYGZsq{}…
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
These operators return either \sphinxcode{\sphinxupquote{True}} or \sphinxcode{\sphinxupquote{False}}, which are \sphinxcode{\sphinxupquote{keywords}} of type \sphinxstyleemphasis{boolean}.

\item {} 
The expressions are called \sphinxstyleemphasis{boolean expressions} or \sphinxstyleemphasis{predicates}, named after \sphinxhref{https://en.wikipedia.org/wiki/George\_Boole}{George Boole}.

\item {} 
N.b., the equality operator \sphinxcode{\sphinxupquote{==}} consists of \sphinxstyleemphasis{two equal signs}, different from the assignment operator \sphinxcode{\sphinxupquote{=}}.

\end{itemize}

\sphinxstylestrong{What is the precedence of comparison operators?}

All the comparison operators have the \sphinxhref{https://docs.python.org/3/reference/expressions.html?highlight=precedence\#operator-precedence}{same precedence} lower than that of \sphinxcode{\sphinxupquote{+}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{3}  \PYG{c+c1}{\PYGZsh{} (1 + 2) \PYGZgt{}= 3}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

Python allows multiple comparison operations to be chained together:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{2.0} \PYG{o}{==} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{}equivalent to (2.0 ==2) and (2\PYGZgt{}1)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\sphinxstylestrong{What is the associativity?}

Comparison operations are \sphinxhref{https://en.wikipedia.org/wiki/Operator\_associativity\#Non-associative\_operators}{\sphinxstyleemphasis{non\sphinxhyphen{}associative}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mf}{2.0} \PYG{o}{==} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{2.0} \PYG{o}{==} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} not the same as 2.0 == 2 \PYGZgt{} 1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(False, False)
\end{sphinxVerbatim}

\sphinxstylestrong{Errorata} in {[}Halterman17{]} due to a misunderstanding of non\sphinxhyphen{}associativity vs left\sphinxhyphen{}to\sphinxhyphen{}right evaluation order:
\begin{itemize}
\item {} 
\sphinxhref{https://archive.org/stream/2018Fundamentals.ofPython?ref=ol\#page/n79/mode/1up}{Halterman17, p.69}:
\begin{quote}

The relational operators are binary operators and are all \textasciitilde{}left associative\textasciitilde{} \sphinxstylestrong{non\sphinxhyphen{}associative}.
\end{quote}

\item {} 
\sphinxhref{https://archive.org/stream/2018Fundamentals.ofPython?ref=ol\#page/n60/mode/1up}{Halterman17, p.50, Table 3.2}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{=}} should be non\sphinxhyphen{}associative instead of right\sphinxhyphen{}associative.

\item {} 
The corresponding table in \sphinxcode{\sphinxupquote{Lecture2/Expressions and Arithmetic.ipynb}} should also be corrected accordingly.

\end{itemize}

\end{itemize}

\sphinxstylestrong{Exercise} Explain why the following boolean expressions have different values.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3} \PYG{o}{!=} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{l+m+mi}{3} \PYG{o}{!=} \PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(True, False)
\end{sphinxVerbatim}

The second expression is not a chained comparison:
\begin{itemize}
\item {} 
The expressions in the parentheses are evaluated to boolean values first to \sphinxcode{\sphinxupquote{True}}, and so

\item {} 
the overall expression \sphinxcode{\sphinxupquote{True < True}} is evaluated to \sphinxcode{\sphinxupquote{False}}.

\end{itemize}

\sphinxstylestrong{Exercise} The comparison operators can be applied to different data types, as illustrated below.Explain the meaning of the operators in each of the following expressions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Comparisons beyond numbers}
\PYG{n+nd}{@interact}\PYG{p}{(}\PYG{n}{expression}\PYG{o}{=}\PYG{p}{[}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10 == 10.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ == }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ == }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{A }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ != }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ \PYGZgt{} }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{aBcd}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ \PYGZlt{} }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{abd}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ != 64}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ \PYGZlt{} 64}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{p}{]}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{relational\PYGZus{}expression}\PYG{p}{(}\PYG{n}{expression}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{eval}\PYG{p}{(}\PYG{n}{expression}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(Dropdown(description=\PYGZsq{}expression\PYGZsq{}, options=(\PYGZsq{}10 == 10.\PYGZsq{}, \PYGZsq{}\PYGZdq{}A\PYGZdq{} == \PYGZdq{}A\PYGZdq{}\PYGZsq{}, \PYGZsq{}\PYGZdq{}A\PYGZdq{} == \PYGZdq{}A \PYGZdq{}\PYGZsq{}, \PYGZsq{}\PYGZdq{}…
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Checks whether an integer is equal to a floating point number.

\item {} 
Checks whether two characters are the same.

\item {} 
Checks whether two strings are the same. Note the space character.

\item {} 
Checks whether a character is larger than the order character according to their unicodes.

\item {} 
Checks whether a string is lexicographically smaller than the other string.

\item {} 
Checks whether a character is not equal to an integer.

\item {} 
TypeError because there is no implementation that evaluates whether a string is smaller than an integer.

\end{enumerate}

\sphinxstylestrong{Is \sphinxcode{\sphinxupquote{!}} the same as the \sphinxcode{\sphinxupquote{not}} operator?}

\sphinxstylestrong{Errata} There is an error in \sphinxhref{https://archive.org/stream/2018Fundamentals.ofPython?ref=ol\#page/n79/mode/1up}{Halterman17, p.69} due to confusion with C language:
\begin{quote}

… \sphinxcode{\sphinxupquote{!(x >= 10)}} and \sphinxcode{\sphinxupquote{!(10 <= x)}} are \textasciitilde{}equivalent\textasciitilde{} \sphinxstylestrong{invalid}.
\end{quote}
\begin{itemize}
\item {} 
We can write \sphinxcode{\sphinxupquote{1 != 2}} as \sphinxcode{\sphinxupquote{not 1 == 2}} but not \sphinxcode{\sphinxupquote{!(1 == 2)}} because

\item {} 
\sphinxcode{\sphinxupquote{!}} is not a logical operator. It is used to call a \sphinxhref{https://ipython.readthedocs.io/en/stable/interactive/tutorial.html?highlight=system\%20call\#system-shell-commands}{system shell command} in IPython.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{!}\PYG{o}{(}\PYG{n+nv}{1} \PYG{o}{=}\PYG{o}{=} \PYG{l+m}{2}\PYG{o}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
/bin/bash: 1: command not found
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{!}ls  \PYGZsh{} a bash \PYG{n+nb}{command} that lists files in the current directory
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Conditional Execution.ipynb\PYGZsq{}		        Iteration.ipynb
\PYGZsq{}Conditional Execution.ipynb:Zone.Identifier\PYGZsq{}   Iteration.ipynb:Zone.Identifier
\end{sphinxVerbatim}

\sphinxstylestrong{How to compare floating point numbers?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{y} \PYG{o}{=} \PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}
\PYG{n}{x} \PYG{o}{==} \PYG{n}{y}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

Why False? Shouldn’t \((x^{\frac13})^3=x\)?
\begin{itemize}
\item {} 
Floating point numbers have finite precisions and so

\item {} 
we should instead check whether the numbers are close enough.

\end{itemize}

One method of comparing floating point numbers:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}9}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{abs}} is a function that returns the absolute value of its argument. Hence, the above translates to
\begin{equation*}
\begin{split}|x - y| \leq \delta_{\text{abs}}\end{split}
\end{equation*}
or equivalently
\begin{equation*}
\begin{split}y-\delta_{\text{abs}} \leq x \leq y+\delta_{\text{abs}} \end{split}
\end{equation*}
where \(\delta_{\text{abs}}\) is called the \sphinxstyleemphasis{absolute tolerance}.

\sphinxstylestrong{Is an absolute tolerance of \sphinxcode{\sphinxupquote{1e\sphinxhyphen{}9}} good enough?}

What if we want to compare \sphinxcode{\sphinxupquote{x = 1e10}} instead of \sphinxcode{\sphinxupquote{10}}?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{1e10}
\PYG{n}{y} \PYG{o}{=} \PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}
\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}9}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

Floating point numbers “float” at different scales.A better way to use the \sphinxhref{https://docs.python.org/3/library/math.html\#math.isclose}{\sphinxcode{\sphinxupquote{isclose}}} function from \sphinxcode{\sphinxupquote{math}} module.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{n}{math}\PYG{o}{.}\PYG{n}{isclose}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\sphinxstylestrong{How does it work?}

\sphinxcode{\sphinxupquote{math.isclose(x,y)}} implements
\begin{equation*}
\begin{split} |x - y| \leq \max\{\delta_{\text{rel}} \max\{|x|,|y|\},\delta_{\text{abs}}\}\end{split}
\end{equation*}
with the default
\begin{itemize}
\item {} 
\sphinxstyleemphasis{relative tolerance} \(\delta_{\text{rel}}\) equal to \sphinxcode{\sphinxupquote{1e\sphinxhyphen{}9}}, and

\item {} 
absolute tolerance \(\delta_{\text{abs}}\) equal to \sphinxcode{\sphinxupquote{0.0}}.

\end{itemize}

\sphinxstylestrong{Exercise} Write the boolean expression implemented by \sphinxcode{\sphinxupquote{isclose}}. You can use the function \sphinxcode{\sphinxupquote{max(a,b)}} to find the maximum of \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rel\PYGZus{}tol}\PYG{p}{,} \PYG{n}{abs\PYGZus{}tol} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}9}\PYG{p}{,} \PYG{l+m+mf}{0.0}
\PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}100}\PYG{p}{,} \PYG{l+m+mf}{2e\PYGZhy{}100}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{y}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{rel\PYGZus{}tol} \PYG{o}{*} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{abs\PYGZus{}tol}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}


\subsection{Boolean Operations}
\label{\detokenize{Lecture3/Conditional Execution:boolean-operations}}
Since chained comparisons are non\sphinxhyphen{}associative. It follows a different evaluation rule than arithmetical operators.

E.g., \sphinxcode{\sphinxupquote{1 <= 2 < 3 != 4}} is evaluated as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o+ow}{and} \PYG{l+m+mi}{2} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3} \PYG{o+ow}{and} \PYG{l+m+mi}{3} \PYG{o}{!=} \PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

The above is called a \sphinxstyleemphasis{compound boolean expression}, which is formed using the \sphinxstyleemphasis{boolean/logical operator} \sphinxcode{\sphinxupquote{and}}.

\sphinxstylestrong{Why use boolean operators?}

What if we want to check whether a number is either \(< 0\) or \(\geq 100\)?Can we achieve this only by chaining the comparison operators or applying the logical \sphinxcode{\sphinxupquote{and}}?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Check if a number is outside a range.}
\PYG{n+nd}{@interact}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{15}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{check\PYGZus{}out\PYGZus{}of\PYGZus{}range}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{x\PYGZus{}} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    \PYG{n}{is\PYGZus{}out\PYGZus{}of\PYGZus{}range} \PYG{o}{=} \PYG{n}{x\PYGZus{}}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0} \PYG{o+ow}{or} \PYG{n}{x\PYGZus{}}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{100}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Out of range [0,100):}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{is\PYGZus{}out\PYGZus{}of\PYGZus{}range}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(Text(value=\PYGZsq{}15\PYGZsq{}, description=\PYGZsq{}x\PYGZsq{}), Output()), \PYGZus{}dom\PYGZus{}classes=(\PYGZsq{}widget\PYGZhy{}interact\PYGZsq{},))
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{and}} alone is not \sphinxhref{https://en.wikipedia.org/wiki/Functional\_completeness}{functionally complete},  i.e., not enough to give all possible boolean functions.

\item {} 
In addition to \sphinxcode{\sphinxupquote{and}}, we can also use \sphinxcode{\sphinxupquote{or}} and \sphinxcode{\sphinxupquote{not}}.

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{x}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{y}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{x and y}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{x or y}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{not x}}
\\
\hline
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{False}}
\\
\hline
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{False}}
\\
\hline
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{True}}
\\
\hline
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{True}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The above table is called a \sphinxstyleemphasis{truth table}. It enumerates all possible input and output combinations for each boolean operator.

\sphinxstylestrong{How are chained logical operators evaluated?What are the precedence and associativity for the logical operators?}
\begin{itemize}
\item {} 
All binary boolean operators are left associative.

\item {} 
\sphinxhref{https://docs.python.org/3/reference/expressions.html?highlight=precedence\#operator-precedence}{Precedence}: \sphinxcode{\sphinxupquote{comparison operators}} > \sphinxcode{\sphinxupquote{not}} > \sphinxcode{\sphinxupquote{and}} > \sphinxcode{\sphinxupquote{or}}

\end{itemize}

\sphinxstylestrong{Exercise} Explain what the values of the following two compound boolean expressions are:
\begin{itemize}
\item {} 
Expression A: \sphinxcode{\sphinxupquote{True or False and True}}

\item {} 
Expression B: \sphinxcode{\sphinxupquote{True and False and True}}

\item {} 
Expression C: \sphinxcode{\sphinxupquote{True or True and False}}

\end{itemize}
\begin{itemize}
\item {} 
Expression A evaluates to \sphinxcode{\sphinxupquote{True}} because \sphinxcode{\sphinxupquote{and}} has higher precedence and so the expression has the same value as \sphinxcode{\sphinxupquote{True or (False and True)}}.

\item {} 
Expression B evaluates to \sphinxcode{\sphinxupquote{False}} because \sphinxcode{\sphinxupquote{and}} is left associative and so the expression has the same value as \sphinxcode{\sphinxupquote{(True and False) and True}}.

\item {} 
Expression C evaluates to \sphinxcode{\sphinxupquote{True}} because \sphinxcode{\sphinxupquote{and}} has a higher precedence and so the expression has the same value as \sphinxcode{\sphinxupquote{True or (True and False)}}. Note that \sphinxcode{\sphinxupquote{(True or True) and False}} evaluates to something \sphinxcode{\sphinxupquote{False}} instead, so precedence matters.

\end{itemize}

Instead of following the precedence and associativity, however, a compound boolean expression uses a \sphinxhref{https://docs.python.org/3/reference/expressions.html?highlight=precedence\#boolean-operations}{short\sphinxhyphen{}circuit evaluation}.

To understand this, we will use the following function to evaluate a boolean expression verbosely.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{verbose}\PYG{p}{(}\PYG{n+nb}{id}\PYG{p}{,}\PYG{n}{boolean}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Identify evaluated boolean expressions.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{id}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{evaluated:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{boolean}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{boolean}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{verbose}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{verbose}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kc}{True}\PYG{p}{)} \PYG{o+ow}{or} \PYG{n}{verbose}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{k+kc}{False}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{verbose}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} True or (False and True)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1 evaluated: True
A evaluated: True
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\sphinxstylestrong{Why expression 2 and 3 are not evaluated?}

Because True or … must be True (Why?) so Python does not look further. From the \sphinxhref{https://docs.python.org/3/reference/expressions.html?highlight=precedence\#boolean-operations}{documentation}:
\begin{quote}

The expression \sphinxcode{\sphinxupquote{x or y}} first evaluates \sphinxcode{\sphinxupquote{x}}; if \sphinxcode{\sphinxupquote{x}} is true, its value is returned; otherwise, \sphinxcode{\sphinxupquote{y}} is evaluated and the resulting value is returned.
\end{quote}

Note that:
\begin{itemize}
\item {} 
Even though \sphinxcode{\sphinxupquote{or}} has lower precedence than \sphinxcode{\sphinxupquote{and}}, it is still evaluated first.

\item {} 
The evaluation order for logical operators is left\sphinxhyphen{}to\sphinxhyphen{}right.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{verbose}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{verbose}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{k+kc}{True}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{verbose}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{k+kc}{False}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{verbose}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} (True and False) and True}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
4 evaluated: True
5 evaluated: False
B evaluated: False
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

\sphinxstylestrong{Why expression 6 is not evaluated?}

\sphinxcode{\sphinxupquote{True and False and ...}} must be \sphinxcode{\sphinxupquote{False}} so Python does not look further.
\begin{quote}

The expression \sphinxcode{\sphinxupquote{x and y}} first evaluates \sphinxcode{\sphinxupquote{x}}; if \sphinxcode{\sphinxupquote{x}} is false, its value is returned; otherwise, \sphinxcode{\sphinxupquote{y}} is evaluated and the resulting value is returned.
\end{quote}

Indeed, logical operators can even be applied to non\sphinxhyphen{}boolean operands. From the \sphinxhref{https://docs.python.org/3/reference/expressions.html?highlight=precedence\#boolean-operations}{documentation}:
\begin{quote}

In the context of Boolean operations, and also when expressions are used by control flow statements, the following values are interpreted as false: \sphinxcode{\sphinxupquote{False}}, None, numeric zero of all types, and empty strings and containers (including strings, tuples, lists, dictionaries, sets and frozensets). All other values are interpreted as true.
\end{quote}

\sphinxstylestrong{Exercise} How does the following code work?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{You have entered}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{input}\PYG{p}{(}\PYG{p}{)} \PYG{o+ow}{or} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nothing}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
The code replaces empty user input by the default string \sphinxcode{\sphinxupquote{nothing}} because empty string is regarded as False in a boolean operation.

\item {} 
If user input is non\sphinxhyphen{}empty, it is regarded as True in the boolean expression and returned immediately as the value of the boolean operation.

\end{itemize}

\sphinxstylestrong{Is empty string equal to False?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Is empty string equal False?}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{==}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Is empty string equal False? False
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
An empty string is regarded as False in a boolean operation but

\item {} 
a \sphinxstyleemphasis{comparison operation is not a boolean operation}, even though it forms a boolean expression.

\end{itemize}


\section{Conditional Constructs}
\label{\detokenize{Lecture3/Conditional Execution:conditional-constructs}}
Consider writing a program that sorts values in \sphinxstyleemphasis{ascending} order.A \sphinxstyleemphasis{sorting algorithm} refers to the procedure of sorting values in order.


\subsection{If\sphinxhyphen{}Then Construct}
\label{\detokenize{Lecture3/Conditional Execution:if-then-construct}}
\sphinxstylestrong{How to sort two values?}

Given two values are stored as \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}}, we want to
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{print(x,y)}} if \sphinxcode{\sphinxupquote{x <= y}}, and

\item {} 
\sphinxcode{\sphinxupquote{print(y,x)}} if \sphinxcode{\sphinxupquote{y < x}}.

\end{itemize}

Such a program flow is often represented by a flowchart like the following:



Python provides the \sphinxhref{https://docs.python.org/3/reference/compound\_stmts.html\#the-if-statement}{\sphinxcode{\sphinxupquote{if}} statement} to implement the above \sphinxhref{https://en.wikipedia.org/wiki/Control\_flow}{\sphinxstyleemphasis{control flow}} specified by the diamonds.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Sort two values using if statement}
\PYG{k}{def} \PYG{n+nf}{sort\PYGZus{}two\PYGZus{}values}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{y}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{y} \PYG{o}{\PYGZlt{}} \PYG{n}{x}\PYG{p}{:} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}


\PYG{n+nd}{@interact}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{sort\PYGZus{}two\PYGZus{}values\PYGZus{}app}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{sort\PYGZus{}two\PYGZus{}values}\PYG{p}{(}\PYG{n+nb}{eval}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{eval}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(Text(value=\PYGZsq{}1\PYGZsq{}, description=\PYGZsq{}x\PYGZsq{}), Text(value=\PYGZsq{}0\PYGZsq{}, description=\PYGZsq{}y\PYGZsq{}), Output()), \PYGZus{}dom\PYGZus{}clas…
\end{sphinxVerbatim}

We can visualize the execution as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 350
def sort\PYGZus{}two\PYGZus{}values(x, y):
    if x \PYGZlt{}= y:
        print(x, y)
    if y \PYGZlt{} x: print(y, x)
        
sort\PYGZus{}two\PYGZus{}values(1,0)
sort\PYGZus{}two\PYGZus{}values(1,2)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f283814b358\PYGZgt{}
\end{sphinxVerbatim}

Python use indentation to indicate code blocks or \sphinxstyleemphasis{suite}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{print(x, y)}} (Line 5) is indented to the right of \sphinxcode{\sphinxupquote{if x <= y:}} (Line 4) to indicate it is the body of the if statement.

\item {} 
For convenience, \sphinxcode{\sphinxupquote{if y < x: print(y, x)}} (Line 6) is a one\sphinxhyphen{}liner for an \sphinxcode{\sphinxupquote{if}} statement that only has one line in its block.

\item {} 
Both \sphinxcode{\sphinxupquote{if}} statements (Line 4\sphinxhyphen{}6) are indented to the right of \sphinxcode{\sphinxupquote{def sort\_two\_values(x,y):}} (Line 3) to indicate that they are part of the body of the function \sphinxcode{\sphinxupquote{sort\_two\_values}}.

\end{itemize}

\sphinxstylestrong{How to indent?}
\begin{itemize}
\item {} 
The \sphinxhref{https://www.python.org/dev/peps/pep-0008/\#indentation}{style guide} recommends using 4 spaces for each indentation.

\item {} 
In IPython, you can simply type the \sphinxcode{\sphinxupquote{tab}} key and IPython will likely enter the correct number of spaces for you.

\end{itemize}

\sphinxstylestrong{What if you want to leave a block empty?}

In programming, it is often useful to delay detailed implementations until we have written an overall skeleton.To leave a block empty, Python uses the keyword \sphinxhref{https://docs.python.org/3/tutorial/controlflow.html\#pass-statements}{\sphinxcode{\sphinxupquote{pass}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} write a code skeleton}
\PYG{k}{def} \PYG{n+nf}{sort\PYGZus{}two\PYGZus{}values}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass}
    \PYG{c+c1}{\PYGZsh{} print the smaller value first followed by the larger one}
    
\PYG{n}{sort\PYGZus{}two\PYGZus{}values}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{sort\PYGZus{}two\PYGZus{}values}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

Without \sphinxcode{\sphinxupquote{pass}}, the code will fail to run, preventing you from checking other parts of the code.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} You can add more details to the skeleton step\PYGZhy{}by\PYGZhy{}step}
\PYG{k}{def} \PYG{n+nf}{sort\PYGZus{}two\PYGZus{}values}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{y}\PYG{p}{:}
        \PYG{k}{pass}  
        \PYG{c+c1}{\PYGZsh{} print x before y}
    \PYG{k}{if} \PYG{n}{y} \PYG{o}{\PYGZlt{}} \PYG{n}{x}\PYG{p}{:} \PYG{k}{pass}  \PYG{c+c1}{\PYGZsh{} print y before x}

\PYG{n}{sort\PYGZus{}two\PYGZus{}values}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{sort\PYGZus{}two\PYGZus{}values}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{If\sphinxhyphen{}Then\sphinxhyphen{}Else Construct}
\label{\detokenize{Lecture3/Conditional Execution:if-then-else-construct}}
The sorting algorithm is not efficient enough. Why not?Hint: \sphinxcode{\sphinxupquote{(x <= y) and not (y < x)}} is a \sphinxstyleemphasis{tautology}, i.e., always true.

To improve the efficient, we should implement the following program flow.



This can be down by the \sphinxcode{\sphinxupquote{else}} clause of the \sphinxhref{https://docs.python.org/3/tutorial/controlflow.html\#if-statements}{\sphinxcode{\sphinxupquote{if}} statement}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 350
def sort\PYGZus{}two\PYGZus{}values(x, y):
    if x \PYGZlt{}= y:
        print(x, y)
    else:
        print(y,x)
        
sort\PYGZus{}two\PYGZus{}values(1,0)
sort\PYGZus{}two\PYGZus{}values(1,2)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f282b7be6a0\PYGZgt{}
\end{sphinxVerbatim}

We can also use a \sphinxhref{https://docs.python.org/3/reference/expressions.html\#conditional-expressions}{\sphinxstyleemphasis{conditional expression}} to shorten the code.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sort\PYGZus{}two\PYGZus{}values}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s1}{ }\PYG{l+s+si}{\PYGZob{}1\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{y} \PYG{k}{else} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}1\PYGZcb{}}\PYG{l+s+s1}{ }\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{)}


\PYG{n+nd}{@interact}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{sort\PYGZus{}two\PYGZus{}values\PYGZus{}app}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{sort\PYGZus{}two\PYGZus{}values}\PYG{p}{(}\PYG{n+nb}{eval}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{eval}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(Text(value=\PYGZsq{}1\PYGZsq{}, description=\PYGZsq{}x\PYGZsq{}), Text(value=\PYGZsq{}0\PYGZsq{}, description=\PYGZsq{}y\PYGZsq{}), Output()), \PYGZus{}dom\PYGZus{}clas…
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Explain why the followings have syntax errors.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1} \PYG{k}{if} \PYG{k+kc}{True}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{  File}\PYG{n+nn}{ \PYGZdq{}\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}30\PYGZhy{}1cbab0db8442\PYGZgt{}\PYGZdq{}}\PYG{g+gt}{, line }\PYG{l+m+mi}{1}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{1} \PYG{k}{if} \PYG{k+kc}{True}
             \PYG{o}{\PYGZca{}}
\PYG{n+ne}{SyntaxError}: invalid syntax
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{k}{if} \PYG{k+kc}{True} \PYG{k}{else} \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{0} 
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{  File}\PYG{n+nn}{ \PYGZdq{}\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}31\PYGZhy{}f68814adf81f\PYGZgt{}\PYGZdq{}}\PYG{g+gt}{, line }\PYG{l+m+mi}{1}
    \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{k}{if} \PYG{k+kc}{True} \PYG{k}{else} \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{0}
       \PYG{o}{\PYGZca{}}
\PYG{n+ne}{SyntaxError}: can\PYGZsq{}t assign to conditional expression
\end{sphinxVerbatim}

A conditional expression must be an expression:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
It must give a value under all cases. To enforce that, \sphinxcode{\sphinxupquote{else}} keyword must be provided.

\item {} 
An assignment statement does not return any value and therefore cannot be used for the conditional expression.\sphinxcode{\sphinxupquote{x = 1 if True else 0}} is valid because \sphinxcode{\sphinxupquote{x =}} is not part of the conditional expression.

\end{enumerate}


\subsection{Nested Conditionals}
\label{\detokenize{Lecture3/Conditional Execution:nested-conditionals}}
Consider sorting three values instead of two. A feasible algorithm is as follows:



We can implement the flow using \sphinxstyleemphasis{nested conditional constructs}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sort\PYGZus{}three\PYGZus{}values}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{z}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{y}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{z}\PYG{p}{:}
                \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{x}\PYG{p}{:}
                    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                    \PYG{k}{if} \PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{y}\PYG{p}{:}
                        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
                    \PYG{k}{else}\PYG{p}{:}
                        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}sort\PYGZus{}three\PYGZus{}values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{sort\PYGZus{}three\PYGZus{}values}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{sort\PYGZus{}three\PYGZus{}values}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{sort\PYGZus{}three\PYGZus{}values}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{sort\PYGZus{}three\PYGZus{}values}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{sort\PYGZus{}three\PYGZus{}values}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{sort\PYGZus{}three\PYGZus{}values}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{test\PYGZus{}sort\PYGZus{}three\PYGZus{}values}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 1 2
0 1 2
0 1 2
0 1 2
0 1 2
0 1 2
\end{sphinxVerbatim}

Imagine what would happen if we have to sort many values.To avoid an excessively long line due to the indentation, Python provides the \sphinxcode{\sphinxupquote{elif}} keyword that combines \sphinxcode{\sphinxupquote{else}} and \sphinxcode{\sphinxupquote{if}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sort\PYGZus{}three\PYGZus{}values}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{z}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{y}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{z}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{x}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{y}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}


\PYG{n}{test\PYGZus{}sort\PYGZus{}three\PYGZus{}values}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 1 2
0 1 2
0 1 2
0 1 2
0 1 2
0 1 2
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} The above sorting algorithm is inefficient because some conditions may be checked more than once.Improve the program to eliminate duplicate checks.\sphinxstyleemphasis{Hint:} Do not use chained comparison operators or compound boolean expressions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sort\PYGZus{}three\PYGZus{}values}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{y}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{z}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}
        \PYG{k}{elif} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{z}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{elif} \PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{y}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{x}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
        
\PYG{n}{sort\PYGZus{}three\PYGZus{}values}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{17}\PYG{p}{,}\PYG{l+m+mi}{14}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
10 14 17
\end{sphinxVerbatim}


\chapter{Iteration}
\label{\detokenize{Lecture3/Iteration:iteration}}\label{\detokenize{Lecture3/Iteration::doc}}

\section{Motivation}
\label{\detokenize{Lecture3/Iteration:motivation}}
Many tasks are repetitive:
\begin{itemize}
\item {} 
To print from 1 up to a user\sphinxhyphen{}specified number, which can be arbitrarily large.

\item {} 
To compute the maximum of a sequence of numbers, which can be arbitrarily long.

\item {} 
To repeatedly ask users for input until the input is within the right range.

\end{itemize}

\sphinxstylestrong{How to write code to perform repetitive tasks?}

E.g., can you complete the following code to print from 1 up to a user\sphinxhyphen{}specified number?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
num = int(input(\PYGZsq{}\PYGZgt{}\PYGZsq{}))
if 1 \PYGZlt{} num: print(1)
if 2 \PYGZlt{} num: print(2)
if 3 \PYGZlt{} num: print(3)
\PYGZsh{} YOUR CODE HERE 
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fed686d4f28\PYGZgt{}
\end{sphinxVerbatim}

\sphinxstyleemphasis{code duplication} is not good because:
\begin{itemize}
\item {} 
Duplicate code is hard to read/write/maintain.Imagine there is a small change needed to every duplicate code.

\item {} 
The number of repetitions may not be known before runtime.

\end{itemize}

Instead, programmers write a \sphinxstyleemphasis{loop} which specifies a piece of code to be executed iteratively.


\section{For Loop}
\label{\detokenize{Lecture3/Iteration:for-loop}}

\subsection{Iterate over a sequence}
\label{\detokenize{Lecture3/Iteration:iterate-over-a-sequence}}
\sphinxstylestrong{How to print from 1 up to 4?}

We can use a \sphinxhref{https://docs.python.org/3.3/tutorial/controlflow.html\#for-statements}{\sphinxcode{\sphinxupquote{for}} statement} as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
for i in 1, 2, 3, 4:
    print(i)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fed687726a0\PYGZgt{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{i}} is automatically assigned to each element in the sequence \sphinxcode{\sphinxupquote{1, 2, 3, 4}} one\sphinxhyphen{}by\sphinxhyphen{}one from left to right.

\item {} 
After each assignment, the body \sphinxcode{\sphinxupquote{print(i)}} is executed.

\end{itemize}

N.b., if \sphinxcode{\sphinxupquote{i}} is defined before the for loop, its value will be overwritten.

The assignment is not restricted to integers and can also be a tuple assignment.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tuples} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{c} \PYG{o+ow}{in} \PYG{n}{tuples}\PYG{p}{:} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} one\PYGZhy{}liner}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 l
1 o
2 o
3 p
\end{sphinxVerbatim}

An even shorter code…

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{c} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loop}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 l
1 o
2 o
3 p
\end{sphinxVerbatim}


\subsection{Iterate over a range}
\label{\detokenize{Lecture3/Iteration:iterate-over-a-range}}
\sphinxstylestrong{How to print up to a user\sphinxhyphen{}specified number?}

We can use \sphinxhref{https://docs.python.org/3/library/stdtypes.html\#range}{\sphinxcode{\sphinxupquote{range}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{stop} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{stop}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Why add 1 to the user input number?}

\sphinxcode{\sphinxupquote{range(stop)}} generates a sequence of integers from \sphinxcode{\sphinxupquote{0}} up to \sphinxstyleemphasis{but excluding} \sphinxcode{\sphinxupquote{stop}}.

\sphinxstylestrong{How to start from a number different from \sphinxcode{\sphinxupquote{0}}?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1
2
3
4
\end{sphinxVerbatim}

\sphinxstylestrong{What about a step size different from \sphinxcode{\sphinxupquote{1}}?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} starting number must also be specified. Why?}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0
2
4
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} How to count down from 4 to 0? Do it without addition or subtraction.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
4
3
2
1
0
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Print from \sphinxcode{\sphinxupquote{0}} to a user\sphinxhyphen{}specified number but in steps of \sphinxcode{\sphinxupquote{0.5}}.E.g., if the user inputs \sphinxcode{\sphinxupquote{2}}, the program should print:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{0.0}
\PYG{l+m+mf}{0.5}
\PYG{l+m+mf}{1.0}
\PYG{l+m+mf}{1.5}
\PYG{l+m+mf}{2.0}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Note:} \sphinxcode{\sphinxupquote{range}} only accepts integer arguments.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{num} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} How to print the character \sphinxcode{\sphinxupquote{'*'}} repeatedly for \sphinxcode{\sphinxupquote{m}} rows and \sphinxcode{\sphinxupquote{n}} columns?\sphinxstyleemphasis{Hint:} Use a \sphinxstyleemphasis{nested for loop}, i.e., write a for loop (called \sphinxstyleemphasis{inner loop}) inside the body of another for loop (\sphinxstyleemphasis{outer loop}).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@interact}\PYG{p}{(}\PYG{n}{m}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{n}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{draw\PYGZus{}rectangle}\PYG{p}{(}\PYG{n}{m}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(IntSlider(value=5, description=\PYGZsq{}m\PYGZsq{}, max=10), IntSlider(value=5, description=\PYGZsq{}n\PYGZsq{}, max=10)…
\end{sphinxVerbatim}


\subsection{Iterate over a string}
\label{\detokenize{Lecture3/Iteration:iterate-over-a-string}}
\sphinxstylestrong{What does the following do?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
for character in \PYGZsq{}loop\PYGZsq{}: print(character)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fed686114e0\PYGZgt{}
\end{sphinxVerbatim}

A string is \sphinxstyleemphasis{iterable} because it can be regarded as a sequence of characters.
\begin{itemize}
\item {} 
The function \sphinxhref{https://docs.python.org/3/library/functions.html\#len}{\sphinxcode{\sphinxupquote{len}}} can return the length of a string.

\item {} 
The indexing operator \sphinxcode{\sphinxupquote{{[}{]}}} can return the character of a string at a specified location.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{message} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{loop}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{length:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{characters:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{message}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{message}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{message}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{message}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
length: 4
characters: l o o p
\end{sphinxVerbatim}

We can also iterate over a string as follows although it is less elegant:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loop}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:} \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loop}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
l
o
o
p
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Print a string assigned to \sphinxcode{\sphinxupquote{message}} in reverse.E.g., \sphinxcode{\sphinxupquote{'loop'}} should be printed as \sphinxcode{\sphinxupquote{'pool'}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@interact}\PYG{p}{(}\PYG{n}{message}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loop}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{reverse\PYGZus{}print}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{message}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(Text(value=\PYGZsq{}loop\PYGZsq{}, description=\PYGZsq{}message\PYGZsq{}), Output()), \PYGZus{}dom\PYGZus{}classes=(\PYGZsq{}widget\PYGZhy{}interact\PYGZsq{},))
\end{sphinxVerbatim}


\section{While Loop}
\label{\detokenize{Lecture3/Iteration:while-loop}}
\sphinxstylestrong{How to repeatedly ask the user to enter an input until the user input is not empty?}

Python provides the \sphinxhref{https://docs.python.org/3/reference/compound\_stmts.html\#while}{\sphinxcode{\sphinxupquote{while}} statement} to loop until a specified condition is false.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{o+ow}{not} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Input something please:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:} \PYG{k}{pass}
\end{sphinxVerbatim}

As long as the condition after \sphinxcode{\sphinxupquote{while}} is true, the body gets executed repeatedly. In the above example,
\begin{itemize}
\item {} 
if user press enter without inputting anything,

\item {} 
\sphinxcode{\sphinxupquote{input}} returns an empty string \sphinxcode{\sphinxupquote{''}}, which is \sphinxhref{https://docs.python.org/3/reference/expressions.html\#booleans}{regarded as \sphinxcode{\sphinxupquote{False}}}, and so

\item {} 
the looping condition \sphinxcode{\sphinxupquote{not input('...')}} is \sphinxcode{\sphinxupquote{True}}.

\end{itemize}

\sphinxstylestrong{Is it possible to use a for loop instead of a while loop?}
\begin{itemize}
\item {} 
Not without hacks because the for loop is a \sphinxstyleemphasis{definite loop} which has a definite number of iterations before the execution of the loop.

\item {} 
\sphinxcode{\sphinxupquote{while}} statement is useful for an \sphinxstyleemphasis{indefinite loop} where the number of iterations is unknown before the execution of the loop.

\end{itemize}

It is possible, however, to replace a for loop by a while loop.E.g., the following code prints from \sphinxcode{\sphinxupquote{0}} to \sphinxcode{\sphinxupquote{4}} using a while loop instead of a for loop.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
    \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0
1
2
3
4
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
A while loop may not be as elegant (short), c.f., \sphinxcode{\sphinxupquote{for i in range(5): print(i)}}, but

\item {} 
it can always be as efficient.

\end{itemize}

\sphinxstylestrong{Should we just use while loop?}

Consider using the following while loop to print from \sphinxcode{\sphinxupquote{0}} to a user\sphinxhyphen{}specified value.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{i}\PYG{o}{!=}\PYG{n}{num}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:} 
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
    \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Is the above while loop doing the same thing as the for loop below?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

When user input negative integers smaller than or equal to \sphinxhyphen{}2,
\begin{itemize}
\item {} 
the while loop becomes an infinite loop, but

\item {} 
the for loop terminates without printing any number.

\end{itemize}

We have to be careful not to create unintended \sphinxstyleemphasis{infinite loops}.The computer can’t always detect whether there is an infinite loop. (\sphinxhref{https://en.wikipedia.org/wiki/Halting\_problem}{Why not?})


\section{Break/Continue/Else Constructs of a Loop}
\label{\detokenize{Lecture3/Iteration:break-continue-else-constructs-of-a-loop}}

\subsection{Breaking out of a loop}
\label{\detokenize{Lecture3/Iteration:breaking-out-of-a-loop}}
\sphinxstylestrong{Is the following an infinite loop?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
while True:
    message = input(\PYGZsq{}Input something please:\PYGZsq{})
    if message: break
print(\PYGZsq{}You entered:\PYGZsq{}, message)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fed68668828\PYGZgt{}
\end{sphinxVerbatim}

The loop is terminated by the \sphinxhref{https://docs.python.org/3/tutorial/controlflow.html\#break-and-continue-statements-and-else-clauses-on-loops}{\sphinxcode{\sphinxupquote{break}} statement} when user input is non\sphinxhyphen{}empty.

\sphinxstylestrong{Why is the \sphinxcode{\sphinxupquote{break}} statement useful?}

Recall the earlier \sphinxcode{\sphinxupquote{while}} loop:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
while not input(\PYGZsq{}Input something please:\PYGZsq{}): pass 
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fed6861c1d0\PYGZgt{}
\end{sphinxVerbatim}

This while loop is not useful because it does not store the user input.

\sphinxstylestrong{Is the \sphinxcode{\sphinxupquote{break}} statement strictly necessary?}

We can avoid \sphinxcode{\sphinxupquote{break}} statement by using \sphinxstyleemphasis{flags}, which are boolean variables for flow control:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 350
has\PYGZus{}no\PYGZus{}input = True
while has\PYGZus{}no\PYGZus{}input:
    message = input(\PYGZsq{}Input something please:\PYGZsq{})
    if message: has\PYGZus{}no\PYGZus{}input = False
print(\PYGZsq{}You entered:\PYGZsq{}, message)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fed6861c400\PYGZgt{}
\end{sphinxVerbatim}

Using flags makes the program more readable, and we can use multiple flags for more complicated behavior.The variable names for flags are often \sphinxcode{\sphinxupquote{is\_...}}, \sphinxcode{\sphinxupquote{has\_...}}, etc.


\subsection{Continue to Next Iteration}
\label{\detokenize{Lecture3/Iteration:continue-to-next-iteration}}
\sphinxstylestrong{What does the following program do?Is it an infinite loop?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
while True:
    message = input(\PYGZsq{}Input something please:\PYGZsq{})
    if not message: continue
    print(\PYGZsq{}You entered:\PYGZsq{}, message)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fed6861c630\PYGZgt{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
The program repeatedly ask the user for input.

\item {} 
If the input is empty, the \sphinxcode{\sphinxupquote{continue}} statement will skip to the next iteration.

\item {} 
The loop can only be terminated by interrupting the kernel.

\item {} 
Such an infinite loop can be useful. E.g., your computer clock continuously updates the current time.

\end{itemize}

\sphinxstylestrong{Exercise} Is the \sphinxcode{\sphinxupquote{continue}} statement strictly necessary? Can you rewrite the above program without the \sphinxcode{\sphinxupquote{continue}} statement?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 350
while True:
    message = input(\PYGZsq{}Input something please:\PYGZsq{})
    \PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION
    if message:
        print(\PYGZsq{}You entered:\PYGZsq{}, message)
    \PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fed6861c898\PYGZgt{}
\end{sphinxVerbatim}


\subsection{Else construct for a loop}
\label{\detokenize{Lecture3/Iteration:else-construct-for-a-loop}}
The following program
\begin{itemize}
\item {} 
checks whether the user input is a positive integer using \sphinxcode{\sphinxupquote{isdigit}}, and if so,

\item {} 
check if the positive integer is a composite number, i.e., a product of two smaller positive integers.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@interact}\PYG{p}{(}\PYG{n}{num}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{check\PYGZus{}composite}\PYG{p}{(}\PYG{n}{num}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{num}\PYG{o}{.}\PYG{n}{isdigit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{num} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{num}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{divisor} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{num}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{num} \PYG{o}{\PYGZpc{}} \PYG{n}{divisor}\PYG{p}{:}
                \PYG{k}{continue}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{It is composite.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                \PYG{k}{break}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{It is not composite.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Not a positive integer.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(Text(value=\PYGZsq{}1\PYGZsq{}, description=\PYGZsq{}num\PYGZsq{}), Output()), \PYGZus{}dom\PYGZus{}classes=(\PYGZsq{}widget\PYGZhy{}interact\PYGZsq{},))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 500 
def check\PYGZus{}composite(num):
    if num.isdigit():
        num = int(num)
        for divisor in range(2,num):
            if num \PYGZpc{} divisor:
                continue
            else:
                print(\PYGZsq{}It is composite.\PYGZsq{})
                break
        else:
            print(\PYGZsq{}It is not composite.\PYGZsq{})
    else:
        print(\PYGZsq{}Not a positive integer.\PYGZsq{})
        
check\PYGZus{}composite(\PYGZsq{}1\PYGZsq{})
check\PYGZus{}composite(\PYGZsq{}2\PYGZsq{})
check\PYGZus{}composite(\PYGZsq{}3\PYGZsq{})
check\PYGZus{}composite(\PYGZsq{}4\PYGZsq{})
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fed685af160\PYGZgt{}
\end{sphinxVerbatim}

In addition to using \sphinxcode{\sphinxupquote{continue}} and \sphinxcode{\sphinxupquote{break}} in an elegant way,the code also uses an else clause that is executed only when the loop terminates \sphinxstyleemphasis{normally} not by \sphinxcode{\sphinxupquote{break}}.

\sphinxstylestrong{Exercise} There are three else claues in the earlier code. Which one is for the loop?
\begin{itemize}
\item {} 
The second else clause that \sphinxcode{\sphinxupquote{print('It is not composite.')}}.

\item {} 
The clause is called when there is no divisor found in the range from \sphinxcode{\sphinxupquote{2}} to \sphinxcode{\sphinxupquote{num}}.

\end{itemize}

\sphinxstylestrong{Exercise} Convert the for loop to a while loop.Can you improve the code to use fewer iterations?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@interact}\PYG{p}{(}\PYG{n}{num}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{check\PYGZus{}composite}\PYG{p}{(}\PYG{n}{num}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{num}\PYG{o}{.}\PYG{n}{isdigit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{num} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{num}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} for divisor in range(2,num):    \PYGZsh{} use while instead}
        \PYG{n}{divisor} \PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{k}{while} \PYG{n}{divisor} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{num}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{:} 
            \PYG{k}{if} \PYG{n}{num} \PYG{o}{\PYGZpc{}} \PYG{n}{divisor}\PYG{p}{:}
                \PYG{n}{divisor} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{It is composite.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                \PYG{k}{break}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{It is not composite.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Not a positive integer.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(Text(value=\PYGZsq{}1\PYGZsq{}, description=\PYGZsq{}num\PYGZsq{}), Output()), \PYGZus{}dom\PYGZus{}classes=(\PYGZsq{}widget\PYGZhy{}interact\PYGZsq{},))
\end{sphinxVerbatim}


\chapter{Using Functions}
\label{\detokenize{Lecture4/Using Functions:using-functions}}\label{\detokenize{Lecture4/Using Functions::doc}}

\section{Motivation}
\label{\detokenize{Lecture4/Using Functions:motivation}}
\sphinxstylestrong{How to reuse code so we can write less?}

When we write a loop, the code is executed multiple times, once for each iteration.

This is a simple form of \sphinxstyleemphasis{code reuse} that
\begin{itemize}
\item {} 
gives your code an elegant \sphinxstyleemphasis{structure} that

\item {} 
can be executed efficiently by a computer, and

\item {} 
\sphinxstyleemphasis{interpreted} easily by a programmer.

\end{itemize}

\sphinxstylestrong{How to repeat execution at different times, in different programs, and in slightly different ways?}


\section{Functions}
\label{\detokenize{Lecture4/Using Functions:functions}}
\sphinxstylestrong{How to calculate the logarithm?}

There is no arithmetic operator for logarithm.Do we have to implement it ourselves?

We can use the function \sphinxcode{\sphinxupquote{log}} from the \sphinxhref{https://docs.python.org/3/library/math.html}{\sphinxcode{\sphinxupquote{math}} \sphinxstyleemphasis{module}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{n}{log}
\PYG{n}{log}\PYG{p}{(}\PYG{l+m+mi}{256}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} log base 2 of 256}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
8.0
\end{sphinxVerbatim}

The above computes the base\sphinxhyphen{}\(2\) logarithm, \(\log_2(256)\). Like functions in mathematics, a computer function \sphinxcode{\sphinxupquote{log}}
\begin{itemize}
\item {} 
is \sphinxstyleemphasis{called/invoked} with some input \sphinxstyleemphasis{arguments} \sphinxcode{\sphinxupquote{(256, 2)}} following the function, and

\item {} 
\sphinxstyleemphasis{returns} an output value computed from the input arguments.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} A function is callable while an integer is not}
\PYG{n}{callable}\PYG{p}{(}\PYG{n}{log}\PYG{p}{)}\PYG{p}{,} \PYG{n}{callable}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(True, False)
\end{sphinxVerbatim}

Unlike mathematical functions:
\begin{itemize}
\item {} 
A computer function may require no arguments, but we still need to call it with \sphinxcode{\sphinxupquote{()}}.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{input}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
A computer function may have side effects and return \sphinxcode{\sphinxupquote{None}}.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{of type}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
None of type \PYGZlt{}class \PYGZsq{}NoneType\PYGZsq{}\PYGZgt{}
\end{sphinxVerbatim}

An argument of a function call can be any expression.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1st input:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{input}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2nd input}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{input}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Note also that
\begin{itemize}
\item {} 
the argument can also be a function call like function composition in mathematics.

\item {} 
Before a function call is executed, its arguments are evaluated first from left to right.

\end{itemize}

\sphinxstylestrong{Why not implement logarithm yourself?}
\begin{itemize}
\item {} 
The function from standard library is efficiently implemented and thoroughly tested/documented.

\item {} 
Knowing what a function does is often insufficient for an efficient implementation.(See \sphinxhref{https://en.wikipedia.org/wiki/Logarithm\#Calculation}{how to calculate logarithm} as an example.)

\end{itemize}

Indeed, the \sphinxcode{\sphinxupquote{math}} library does not implement \sphinxcode{\sphinxupquote{log}} itself:
\begin{quote}

\sphinxstylestrong{CPython implementation detail:} The \sphinxcode{\sphinxupquote{math}} module consists mostly of thin \sphinxstyleemphasis{wrappers} around the platform C math library functions. \sphinxhyphen{} \sphinxhref{https://docs.python.org/3/library/math.html}{pydoc last paragraph}
\end{quote}

(See the \sphinxhref{https://github.com/python/cpython/blob/457d4e97de0369bc786e363cb53c7ef3276fdfcd/Modules/mathmodule.c\#L731}{source code wrapper for \sphinxcode{\sphinxupquote{log}}}.)

\sphinxstylestrong{Exercise} What is a function in programming?
\begin{itemize}
\item {} 
A function is a structure that allows a piece of code to be reused in a program.

\item {} 
A function can adapt its computations to different situations using input arguments.

\end{itemize}


\section{Import Functions from Modules}
\label{\detokenize{Lecture4/Using Functions:import-functions-from-modules}}
\sphinxstylestrong{How to import functions?}

We can use the \sphinxhref{https://docs.python.org/3/reference/simple\_stmts.html\#import}{\sphinxcode{\sphinxupquote{import}} statement} to import multiple functions into the program \sphinxstyleemphasis{global frame}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
from math import log10, ceil
x = 1234
print(\PYGZsq{}Number of digits of x:\PYGZsq{}, ceil(log10(x)))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f15c059a898\PYGZgt{}
\end{sphinxVerbatim}

The above import both the functions \sphinxcode{\sphinxupquote{log10}} and \sphinxcode{\sphinxupquote{ceil}} from \sphinxcode{\sphinxupquote{math}} to compute the number \(\lceil \log_{10}(x)\rceil\) of digits of a \sphinxstyleemphasis{strictly positive} integer \(x\).

\sphinxstylestrong{How to import all functions from a library?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
from math import *  \PYGZsh{} import all except names starting with an underscore
print(\PYGZsq{}\PYGZob{}:.2f\PYGZcb{}, \PYGZob{}:.2f\PYGZcb{}, \PYGZob{}:.2f\PYGZcb{}\PYGZsq{}.format(sin(pi / 6), cos(pi / 3), tan(pi / 4)))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f15c059ad30\PYGZgt{}
\end{sphinxVerbatim}

The above uses the wildcard \sphinxcode{\sphinxupquote{*}} to import (\sphinxhref{https://docs.python.org/3/tutorial/modules.html\#more-on-modules}{nearly}) all the functions/variables provided in \sphinxcode{\sphinxupquote{math}}.

\sphinxstylestrong{What if different packages define the same function?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
print(\PYGZsq{}\PYGZob{}\PYGZcb{}\PYGZsq{}.format(pow(\PYGZhy{}1, 2)))
print(\PYGZsq{}\PYGZob{}:.2f\PYGZcb{}\PYGZsq{}.format(pow(\PYGZhy{}1, 1 / 2)))
from math import *
print(\PYGZsq{}\PYGZob{}\PYGZcb{}\PYGZsq{}.format(pow(\PYGZhy{}1, 2)))
print(\PYGZsq{}\PYGZob{}:.2f\PYGZcb{}\PYGZsq{}.format(pow(\PYGZhy{}1, 1 / 2)))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f15c05a80f0\PYGZgt{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
The function \sphinxcode{\sphinxupquote{pow}} imported from \sphinxcode{\sphinxupquote{math}} overwrites the built\sphinxhyphen{}in function \sphinxcode{\sphinxupquote{pow}}.

\item {} 
Unlike the built\sphinxhyphen{}in function, \sphinxcode{\sphinxupquote{pow}} from \sphinxcode{\sphinxupquote{math}} returns only floats but not integers nor complex numbers.

\item {} 
We say that the import statement \sphinxstyleemphasis{polluted the namespace of the global frame} and caused a \sphinxstyleemphasis{name collision}.

\end{itemize}

\sphinxstylestrong{How to avoid name collisions?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 250
import math
print(\PYGZsq{}\PYGZob{}:.2f\PYGZcb{}, \PYGZob{}:.2f\PYGZcb{}\PYGZsq{}.format(math.pow(\PYGZhy{}1, 2), pow(\PYGZhy{}1, 1 / 2)))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f15c05a8400\PYGZgt{}
\end{sphinxVerbatim}

We can use the full name (\sphinxstyleemphasis{fully\sphinxhyphen{}qualified name}) \sphinxcode{\sphinxupquote{math.pow}} prefixed with the module name (and possibly package names containing the module).

\sphinxstylestrong{Can we shorten a name?}

The name of a library can be very long and there can be a hierarchical structure as well.E.g., to plot a sequence using \sphinxcode{\sphinxupquote{pyplot}} module from \sphinxcode{\sphinxupquote{matplotlib}} package:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} inline
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot}
\PYG{n}{matplotlib}\PYG{o}{.}\PYG{n}{pyplot}\PYG{o}{.}\PYG{n}{stem}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{matplotlib}\PYG{o}{.}\PYG{n}{pyplot}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZus{}n\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{matplotlib}\PYG{o}{.}\PYG{n}{pyplot}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}n\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{matplotlib}\PYG{o}{.}\PYG{n}{pyplot}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A sequence of numbers}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{matplotlib}\PYG{o}{.}\PYG{n}{pyplot}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Using Functions_43_0}.png}

It is common to rename \sphinxcode{\sphinxupquote{matplotlib.pyplot}} as \sphinxcode{\sphinxupquote{plt}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} inline
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{stem}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZus{}n\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}n\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A sequence of numbers}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Using Functions_45_0}.png}

We can also rename a function as we import it to avoid name collision:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{n+nb}{pow} \PYG{k}{as} \PYG{n}{fpow}
\PYG{n}{fpow}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{pow}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(4.0, 4)
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} What is wrong with the following code?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math} \PYG{k}{as} \PYG{n+nn}{m}
\PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:} \PYG{n}{m}\PYG{o}{.}\PYG{n}{pow}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{AttributeError}\PYG{g+gWhitespace}{                            }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{14}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{53146}\PYG{n}{a1609f3}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{k+kn}{import} \PYG{n+nn}{math} \PYG{k}{as} \PYG{n+nn}{m}
\PYG{n+nn}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 2 for m} in \PYG{n+ni}{range(5): m.pow}\PYG{n+nt}{(m, 2)}

\PYG{n+ne}{AttributeError}: \PYGZsq{}int\PYGZsq{} object has no attribute \PYGZsq{}pow\PYGZsq{}
\end{sphinxVerbatim}

There is a name collision: \sphinxcode{\sphinxupquote{m}} is assigned to an integer in the for loop and so it is no longer the module \sphinxcode{\sphinxupquote{math}} when calling \sphinxcode{\sphinxupquote{m.pow}}.

\sphinxstylestrong{Exercise} Use the \sphinxcode{\sphinxupquote{randint}} function from \sphinxcode{\sphinxupquote{random}} to simulate the rolling of a die, by printing a random integer from 1 to 6.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1
\end{sphinxVerbatim}


\section{Built\sphinxhyphen{}in Functions}
\label{\detokenize{Lecture4/Using Functions:built-in-functions}}
\sphinxstylestrong{How to learn more about a function such as \sphinxcode{\sphinxupquote{randint}}?}

There is a built\sphinxhyphen{}in function \sphinxcode{\sphinxupquote{help}} for showing the \sphinxstyleemphasis{docstring} (documentation string).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}
\PYG{n}{help}\PYG{p}{(}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} random must be imported before}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Help on method randint in module random:

randint(a, b) method of random.Random instance
    Return random integer in range [a, b], including both end points.
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{help}\PYG{p}{(}\PYG{n}{random}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} can also show the docstring of a module}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{help}\PYG{p}{(}\PYG{n}{help}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Does built\sphinxhyphen{}in functions belong to a module?}

Indeed, every function must come from a module.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{\PYGZus{}\PYGZus{}builtin\PYGZus{}\PYGZus{}}\PYG{o}{.}\PYG{n}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I am from the \PYGZus{}\PYGZus{}builtin\PYGZus{}\PYGZus{} module.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
I am from the \PYGZus{}\PYGZus{}builtin\PYGZus{}\PYGZus{} module.
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{\_\_builtin\_\_}} module is automatically loaded because it provides functions that are commonly use for all programs.

\sphinxstylestrong{How to list everything in a module?}

We can use the built\sphinxhyphen{}in function \sphinxcode{\sphinxupquote{dir}} (\sphinxstyleemphasis{directory}).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{dir}\PYG{p}{(}\PYG{n}{\PYGZus{}\PYGZus{}builtin\PYGZus{}\PYGZus{}}\PYG{p}{)}
\end{sphinxVerbatim}

We can also call \sphinxcode{\sphinxupquote{dir}} without arguments.What does it print?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{dir}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Writing Function}
\label{\detokenize{Lecture4/Writing Functions:writing-function}}\label{\detokenize{Lecture4/Writing Functions::doc}}

\section{Function Definition}
\label{\detokenize{Lecture4/Writing Functions:function-definition}}
\sphinxstylestrong{How to write a function?}

A function is defined using the \sphinxhref{https://docs.python.org/3/reference/compound\_stmts.html\#def}{\sphinxcode{\sphinxupquote{def}} keyword}:

The following is a simple function that prints “Hello, World!”.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Function definition}
\PYG{k}{def} \PYG{n+nf}{say\PYGZus{}hello}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello, World!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Function invocation}
\PYG{n}{say\PYGZus{}hello}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Hello, World!
\end{sphinxVerbatim}

To make a function more powerful and solve different problems,we can
\begin{itemize}
\item {} 
use a \sphinxhref{https://docs.python.org/3/reference/simple\_stmts.html\#the-return-statement}{return statement} to return a value that

\item {} 
depends on some input arguments.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{increment}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{1}


\PYG{n}{increment}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
4
\end{sphinxVerbatim}

We can also have multiple input arguments.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{length\PYGZus{}of\PYGZus{}hypotenuse}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{a} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{b} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{b}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Input arguments must be non\PYGZhy{}negative.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{length\PYGZus{}of\PYGZus{}hypotenuse}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
5.0
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{length\PYGZus{}of\PYGZus{}hypotenuse}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input arguments must be non\PYGZhy{}negative.
\end{sphinxVerbatim}


\section{Documentation}
\label{\detokenize{Lecture4/Writing Functions:documentation}}
\sphinxstylestrong{How to document a function?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Author: John Doe}
\PYG{c+c1}{\PYGZsh{} Last modified: 2020\PYGZhy{}09\PYGZhy{}14}
\PYG{k}{def} \PYG{n+nf}{increment}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}The function takes in a value x and returns the increment x + 1.}
\PYG{l+s+sd}{    }
\PYG{l+s+sd}{    It is a simple example that demonstrates the idea of}
\PYG{l+s+sd}{    \PYGZhy{} parameter passing, }
\PYG{l+s+sd}{    \PYGZhy{} return statement, and }
\PYG{l+s+sd}{    \PYGZhy{} function documentation.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{return} \PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{1}  \PYG{c+c1}{\PYGZsh{} + operation is used and may fail for \PYGZsq{}str\PYGZsq{}}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{help}} command shows the docstring we write
\begin{itemize}
\item {} 
at beginning of the function body

\item {} 
delimited using triple single/double quotes.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{help}\PYG{p}{(}\PYG{n}{increment}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Help on function increment in module \PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}:

increment(x)
    The function takes in a value x and returns the increment x + 1.
    
    It is a simple example that demonstrates the idea of
    \PYGZhy{} parameter passing, 
    \PYGZhy{} return statement, and 
    \PYGZhy{} function documentation.
\end{sphinxVerbatim}

The docstring should contain the \sphinxstyleemphasis{usage guide}, i.e., information for new users to call the function properly.There is a Python style guide (PEP 257) for
\begin{itemize}
\item {} 
\sphinxhref{https://www.python.org/dev/peps/pep-0257/\#one-line-docstrings}{one\sphinxhyphen{}line docstrings} and

\item {} 
\sphinxhref{https://www.python.org/dev/peps/pep-0257/\#multi-line-docstrings}{multi\sphinxhyphen{}line docstrings}.

\end{itemize}

\sphinxstylestrong{Why doesn’t \sphinxcode{\sphinxupquote{help}} show the comments that start with \sphinxcode{\sphinxupquote{\#}}?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Author: John Doe}
\PYG{c+c1}{\PYGZsh{} Last modified: 2020\PYGZhy{}09\PYGZhy{}14}
\PYG{k}{def} \PYG{n+nf}{increment}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{k}{return} \PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{1}  \PYG{c+c1}{\PYGZsh{} + operation is used and may fail for \PYGZsq{}str\PYGZsq{}}
\end{sphinxVerbatim}

Those comments are not usage guide. They are intended for programmers who need to maintain/extend the function definition.
\begin{itemize}
\item {} 
Information about the author and modification date facilitate communications among programmers.

\item {} 
Comments within the code help explain important and not\sphinxhyphen{}so\sphinxhyphen{}obvious implementation details.

\end{itemize}

\sphinxstylestrong{How to let user know the data types of input arguments and return value?}

We can \sphinxhref{https://docs.python.org/3/library/typing.html}{annotate} the function with \sphinxstyleemphasis{hints} of the types of the arguments and return value.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Author: John Doe}
\PYG{c+c1}{\PYGZsh{} Last modified: 2020\PYGZhy{}09\PYGZhy{}14}
\PYG{k}{def} \PYG{n+nf}{increment}\PYG{p}{(}\PYG{n}{x}\PYG{p}{:} \PYG{n+nb}{float}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n+nb}{float}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}The function takes in a value x and returns the increment x + 1.}
\PYG{l+s+sd}{    }
\PYG{l+s+sd}{    It is a simple example that demonstrates the idea of}
\PYG{l+s+sd}{    \PYGZhy{} parameter passing, }
\PYG{l+s+sd}{    \PYGZhy{} return statement, and }
\PYG{l+s+sd}{    \PYGZhy{} function documentation.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{return} \PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{1}  \PYG{c+c1}{\PYGZsh{} + operation is used and may fail for \PYGZsq{}str\PYGZsq{}}


\PYG{n}{help}\PYG{p}{(}\PYG{n}{increment}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Help on function increment in module \PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}:

increment(x: float) \PYGZhy{}\PYGZgt{} float
    The function takes in a value x and returns the increment x + 1.
    
    It is a simple example that demonstrates the idea of
    \PYGZhy{} parameter passing, 
    \PYGZhy{} return statement, and 
    \PYGZhy{} function documentation.
\end{sphinxVerbatim}

The above annotations is not enforced by the Python interpreter.Nevertheless, such annotations make the code easier to understand and can be used by editor with type\sphinxhyphen{}checking tools.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{increment\PYGZus{}user\PYGZus{}input}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{increment}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} does not raise error even though input returns str}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{increment\PYGZus{}user\PYGZus{}input}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} still lead to runtime error}
\end{sphinxVerbatim}


\section{Parameter Passing}
\label{\detokenize{Lecture4/Writing Functions:parameter-passing}}
\sphinxstylestrong{Can we increment a variable instead of returning its increment?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{increment}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{x} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{n}{increment}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} 4?}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
3
\end{sphinxVerbatim}

Does the above code increment \sphinxcode{\sphinxupquote{x}}?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 350
def increment(x):
    x += 1


x = 3
increment(x)
print(x)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f2f4152d978\PYGZgt{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Step 3: The function \sphinxcode{\sphinxupquote{increment}} is invoked with the argument evaluated to the value of \sphinxcode{\sphinxupquote{x}}.

\item {} 
Step 3\sphinxhyphen{}4: A local frame is created for variables local to \sphinxcode{\sphinxupquote{increment}} during its execution.
\begin{itemize}
\item {} 
The \sphinxstyleemphasis{formal parameter} \sphinxcode{\sphinxupquote{x}} in \sphinxcode{\sphinxupquote{def increment(x):}} becomes a local variable and

\item {} 
it is assigned the value \sphinxcode{\sphinxupquote{3}} of the \sphinxstyleemphasis{actual parameter} given by the global variable \sphinxcode{\sphinxupquote{x}}.

\end{itemize}

\item {} 
Step 5\sphinxhyphen{}6: The local (but not the global) variable \sphinxcode{\sphinxupquote{x}} is incremented.

\item {} 
Step 6\sphinxhyphen{}7: The function call completes and the local frame is removed.

\end{itemize}


\chapter{Objects}
\label{\detokenize{Lecture5/Objects:objects}}\label{\detokenize{Lecture5/Objects::doc}}

\section{Object\sphinxhyphen{}Oriented Programming}
\label{\detokenize{Lecture5/Objects:object-oriented-programming}}
\sphinxstylestrong{Why object\sphinxhyphen{}oriented programming?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{jupyter\PYGZus{}manim}
\PYG{k+kn}{from} \PYG{n+nn}{manimlib}\PYG{n+nn}{.}\PYG{n+nn}{imports} \PYG{k+kn}{import} \PYG{o}{*}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{manim} HelloWorld \PYGZhy{}l
class HelloWorld(Scene):
    def construct(self):
        self.play(Write(TextMobject(\PYGZsq{}Hello, World!\PYGZsq{})))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{HelloWorld}} is a specific \sphinxcode{\sphinxupquote{Scene}} that is

\item {} 
\sphinxcode{\sphinxupquote{construct}}ed by \sphinxcode{\sphinxupquote{play}}ing an animation that \sphinxcode{\sphinxupquote{Write}}

\item {} 
the \sphinxcode{\sphinxupquote{TextMobject}} of the message \sphinxcode{\sphinxupquote{'Hello, World!'}}.

\end{itemize}

\sphinxstylestrong{Exercise} Try changing
\begin{itemize}
\item {} 
Mobjects: \sphinxcode{\sphinxupquote{TextMobject('Hello, World!')}} to \sphinxcode{\sphinxupquote{TexMobject(r'E=mc\textasciicircum{}2')}} or \sphinxcode{\sphinxupquote{Circle()}} or \sphinxcode{\sphinxupquote{Square()}}.

\item {} 
Animation objects: \sphinxcode{\sphinxupquote{Write}} to \sphinxcode{\sphinxupquote{FadeIn}} or \sphinxcode{\sphinxupquote{GrowFromCenter}}.

\end{itemize}

See the \sphinxhref{https://eulertour.com/docs/}{documentation} for other choices.

More complicated behavior can be achieved by using different objects.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}html}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{iframe} \PYG{n+na}{width}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}912\PYGZdq{}} \PYG{n+na}{height}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}513\PYGZdq{}} \PYG{n+na}{src}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}https://www.youtube.com/embed/ENMyFGmq5OA\PYGZdq{}} \PYG{n+na}{frameborder}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}0\PYGZdq{}} \PYG{n+na}{allow}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}accelerometer; autoplay; clipboard\PYGZhy{}write; encrypted\PYGZhy{}media; gyroscope; picture\PYGZhy{}in\PYGZhy{}picture\PYGZdq{}} \PYG{n+na}{allowfullscreen}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{iframe}\PYG{p}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\sphinxstylestrong{What is an object?}

Almost everything is an \sphinxhref{https://docs.python.org/3/library/functions.html?highlight=object\#object}{\sphinxcode{\sphinxupquote{object}}} in Python.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
isinstance\PYG{o}{?}
\PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(True, True, True)
\end{sphinxVerbatim}

A function is also a \sphinxhref{https://en.wikipedia.org/wiki/First-class\_function}{first\sphinxhyphen{}class} object object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n+nb}{print}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{isdigit}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(True, True)
\end{sphinxVerbatim}

A data type is also an object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} chicken and egg relationship}
\PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(True, True, True)
\end{sphinxVerbatim}

Python is a \sphinxhref{https://en.wikipedia.org/wiki/Object-oriented\_programming\#Class-based\_vs\_prototype-based}{\sphinxstyleemphasis{class\sphinxhyphen{}based} object\sphinxhyphen{}oriented programming} language:
\begin{itemize}
\item {} 
Each object is an instance of a \sphinxstyleemphasis{class} (also called type in Python).

\item {} 
An object is a collection of \sphinxstyleemphasis{members/attributes}, each of which is an object.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
hasattr\PYG{o}{?}
\PYG{n+nb}{hasattr}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{isdigit}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

Different objects of a class
\begin{itemize}
\item {} 
have the same set of attributes as that of the class, but

\item {} 
the attribute values can be different.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
dir\PYG{o}{?}
\PYG{n+nb}{dir}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{==}\PYG{n+nb}{dir}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{complex}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{imag} \PYG{o}{!=} \PYG{n+nb}{complex}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}\PYG{n}{imag}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(True, True)
\end{sphinxVerbatim}

\sphinxstylestrong{How to operate on an object?}
\begin{itemize}
\item {} 
A class can define a function as an attribute for all its instances.

\item {} 
Such a function is called a \sphinxstyleemphasis{method} or \sphinxstyleemphasis{member function}.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{complex}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{(}\PYG{n+nb}{complex}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n+nb}{complex}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
((1\PYGZhy{}2j), method\PYGZus{}descriptor)
\end{sphinxVerbatim}

A \sphinxhref{https://docs.python.org/3/tutorial/classes.html\#method-objects}{method} can be accessed by objects of the class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{complex}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n+nb}{complex}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
((1\PYGZhy{}2j), builtin\PYGZus{}function\PYGZus{}or\PYGZus{}method)
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{complex(1,2).conjugate}} is a \sphinxstyleemphasis{callable} object:
\begin{itemize}
\item {} 
Its attribute \sphinxcode{\sphinxupquote{\_\_self\_\_}} is assigned to \sphinxcode{\sphinxupquote{complex(1,2)}}.

\item {} 
When called, it passes \sphinxcode{\sphinxupquote{\_\_self\_\_}} as the first argument to \sphinxcode{\sphinxupquote{complex.conjugate}}.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{callable}\PYG{p}{(}\PYG{n+nb}{complex}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{complex}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{conjugate}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}self\PYGZus{}\PYGZus{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(True, (1+2j))
\end{sphinxVerbatim}


\section{File Objects}
\label{\detokenize{Lecture5/Objects:file-objects}}
\sphinxstylestrong{How to read a text file?}

Consider reading a csv (comma separated value) file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{!}more \PYG{l+s+s1}{\PYGZsq{}contact.csv\PYGZsq{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
name, email, phone
Amelia Hawkins,dugorre@lufu.cg,(414) 524\PYGZhy{}6465
Alta Perez,bos@fiur.sc,(385) 247\PYGZhy{}9001
Tai Ming Chan,tmchan@cityu.edu.hk,(634) 234\PYGZhy{}7294
Annie Zimmerman,okodag@saswuf.mn,(259) 862\PYGZhy{}1082
Eula Crawford,ve@rorohte.mx,(635) 827\PYGZhy{}9819
Clayton Atkins,vape@nig.eh,(762) 271\PYGZhy{}7090
Hallie Day,kozzazazi@ozakewje.am,(872) 949\PYGZhy{}5878
Lida Matthews,joobu@pabnesis.kg,(213) 486\PYGZhy{}8330
Amelia Pittman,nulif@uposzag.au,(800) 303\PYGZhy{}3234
\end{sphinxVerbatim}

To read the file by a Python program:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{contact.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} create a file object for reading}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} return the entire content}
\PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}         \PYG{c+c1}{\PYGZsh{} close the file}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
name, email, phone
Amelia Hawkins,dugorre@lufu.cg,(414) 524\PYGZhy{}6465
Alta Perez,bos@fiur.sc,(385) 247\PYGZhy{}9001
Tai Ming Chan,tmchan@cityu.edu.hk,(634) 234\PYGZhy{}7294
Annie Zimmerman,okodag@saswuf.mn,(259) 862\PYGZhy{}1082
Eula Crawford,ve@rorohte.mx,(635) 827\PYGZhy{}9819
Clayton Atkins,vape@nig.eh,(762) 271\PYGZhy{}7090
Hallie Day,kozzazazi@ozakewje.am,(872) 949\PYGZhy{}5878
Lida Matthews,joobu@pabnesis.kg,(213) 486\PYGZhy{}8330
Amelia Pittman,nulif@uposzag.au,(800) 303\PYGZhy{}3234
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxhref{https://docs.python.org/3/library/functions.html?highlight=open\#open}{\sphinxcode{\sphinxupquote{open}}} is a function that creates a file object and assigns it to \sphinxcode{\sphinxupquote{f}}.

\item {} 
Associated with the file object,

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxhref{https://docs.python.org/3/library/io.html\#io.TextIOBase.read}{\sphinxcode{\sphinxupquote{read}}} returns the entire content of the file as a string.

\item {} 
\sphinxhref{https://docs.python.org/3/library/io.html\#io.IOBase.close}{\sphinxcode{\sphinxupquote{close}}} flushes and closes the file.

\end{itemize}

\sphinxstylestrong{Why close a file?}

If not, depending on the operating system,
\begin{itemize}
\item {} 
other programs may not be able to access the file, and

\item {} 
changes may not be written to the file.

\end{itemize}

To ensure a file is closed properly, we can use the \sphinxhref{https://docs.python.org/3/reference/compound\_stmts.html\#with}{\sphinxcode{\sphinxupquote{with}} statement}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{contact.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
name, email, phone
Amelia Hawkins,dugorre@lufu.cg,(414) 524\PYGZhy{}6465
Alta Perez,bos@fiur.sc,(385) 247\PYGZhy{}9001
Tai Ming Chan,tmchan@cityu.edu.hk,(634) 234\PYGZhy{}7294
Annie Zimmerman,okodag@saswuf.mn,(259) 862\PYGZhy{}1082
Eula Crawford,ve@rorohte.mx,(635) 827\PYGZhy{}9819
Clayton Atkins,vape@nig.eh,(762) 271\PYGZhy{}7090
Hallie Day,kozzazazi@ozakewje.am,(872) 949\PYGZhy{}5878
Lida Matthews,joobu@pabnesis.kg,(213) 486\PYGZhy{}8330
Amelia Pittman,nulif@uposzag.au,(800) 303\PYGZhy{}3234
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{with}} statement applies to any \sphinxhref{https://docs.python.org/3/reference/datamodel.html\#context-managers}{context manager} that provides the methods
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\_\_enter\_\_}} for initialization, and

\item {} 
\sphinxcode{\sphinxupquote{\_\_exit\_\_}} for finalization.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{contact.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n+nb}{hasattr}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}enter\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{hasattr}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}exit\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}\PYGZus{}io.TextIOWrapper name=\PYGZsq{}contact.csv\PYGZsq{} mode=\PYGZsq{}r\PYGZsq{} encoding=\PYGZsq{}UTF\PYGZhy{}8\PYGZsq{}\PYGZgt{}
True
True
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{f.\_\_enter\_\_}} is called after the file object is successfully created and assigned to \sphinxcode{\sphinxupquote{f}}, and

\item {} 
\sphinxcode{\sphinxupquote{f.\_\_exit\_\_}} is called at the end, which closes the file.

\item {} 
\sphinxcode{\sphinxupquote{f.closed}} indicates whether the file is closed.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f}\PYG{o}{.}\PYG{n}{closed}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

We can iterate a file object in a for loop,which implicitly call the method \sphinxcode{\sphinxupquote{\_\_iter\_\_}} to read a file line by line.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{contact.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{f}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{line}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n+nb}{hasattr}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}iter\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
name, email, phone
Amelia Hawkins,dugorre@lufu.cg,(414) 524\PYGZhy{}6465
Alta Perez,bos@fiur.sc,(385) 247\PYGZhy{}9001
Tai Ming Chan,tmchan@cityu.edu.hk,(634) 234\PYGZhy{}7294
Annie Zimmerman,okodag@saswuf.mn,(259) 862\PYGZhy{}1082
Eula Crawford,ve@rorohte.mx,(635) 827\PYGZhy{}9819
Clayton Atkins,vape@nig.eh,(762) 271\PYGZhy{}7090
Hallie Day,kozzazazi@ozakewje.am,(872) 949\PYGZhy{}5878
Lida Matthews,joobu@pabnesis.kg,(213) 486\PYGZhy{}8330
Amelia Pittman,nulif@uposzag.au,(800) 303\PYGZhy{}3234
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Print only the first 5 lines of the file \sphinxcode{\sphinxupquote{contact.csv}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{contact.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{line}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{i} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{:} \PYG{k}{break}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
name, email, phone
Amelia Hawkins,dugorre@lufu.cg,(414) 524\PYGZhy{}6465
Alta Perez,bos@fiur.sc,(385) 247\PYGZhy{}9001
Tai Ming Chan,tmchan@cityu.edu.hk,(634) 234\PYGZhy{}7294
Annie Zimmerman,okodag@saswuf.mn,(259) 862\PYGZhy{}1082
Eula Crawford,ve@rorohte.mx,(635) 827\PYGZhy{}9819
\end{sphinxVerbatim}

\sphinxstylestrong{How to write to a text file?}

Consider backing up \sphinxcode{\sphinxupquote{contact.csv}} to a new file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{destination} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{private/new\PYGZus{}contact.csv}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

The directory has to be created first if it does not exist:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{makedirs}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{dirname}\PYG{p}{(}\PYG{n}{destination}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exist\PYGZus{}ok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
os.makedirs\PYG{o}{?}
\PYG{o}{!}ls
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Objects.ipynb  contact.csv  media  private
\end{sphinxVerbatim}

To write to the destination file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{contact.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{source\PYGZus{}file}\PYG{p}{:}
    \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{destination}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{destination\PYGZus{}file}\PYG{p}{:}
        \PYG{n}{destination\PYGZus{}file}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{source\PYGZus{}file}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
destination\PYGZus{}file.write\PYG{o}{?}
\PYG{o}{!}more \PYG{o}{\PYGZob{}}destination\PYG{o}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
name, email, phone
Amelia Hawkins,dugorre@lufu.cg,(414) 524\PYGZhy{}6465
Alta Perez,bos@fiur.sc,(385) 247\PYGZhy{}9001
Tai Ming Chan,tmchan@cityu.edu.hk,(634) 234\PYGZhy{}7294
Annie Zimmerman,okodag@saswuf.mn,(259) 862\PYGZhy{}1082
Eula Crawford,ve@rorohte.mx,(635) 827\PYGZhy{}9819
Clayton Atkins,vape@nig.eh,(762) 271\PYGZhy{}7090
Hallie Day,kozzazazi@ozakewje.am,(872) 949\PYGZhy{}5878
Lida Matthews,joobu@pabnesis.kg,(213) 486\PYGZhy{}8330
Amelia Pittman,nulif@uposzag.au,(800) 303\PYGZhy{}3234
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
The argument \sphinxcode{\sphinxupquote{'w'}} to \sphinxcode{\sphinxupquote{open}} sets the file object to write mode.

\item {} 
The method \sphinxcode{\sphinxupquote{write}} writes the input strings to the file.

\end{itemize}

\sphinxstylestrong{Exercise} We can also use \sphinxcode{\sphinxupquote{a}} mode to \sphinxstyleemphasis{append} new content to a file.Complete the following code to append \sphinxcode{\sphinxupquote{new\_data}} to the file \sphinxcode{\sphinxupquote{destination}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{new\PYGZus{}data} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Effie, Douglas,galnec@naowdu.tc, (888) 311\PYGZhy{}9512}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{destination}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{new\PYGZus{}data}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\PYG{o}{!}more \PYG{o}{\PYGZob{}}destination\PYG{o}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
name, email, phone
Amelia Hawkins,dugorre@lufu.cg,(414) 524\PYGZhy{}6465
Alta Perez,bos@fiur.sc,(385) 247\PYGZhy{}9001
Tai Ming Chan,tmchan@cityu.edu.hk,(634) 234\PYGZhy{}7294
Annie Zimmerman,okodag@saswuf.mn,(259) 862\PYGZhy{}1082
Eula Crawford,ve@rorohte.mx,(635) 827\PYGZhy{}9819
Clayton Atkins,vape@nig.eh,(762) 271\PYGZhy{}7090
Hallie Day,kozzazazi@ozakewje.am,(872) 949\PYGZhy{}5878
Lida Matthews,joobu@pabnesis.kg,(213) 486\PYGZhy{}8330
Amelia Pittman,nulif@uposzag.au,(800) 303\PYGZhy{}3234
Effie, Douglas,galnec@naowdu.tc, (888) 311\PYGZhy{}9512
\end{sphinxVerbatim}

\sphinxstylestrong{How to delete a file?}

Note that the file object does not provide any method to delete the file.Instead, we should use the function \sphinxcode{\sphinxupquote{remove}} of the \sphinxcode{\sphinxupquote{os}} module.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{destination}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{destination}\PYG{p}{)}
\end{sphinxVerbatim}


\section{String Objects}
\label{\detokenize{Lecture5/Objects:string-objects}}
\sphinxstylestrong{How to search for a substring in a string?}

A string object has the method \sphinxcode{\sphinxupquote{find}} to search for a substring.E.g., to find the contact information of Tai Ming:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
str.find\PYG{o}{?}
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{contact.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{f}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{line}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tai Ming}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{n}{record} \PYG{o}{=} \PYG{n}{line}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{record}\PYG{p}{)}
            \PYG{k}{break}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Tai Ming Chan,tmchan@cityu.edu.hk,(634) 234\PYGZhy{}7294
\end{sphinxVerbatim}

\sphinxstylestrong{How to split and join strings?}

A string can be split according to a delimiter using the \sphinxcode{\sphinxupquote{split}} method.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{record}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}Tai Ming Chan\PYGZsq{}, \PYGZsq{}tmchan@cityu.edu.hk\PYGZsq{}, \PYGZsq{}(634) 234\PYGZhy{}7294\PYGZbs{}n\PYGZsq{}]
\end{sphinxVerbatim}

The list of substrings can be joined back together using the \sphinxcode{\sphinxupquote{join}} methods.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{record}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Tai Ming Chan
tmchan@cityu.edu.hk
(634) 234\PYGZhy{}7294
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Print only the phone number (last item) in \sphinxcode{\sphinxupquote{record}}. Use the method \sphinxcode{\sphinxupquote{rstrip}} or  \sphinxcode{\sphinxupquote{strip}} to remove unnecessary white spaces at the end.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
str.rstrip\PYG{o}{?}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{record}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{rstrip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(634) 234\PYGZhy{}7294
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Print only the name (first item) in \sphinxcode{\sphinxupquote{record}} but with
\begin{itemize}
\item {} 
surname printed first with all letters in upper case

\item {} 
followed by a comma, a space, and

\item {} 
the first name as it is in \sphinxcode{\sphinxupquote{record}}.

\end{itemize}

E.g., \sphinxcode{\sphinxupquote{Tai Ming Chan}} should be printed as \sphinxcode{\sphinxupquote{CHAN, Tai Ming}}.

\sphinxstyleemphasis{Hint}: Use the methods \sphinxcode{\sphinxupquote{upper}} and \sphinxcode{\sphinxupquote{rsplit}} (with the parameter \sphinxcode{\sphinxupquote{maxsplit=1}}).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
str.rsplit\PYG{o}{?}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
\PYG{n}{first}\PYG{p}{,} \PYG{n}{last} \PYG{o}{=} \PYG{n}{record}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{rsplit}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{maxsplit}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{, }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{last}\PYG{o}{.}\PYG{n}{upper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{first}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CHAN, Tai Ming
\end{sphinxVerbatim}


\section{Operator Overloading}
\label{\detokenize{Lecture5/Objects:operator-overloading}}

\subsection{What is overloading?}
\label{\detokenize{Lecture5/Objects:what-is-overloading}}
Recall that the addition operation \sphinxcode{\sphinxupquote{+}} behaves differently for different types.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o+ow}{in} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{!r:}\PYG{l+s+s1}{\PYGZca{}5}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ + }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y}\PYG{l+s+si}{!r:}\PYG{l+s+s1}{\PYGZca{}5}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{o}{+}\PYG{n}{y}\PYG{l+s+si}{!r\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  1   +   1   = 2
 \PYGZsq{}1\PYGZsq{}  +  \PYGZsq{}1\PYGZsq{}  = \PYGZsq{}11\PYGZsq{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{32}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{297}\PYG{n}{be71279db}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{k}{for} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o+ow}{in} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{2}     \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{!r:}\PYG{l+s+s1}{\PYGZca{}5}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ + }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y}\PYG{l+s+si}{!r:}\PYG{l+s+s1}{\PYGZca{}5}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{o}{+}\PYG{n}{y}\PYG{l+s+si}{!r\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n+ne}{TypeError}: unsupported operand type(s) for +: \PYGZsq{}int\PYGZsq{} and \PYGZsq{}str\PYGZsq{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Having an operator perform differently based on its argument types is called \sphinxhref{https://en.wikipedia.org/wiki/Operator\_overloading}{operator \sphinxstyleemphasis{overloading}}.

\item {} 
\sphinxcode{\sphinxupquote{+}} is called a \sphinxstyleemphasis{generic} operator.

\item {} 
We can also have function overloading to create generic functions.

\end{itemize}


\subsection{How to dispatch on type?}
\label{\detokenize{Lecture5/Objects:how-to-dispatch-on-type}}
The strategy of checking the type for the appropriate implementation is called \sphinxstyleemphasis{dispatching on type}.

A naive idea is to put all different implementations together with case\sphinxhyphen{}by\sphinxhyphen{}case checks of operand types.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}case\PYGZus{}by\PYGZus{}case}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Do integer summation...}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n+nb}{str}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n+nb}{str}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Do string concatenation...}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Return a TypeError...}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{x} \PYG{o}{+} \PYG{n}{y}  \PYG{c+c1}{\PYGZsh{} replaced by internal implementations}


\PYG{k}{for} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o+ow}{in} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{!r:}\PYG{l+s+s1}{\PYGZca{}10}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ + }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y}\PYG{l+s+si}{!r:}\PYG{l+s+s1}{\PYGZca{}10}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{add\PYGZus{}case\PYGZus{}by\PYGZus{}case}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{l+s+si}{!r\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Do integer summation...
    1      +     1      = 2
Do string concatenation...
   \PYGZsq{}1\PYGZsq{}     +    \PYGZsq{}1\PYGZsq{}     = \PYGZsq{}11\PYGZsq{}
Return a TypeError...
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{33}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{85}\PYG{n}{c671bf17e3}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{10} 
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{11} \PYG{k}{for} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o+ow}{in} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{12}     \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{!r:}\PYG{l+s+s1}{\PYGZca{}10}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ + }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y}\PYG{l+s+si}{!r:}\PYG{l+s+s1}{\PYGZca{}10}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{add\PYGZus{}case\PYGZus{}by\PYGZus{}case}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{l+s+si}{!r\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n+nn}{\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}33\PYGZhy{}85c671bf17e3\PYGZgt{}} in \PYG{n+ni}{add\PYGZus{}case\PYGZus{}by\PYGZus{}case}\PYG{n+nt}{(x, y)}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{6}     \PYG{k}{else}\PYG{p}{:}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{7}         \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Return a TypeError...}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{8}     \PYG{k}{return} \PYG{n}{x} \PYG{o}{+} \PYG{n}{y}  \PYG{c+c1}{\PYGZsh{} replaced by internal implementations}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{9} 
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{10} 

\PYG{n+ne}{TypeError}: unsupported operand type(s) for +: \PYGZsq{}int\PYGZsq{} and \PYGZsq{}str\PYGZsq{}
\end{sphinxVerbatim}

It can get quite messy with all possible types and combinations.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o+ow}{in} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{1.1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nb}{complex}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{!r:}\PYG{l+s+s1}{\PYGZca{}10}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ + }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y}\PYG{l+s+si}{!r:}\PYG{l+s+s1}{\PYGZca{}10}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{o}{+}\PYG{n}{y}\PYG{l+s+si}{!r\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    1      +    1.1     = 2.1
    1      +   (1+2j)   = (2+2j)
  (1, 2)   +   (1, 2)   = (1, 2, 1, 2)
\end{sphinxVerbatim}

\sphinxstylestrong{What about new data types?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{fractions} \PYG{k+kn}{import} \PYG{n}{Fraction}  \PYG{c+c1}{\PYGZsh{} non\PYGZhy{}built\PYGZhy{}in type for fractions}
\PYG{k}{for} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o+ow}{in} \PYG{p}{(}\PYG{p}{(}\PYG{n}{Fraction}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Fraction}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ + }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{o}{+}\PYG{n}{y}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1/2 + 1 = 3/2
1 + 1/2 = 3/2
\end{sphinxVerbatim}

Weaknesses of the naive approach:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
New data types require rewriting the addition operation.

\item {} 
A programmer may not know all other types and combinations to rewrite the code properly.

\end{enumerate}


\subsection{How to have data\sphinxhyphen{}directed programming?}
\label{\detokenize{Lecture5/Objects:how-to-have-data-directed-programming}}
The idea is to treat an implementation as a datum that can be returned by the operand types.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x + y}} is a \sphinxhref{https://en.wikipedia.org/wiki/Syntactic\_sugar}{\sphinxstyleemphasis{syntactic sugar}} that

\item {} 
invokes the method \sphinxcode{\sphinxupquote{type(x).\_\_add\_\_(x,y)}} of \sphinxcode{\sphinxupquote{type(x)}} to do the addition.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o+ow}{in} \PYG{p}{(}\PYG{n}{Fraction}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Fraction}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ + }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ = }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} instead of x + y}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1/2 + 1 = 3/2
1 + 1/2 = NotImplemented
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
The first case calls \sphinxcode{\sphinxupquote{Fraction.\_\_add\_\_}}, which provides a way to add \sphinxcode{\sphinxupquote{int}} to \sphinxcode{\sphinxupquote{Fraction}}.

\item {} 
The second case calls \sphinxcode{\sphinxupquote{int.\_\_add\_\_}}, which cannot provide any way of adding \sphinxcode{\sphinxupquote{Fraction}} to \sphinxcode{\sphinxupquote{int}}. (Why not?)

\end{itemize}

\sphinxstylestrong{Why return a \sphinxhref{https://docs.python.org/3.6/library/constants.html\#NotImplemented}{\sphinxcode{\sphinxupquote{NotImplemented}} object} instead of raising an error/exception?}
\begin{itemize}
\item {} 
This allows \sphinxcode{\sphinxupquote{+}} to continue to handle the addition by

\item {} 
dispatching on \sphinxcode{\sphinxupquote{Fraction}} to call its reverse addition method \sphinxhref{https://docs.python.org/3.6/library/numbers.html\#implementing-the-arithmetic-operations}{\sphinxcode{\sphinxupquote{\_\_radd\_\_}}}.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 500
from fractions import Fraction
def add(x, y):
    \PYGZsq{}\PYGZsq{}\PYGZsq{}Simulate the + operator.\PYGZsq{}\PYGZsq{}\PYGZsq{}
    sum = x.\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}(y)
    if sum is NotImplemented:
        sum = y.\PYGZus{}\PYGZus{}radd\PYGZus{}\PYGZus{}(x)
    return sum


for x, y in (Fraction(1, 2), 1), (1, Fraction(1, 2)):
    print(f\PYGZsq{}\PYGZob{}x\PYGZcb{} + \PYGZob{}y\PYGZcb{} = \PYGZob{}add(x,y)\PYGZcb{}\PYGZsq{})
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f5bc28de8d0\PYGZgt{}
\end{sphinxVerbatim}

The object\sphinxhyphen{}oriented programming techniques involved are formally called:
\begin{itemize}
\item {} 
\sphinxhref{https://en.wikipedia.org/wiki/Polymorphism\_(computer\_science)}{\sphinxstyleemphasis{Polymorphism}}: Different types can have different implementations of the \sphinxcode{\sphinxupquote{\_\_add\_\_}} method.

\item {} 
\sphinxhref{https://en.wikipedia.org/wiki/Dynamic\_dispatch}{\sphinxstyleemphasis{Single dispatch}}: The implementation is chosen based on one single type at a time.

\end{itemize}

Remarks:
\begin{itemize}
\item {} 
A method with starting and trailing double underscores in its name is called a \sphinxhref{https://dbader.org/blog/meaning-of-underscores-in-python}{\sphinxstyleemphasis{dunder method}}.

\item {} 
Dunder methods are not intended to be called directly. E.g., we normally use \sphinxcode{\sphinxupquote{+}} instead of \sphinxcode{\sphinxupquote{\_\_add\_\_}}.

\item {} 
\sphinxhref{https://docs.python.org/3/library/operator.html?highlight=operator}{Other operators} have their corresponding dunder methods that overloads the operator.

\end{itemize}


\section{Object Aliasing}
\label{\detokenize{Lecture5/Objects:object-aliasing}}
\sphinxstylestrong{When are two objects identical?}
\begin{itemize}
\item {} 
Two objects are the same if they occupy the same memory.

\item {} 
The keyword \sphinxcode{\sphinxupquote{is}} checks whether two objects are the same object.

\item {} 
The function \sphinxcode{\sphinxupquote{id}} returns a unique id number for each object.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 400
x, y = complex(1,2), complex(1,2)
z = x

for expr in \PYGZsq{}id(x)\PYGZsq{}, \PYGZsq{}id(y)\PYGZsq{}, \PYGZsq{}id(z)\PYGZsq{}, \PYGZsq{}x == y == z\PYGZsq{}, \PYGZsq{}x is y\PYGZsq{}, \PYGZsq{}x is z\PYGZsq{}:
    print(expr,eval(expr))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f5bc19150b8\PYGZgt{}
\end{sphinxVerbatim}

As the box\sphinxhyphen{}pointer diagram shows:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{x}} is not \sphinxcode{\sphinxupquote{y}} because they point to objects at different memory locations,even though the objects have the same type and value.

\item {} 
\sphinxcode{\sphinxupquote{x}} is \sphinxcode{\sphinxupquote{z}} because the assignment \sphinxcode{\sphinxupquote{z = x}} binds \sphinxcode{\sphinxupquote{z}} to the same memory location \sphinxcode{\sphinxupquote{x}} points to.\sphinxcode{\sphinxupquote{z}} is said to be an \sphinxstyleemphasis{alias} (another name) of \sphinxcode{\sphinxupquote{x}}.

\end{itemize}

\sphinxstylestrong{Should we use \sphinxcode{\sphinxupquote{is}} or \sphinxcode{\sphinxupquote{==}}?}

\sphinxcode{\sphinxupquote{is}} is faster but:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1} \PYG{o+ow}{is} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{o+ow}{is} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{o}{==} \PYG{l+m+mf}{1.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(True, False, True)
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{1 is 1.}} returns false because \sphinxcode{\sphinxupquote{1}} is \sphinxcode{\sphinxupquote{int}} but \sphinxcode{\sphinxupquote{1.}} is \sphinxcode{\sphinxupquote{float}}.

\item {} 
\sphinxcode{\sphinxupquote{==}} calls the method \sphinxcode{\sphinxupquote{\_\_eq\_\_}} of \sphinxcode{\sphinxupquote{float}} which returns mathematical equivalence.

\end{itemize}

\sphinxstyleemphasis{Can we use \sphinxcode{\sphinxupquote{is}} for integer comparison?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{1234}\PYG{p}{,} \PYG{l+m+mi}{1234}
\PYG{l+m+mi}{1234} \PYG{o+ow}{is} \PYG{l+m+mi}{1234}\PYG{p}{,} \PYG{n}{x} \PYG{o+ow}{is} \PYG{n}{y}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(True, False)
\end{sphinxVerbatim}

No. The behavior of \sphinxcode{\sphinxupquote{is}} is not entirely predictable.

\sphinxstylestrong{When should we use \sphinxcode{\sphinxupquote{is}}?}

\sphinxcode{\sphinxupquote{is}} can be used for \sphinxhref{https://docs.python.org/3/library/constants.html\#built-in-constants}{built\sphinxhyphen{}in constants} such as \sphinxcode{\sphinxupquote{None}} and  \sphinxcode{\sphinxupquote{NotImplemented}}because there can only be one instance of each of them.


\chapter{More on Functions}
\label{\detokenize{Lecture6/More on Functions:more-on-functions}}\label{\detokenize{Lecture6/More on Functions::doc}}

\section{Recursion}
\label{\detokenize{Lecture6/More on Functions:recursion}}
Consider computing the \sphinxhref{https://en.wikipedia.org/wiki/Fibonacci\_number}{Fibonacci number} of order \(n\):
\begin{equation*}
\begin{split}
F_n := 
\begin{cases}
F_{n-1}+F_{n-2} & n>1 \kern1em \text{(recurrence)}\\
1 & n=1 \kern1em \text{(base case)}\\
0 & n=0 \kern1em \text{(base case)}.
\end{cases}\end{split}
\end{equation*}
Fibonacci numbers have practical applications in generating \sphinxhref{https://en.wikipedia.org/wiki/Lagged\_Fibonacci\_generator}{pseudorandom numbers}.

\sphinxstylestrong{Can we define the function by calling the function itself?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}r \PYGZhy{}h 450
def fibonacci(n):
    if n \PYGZgt{} 1:
        return fibonacci(n \PYGZhy{} 1) + fibonacci(n \PYGZhy{} 2)  \PYGZsh{} recursion
    elif n == 1:
        return 1
    else:
        return 0

fibonacci(2)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fd7e27fc898\PYGZgt{}
\end{sphinxVerbatim}

\sphinxhref{https://en.wikipedia.org/wiki/Recursion\_(computer\_science)}{\sphinxstyleemphasis{Recursion}} is a function that calls itself (\sphinxstyleemphasis{recurs}).

\sphinxstylestrong{Exercise} Write a function \sphinxcode{\sphinxupquote{gcd}} that implements the \sphinxhref{https://en.wikipedia.org/wiki/Euclidean\_algorithm}{Euclidean algorithm for the greatest common divisor}:
\begin{equation*}
\begin{split}\operatorname{gcd}(a,b)=\begin{cases}a & b=0\\ \operatorname{gcd}(b, a\operatorname{mod}b) & \text{otherwise} \end{cases}\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}r \PYGZhy{}h 550
def gcd(a, b):
    \PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION
    return gcd(b, a \PYGZpc{} b) if b else a
    \PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION


gcd(3 * 5, 5 * 7)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
5
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fd7e27fca20\PYGZgt{}
\end{sphinxVerbatim}

\sphinxstylestrong{Is recursion strictly necessary?}

No. We can always convert a recursion to an iteration.E.g., the following computes the Fibonnacci number of order using a while loop instead.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}r \PYGZhy{}h 550
def fibonacci\PYGZus{}iteration(n):
    if n \PYGZgt{} 1:
        \PYGZus{}, F = 0, 1  \PYGZsh{} next two Fibonacci numbers
        while n \PYGZgt{} 1:
            \PYGZus{}, F, n = F, F + \PYGZus{}, n \PYGZhy{} 1
        return F
    elif n == 1:
        return 1
    else:
        return 0
    
fibonacci\PYGZus{}iteration(3)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
2
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fd7e807d5f8\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} more tests}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{assert} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{o}{==} \PYG{n}{fibonacci\PYGZus{}iteration}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Implement \sphinxcode{\sphinxupquote{gcd\_iteration}} using a while loop instead of a recursion.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}r \PYGZhy{}h 550
def gcd\PYGZus{}iteration(a, b):
    \PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION
    while b:
        a, b = b, a \PYGZpc{} b
    return a
    \PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION


gcd\PYGZus{}iteration(3 * 5, 5 * 7)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
5
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fd7e27fc2b0\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} test}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{assert} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{o}{==} \PYG{n}{fibonacci\PYGZus{}iteration}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{What is the benefit of recursion?}
\begin{itemize}
\item {} 
Recursion is often shorter and easier to understand.

\item {} 
It is also easier to write code by \sphinxstyleemphasis{wishful thinking} or \sphinxstyleemphasis{\sphinxhref{https://en.wikipedia.org/wiki/Declarative\_programming}{declarative programming}}.

\end{itemize}

\sphinxstylestrong{Is recusion more efficient than iteration?}

\sphinxstylestrong{Exercise} Find the smallest values of \sphinxcode{\sphinxupquote{n}} for\sphinxcode{\sphinxupquote{fibonacci(n)}} and \sphinxcode{\sphinxupquote{fibonacci\_iteration(n)}} respectively to run for more than a second.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Assign n}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{33}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\PYG{n}{fib\PYGZus{}recursion} \PYG{o}{=} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Assign n}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{300000}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\PYG{n}{fib\PYGZus{}iteration} \PYG{o}{=} \PYG{n}{fibonacci\PYGZus{}iteration}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\end{sphinxVerbatim}

To see why recursion is slow, we will modify \sphinxcode{\sphinxupquote{fibonacci}} to print each function call as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{fibonacci}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Returns the Fibonacci number of order n.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fibonacci(}\PYG{l+s+si}{\PYGZob{}!r\PYGZcb{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{k}{else} \PYG{l+m+mi}{1} \PYG{k}{if} \PYG{n}{n} \PYG{o}{==} \PYG{l+m+mi}{1} \PYG{k}{else} \PYG{l+m+mi}{0}


\PYG{n}{fibonacci}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
fibonacci(5)
fibonacci(4)
fibonacci(3)
fibonacci(2)
fibonacci(1)
fibonacci(0)
fibonacci(1)
fibonacci(2)
fibonacci(1)
fibonacci(0)
fibonacci(3)
fibonacci(2)
fibonacci(1)
fibonacci(0)
fibonacci(1)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
5
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{fibonacci(5)}} calls \sphinxcode{\sphinxupquote{fibonacci(3)}} and \sphinxcode{\sphinxupquote{fibonacci(4)}}, which in turn call \sphinxcode{\sphinxupquote{fibonacci(2)}} and \sphinxcode{\sphinxupquote{fibonacci(3)}}. \sphinxcode{\sphinxupquote{fibonacci(3)}} is called twice.


\section{Global Variables}
\label{\detokenize{Lecture6/More on Functions:global-variables}}
Consider the problem of generating a sequence of Fibonacci numbers.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fibonacci\PYGZus{}iteration}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0
1
1
2
3
\end{sphinxVerbatim}

\sphinxstylestrong{Is the above loop efficient?}

No. Each call to \sphinxcode{\sphinxupquote{fibonacci\_iteration(n)}} recomputes the last two Fibonacci numbers \(F_{n-1}\) and \(F_{n-2}\) for \(n\geq 2\).

\sphinxstylestrong{How to avoid redundant computations?}

One way is to store the last two computed Fibonacci numbers.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 600
def next\PYGZus{}fibonacci():
    \PYGZsq{}\PYGZsq{}\PYGZsq{}Returns the next Fibonacci number.\PYGZsq{}\PYGZsq{}\PYGZsq{}
    global \PYGZus{}Fn, \PYGZus{}Fn1, \PYGZus{}n  \PYGZsh{} global declaration
    value = \PYGZus{}Fn
    \PYGZus{}Fn, \PYGZus{}Fn1, \PYGZus{}n = \PYGZus{}Fn1, \PYGZus{}Fn + \PYGZus{}Fn1, \PYGZus{}n + 1
    return value

def print\PYGZus{}fibonacci\PYGZus{}state():
    print(\PYGZsq{}\PYGZsq{}\PYGZsq{}States:
    \PYGZus{}Fn  : Next Fibonacci number      = \PYGZob{}\PYGZcb{}
    \PYGZus{}Fn1 : Next next Fibonacci number = \PYGZob{}\PYGZcb{}
    \PYGZus{}n   : Next order                 = \PYGZob{}\PYGZcb{}\PYGZsq{}\PYGZsq{}\PYGZsq{}.format(\PYGZus{}Fn,\PYGZus{}Fn1,\PYGZus{}n))

\PYGZsh{} global variables for next\PYGZus{}fibonacci and print\PYGZus{}fibonacci\PYGZus{}state
\PYGZus{}Fn, \PYGZus{}Fn1, \PYGZus{}n = 0, 1, 0

for n in range(5):
    print(next\PYGZus{}fibonacci())
print\PYGZus{}fibonacci\PYGZus{}state()
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fd7e1f9f240\PYGZgt{}
\end{sphinxVerbatim}

Rules for \sphinxhref{https://docs.python.org/3/faq/programming.html\#what-are-the-rules-for-local-and-global-variables-in-python}{\sphinxstyleemphasis{global/local variables}}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
A local variable must be defined within a function.

\item {} 
An assignment defines a local variable except in a \sphinxhref{https://docs.python.org/3/reference/simple\_stmts.html\#the-global-statement}{\sphinxcode{\sphinxupquote{global}} statement}.

\end{enumerate}

\sphinxstylestrong{Why \sphinxcode{\sphinxupquote{global}} is NOT needed in \sphinxcode{\sphinxupquote{print\_fibonacci\_state}}?}

Without ambiguity, \sphinxcode{\sphinxupquote{\_Fn, \_Fn1, \_n}} in \sphinxcode{\sphinxupquote{print\_fibonacci\_state}} are not local variables by Rule 1 because they are not defined within the function.

\sphinxstylestrong{Why \sphinxcode{\sphinxupquote{global}} is needed in \sphinxcode{\sphinxupquote{next\_fibonacci}}?}

What happens otherwise:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{next\PYGZus{}fibonacci}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Returns the next Fibonacci number.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{c+c1}{\PYGZsh{} global \PYGZus{}Fn, \PYGZus{}Fn1, \PYGZus{}n}
    \PYG{n}{value} \PYG{o}{=} \PYG{n}{\PYGZus{}Fn}
    \PYG{n}{\PYGZus{}Fn}\PYG{p}{,} \PYG{n}{\PYGZus{}Fn1}\PYG{p}{,} \PYG{n}{\PYGZus{}n} \PYG{o}{=} \PYG{n}{\PYGZus{}Fn1}\PYG{p}{,} \PYG{n}{\PYGZus{}Fn} \PYG{o}{+} \PYG{n}{\PYGZus{}Fn1}\PYG{p}{,} \PYG{n}{\PYGZus{}n} \PYG{o}{+} \PYG{l+m+mi}{1}
    \PYG{k}{return} \PYG{n}{value}

\PYG{n}{next\PYGZus{}fibonacci}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{UnboundLocalError}\PYG{g+gWhitespace}{                         }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{13}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{44}\PYG{n}{c8c496bfd8}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{6}     \PYG{k}{return} \PYG{n}{value}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{7} 
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{8} \PYG{n}{next\PYGZus{}fibonacci}\PYG{p}{(}\PYG{p}{)}

\PYG{n+nn}{\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}13\PYGZhy{}44c8c496bfd8\PYGZgt{}} in \PYG{n+ni}{next\PYGZus{}fibonacci}\PYG{n+nt}{()}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2}     \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Returns the next Fibonacci number.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{3}     \PYG{c+c1}{\PYGZsh{} global \PYGZus{}Fn, \PYGZus{}Fn1, \PYGZus{}n}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{4}     \PYG{n}{value} \PYG{o}{=} \PYG{n}{\PYGZus{}Fn}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{5}     \PYG{n}{\PYGZus{}Fn}\PYG{p}{,} \PYG{n}{\PYGZus{}Fn1}\PYG{p}{,} \PYG{n}{\PYGZus{}n} \PYG{o}{=} \PYG{n}{\PYGZus{}Fn1}\PYG{p}{,} \PYG{n}{\PYGZus{}Fn} \PYG{o}{+} \PYG{n}{\PYGZus{}Fn1}\PYG{p}{,} \PYG{n}{\PYGZus{}n} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{6}     \PYG{k}{return} \PYG{n}{value}

\PYG{n+ne}{UnboundLocalError}: local variable \PYGZsq{}\PYGZus{}Fn\PYGZsq{} referenced before assignment
\end{sphinxVerbatim}

Why is there an \sphinxcode{\sphinxupquote{UnboundLocalError}}?
\begin{itemize}
\item {} 
The assignment defines \sphinxcode{\sphinxupquote{\_Fn}} as a local variable by Rule 2.

\item {} 
However, the assignment requires first evaluating \sphinxcode{\sphinxupquote{\_Fn}}, which is not yet defined.

\end{itemize}

\sphinxstylestrong{Are global variables preferred over local ones?}

Suppose for aesthetic reasons we remove the underscores in global variable names?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 600
def next\PYGZus{}fibonacci():
    \PYGZsq{}\PYGZsq{}\PYGZsq{}Returns the next Fibonacci number.\PYGZsq{}\PYGZsq{}\PYGZsq{}
    global Fn, Fn1, n
    value = Fn
    Fn, Fn1, n = Fn1, Fn + Fn1, n + 1
    return value

def print\PYGZus{}fibonacci\PYGZus{}state():
    print(\PYGZsq{}\PYGZsq{}\PYGZsq{}States:
    Fn  : Next Fibonacci number      = \PYGZob{}\PYGZcb{}
    Fn1 : Next next Fibonacci number = \PYGZob{}\PYGZcb{}
    n   : Next order                 = \PYGZob{}\PYGZcb{}\PYGZsq{}\PYGZsq{}\PYGZsq{}.format(Fn,Fn1,n))

\PYGZsh{} global variables renamed without underscores
Fn, Fn1, n = 0, 1, 0

n = 0
while n \PYGZlt{} 5:
    print(next\PYGZus{}fibonacci())
    n += 1
print\PYGZus{}fibonacci\PYGZus{}state()
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fd7e1f9fa20\PYGZgt{}
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Why does the while loop prints only 3 instead of 5 Fibonacci numbers?

There is a name collision. \sphinxcode{\sphinxupquote{n}} is also incremented by \sphinxcode{\sphinxupquote{next\_fibonacci()}}, and so the while loop is only executed 3 times in total.

With global variables
\begin{itemize}
\item {} 
codes are less predictable, more difficult to reuse/extend, and

\item {} 
tests cannot be isolated, making debugging difficult.

\end{itemize}

\sphinxstylestrong{Is it possible to store the function states without using global variables?}

Yes. We can use nested functions and \sphinxhref{https://docs.python.org/3/reference/simple\_stmts.html\#grammar-token-nonlocal-stmt}{\sphinxcode{\sphinxupquote{nonlocal}} variables}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{fibonacci\PYGZus{}closure}\PYG{p}{(}\PYG{n}{Fn}\PYG{p}{,} \PYG{n}{Fn1}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{next\PYGZus{}fibonacci}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Returns the next (generalized) Fibonacci number starting with }
\PYG{l+s+sd}{        Fn and Fn1 as the first two numbers.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
        \PYG{k}{nonlocal} \PYG{n}{Fn}\PYG{p}{,} \PYG{n}{Fn1}\PYG{p}{,} \PYG{n}{n}  \PYG{c+c1}{\PYGZsh{} declare nonlocal variables}
        \PYG{n}{value} \PYG{o}{=} \PYG{n}{Fn}
        \PYG{n}{Fn}\PYG{p}{,} \PYG{n}{Fn1}\PYG{p}{,} \PYG{n}{n} \PYG{o}{=} \PYG{n}{Fn1}\PYG{p}{,} \PYG{n}{Fn} \PYG{o}{+} \PYG{n}{Fn1}\PYG{p}{,} \PYG{n}{n} \PYG{o}{+} \PYG{l+m+mi}{1}
        \PYG{k}{return} \PYG{n}{value}

    \PYG{k}{def} \PYG{n+nf}{print\PYGZus{}fibonacci\PYGZus{}state}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+s1}{States:}
\PYG{l+s+s1}{        Next Fibonacci number      = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}
\PYG{l+s+s1}{        Next next Fibonacci number = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}
\PYG{l+s+s1}{        Next order                 = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{Fn}\PYG{p}{,} \PYG{n}{Fn1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{0}  \PYG{c+c1}{\PYGZsh{} Fn and Fn1 specified in the function arguments}
    \PYG{k}{return} \PYG{n}{next\PYGZus{}fibonacci}\PYG{p}{,} \PYG{n}{print\PYGZus{}fibonacci\PYGZus{}state}


\PYG{n}{next\PYGZus{}fibonacci}\PYG{p}{,} \PYG{n}{print\PYGZus{}fibonacci\PYGZus{}state} \PYG{o}{=} \PYG{n}{fibonacci\PYGZus{}closure}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{next\PYGZus{}fibonacci}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{n} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{print\PYGZus{}fibonacci\PYGZus{}state}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0
1
1
2
3
States:
        Next Fibonacci number      = 5
        Next next Fibonacci number = 8
        Next order                 = 5
\end{sphinxVerbatim}

The state variables \sphinxcode{\sphinxupquote{Fn, Fn1, n}} are now \sphinxstyleemphasis{encapsulated}, and sothe functions returned by \sphinxcode{\sphinxupquote{fibonacci\_closure}} no longer depends on any global variables.

Another benefit of using nested functions is that we can also create different Fibonacci sequence with different base cases.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}next\PYGZus{}fibonacci}\PYG{p}{,} \PYG{n}{my\PYGZus{}print\PYGZus{}fibonacci\PYGZus{}state} \PYG{o}{=} \PYG{n}{fibonacci\PYGZus{}closure}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1302}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{my\PYGZus{}next\PYGZus{}fibonacci}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{my\PYGZus{}print\PYGZus{}fibonacci\PYGZus{}state}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cs
1302
cs1302
1302cs1302
cs13021302cs1302
States:
        Next Fibonacci number      = 1302cs1302cs13021302cs1302
        Next next Fibonacci number = cs13021302cs13021302cs1302cs13021302cs1302
        Next order                 = 5
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{next\_fibonacci}} and \sphinxcode{\sphinxupquote{print\_fibonacci\_state}} are \sphinxstyleemphasis{local functions} of \sphinxcode{\sphinxupquote{fibonacci\_closure}}.
\begin{itemize}
\item {} 
They can access (\sphinxstyleemphasis{capture}) the other local variables of \sphinxcode{\sphinxupquote{fibonacci\_closure}} by forming the so\sphinxhyphen{}called \sphinxstyleemphasis{closures}.

\item {} 
Similar to the use of \sphinxcode{\sphinxupquote{global}} statement, a \sphinxhref{https://docs.python.org/3/reference/simple\_stmts.html\#the-nonlocal-statement}{\sphinxcode{\sphinxupquote{non\sphinxhyphen{}local}} statement} is needed for assigning nonlocal variables.

\end{itemize}

Each local function has an attribute named \sphinxcode{\sphinxupquote{\_\_closure\_\_}} that stores the captured local variables.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}closure}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Print the closure of a function.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{closure of }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{f}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{cell} \PYG{o+ow}{in} \PYG{n}{f}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}closure\PYGZus{}\PYGZus{}}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{    }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{ content: }\PYG{l+s+si}{\PYGZob{}!r\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{,} \PYG{n}{cell}\PYG{o}{.}\PYG{n}{cell\PYGZus{}contents}\PYG{p}{)}\PYG{p}{)}


\PYG{n}{print\PYGZus{}closure}\PYG{p}{(}\PYG{n}{next\PYGZus{}fibonacci}\PYG{p}{)}
\PYG{n}{print\PYGZus{}closure}\PYG{p}{(}\PYG{n}{print\PYGZus{}fibonacci\PYGZus{}state}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
closure of  next\PYGZus{}fibonacci
    \PYGZlt{}cell at 0x7fd7e98a9978: int object at 0x55ee54d3a4a0\PYGZgt{} content: 5
    \PYGZlt{}cell at 0x7fd7e98a99d8: int object at 0x55ee54d3a500\PYGZgt{} content: 8
    \PYGZlt{}cell at 0x7fd7e98a9e88: int object at 0x55ee54d3a4a0\PYGZgt{} content: 5
closure of  print\PYGZus{}fibonacci\PYGZus{}state
    \PYGZlt{}cell at 0x7fd7e98a9978: int object at 0x55ee54d3a4a0\PYGZgt{} content: 5
    \PYGZlt{}cell at 0x7fd7e98a99d8: int object at 0x55ee54d3a500\PYGZgt{} content: 8
    \PYGZlt{}cell at 0x7fd7e98a9e88: int object at 0x55ee54d3a4a0\PYGZgt{} content: 5
\end{sphinxVerbatim}


\section{Generator}
\label{\detokenize{Lecture6/More on Functions:generator}}
Another way to generate a sequence of objects one\sphinxhyphen{}by\sphinxhyphen{}one is to write a \sphinxstyleemphasis{generator}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fibonacci\PYGZus{}generator} \PYG{o}{=} \PYG{p}{(}\PYG{n}{fibonacci\PYGZus{}iteration}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{fibonacci\PYGZus{}generator}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}generator object \PYGZlt{}genexpr\PYGZgt{} at 0x7fd7e1f08de0\PYGZgt{}
\end{sphinxVerbatim}

The above uses a \sphinxhref{https://docs.python.org/3/reference/expressions.html\#grammar-token-generator-expression}{\sphinxstyleemphasis{generator expression}} to define \sphinxcode{\sphinxupquote{fibonacci\_generator}}.

\sphinxstylestrong{How to obtain items from a generator?}

We can use the \sphinxhref{https://docs.python.org/3/library/functions.html\#next}{\sphinxcode{\sphinxupquote{next}} function}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:} 
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{fibonacci\PYGZus{}generator}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} raises StopIterationException eventually}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0
1
1
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{StopIteration}\PYG{g+gWhitespace}{                             }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{19}\PYG{o}{\PYGZhy{}}\PYG{n}{e6f031ce2829}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{2}     \PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{fibonacci\PYGZus{}generator}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} raises StopIterationException eventually}

\PYG{n+ne}{StopIteration}: 
\end{sphinxVerbatim}

A generator object is \sphinxhref{https://www.programiz.com/python-programming/iterator}{\sphinxstyleemphasis{iterable}}, i.e., it implements both \sphinxcode{\sphinxupquote{\_\_iter\_\_}} and \sphinxcode{\sphinxupquote{\_\_next\_\_}} methods that are automatically called in a \sphinxcode{\sphinxupquote{for}} loop as well as the \sphinxcode{\sphinxupquote{next}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fibonacci\PYGZus{}generator} \PYG{o}{=} \PYG{p}{(}\PYG{n}{fibonacci\PYGZus{}iteration}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{fib} \PYG{o+ow}{in} \PYG{n}{fibonacci\PYGZus{}generator}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} StopIterationException handled by for loop}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fib}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0
1
1
2
3
\end{sphinxVerbatim}

\sphinxstylestrong{Is \sphinxcode{\sphinxupquote{fibonacci\_generator}} efficient?}

No again due to redundant computations.A better way to define the generator is to use the keyword \sphinxhref{https://docs.python.org/3/reference/expressions.html?highlight=yield\#yield-expressions}{\sphinxcode{\sphinxupquote{yield}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 450
def fibonacci\PYGZus{}sequence(Fn, Fn1, stop):
    \PYGZsq{}\PYGZsq{}\PYGZsq{}Return a generator that generates Fibonacci numbers
    starting from Fn and Fn1 until stop (exclusive).\PYGZsq{}\PYGZsq{}\PYGZsq{}
    while Fn \PYGZlt{} stop:
        yield Fn  \PYGZsh{} return Fn and pause execution
        Fn, Fn1 = Fn1, Fn1 + Fn


for fib in fibonacci\PYGZus{}sequence(0, 1, 5):
    print(fib)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fd7e27fc898\PYGZgt{}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxcode{\sphinxupquote{yield}} causes the function to return a \sphinxstyleemphasis{generator} without executing the function body.

\item {} 
Calling \sphinxcode{\sphinxupquote{\_\_next\_\_}} resumes the execution, which
\begin{itemize}
\item {} 
pauses at the next \sphinxcode{\sphinxupquote{yield}} expression, or

\item {} 
raises the \sphinxcode{\sphinxupquote{StopIterationException}} at the end.

\end{itemize}

\end{enumerate}

\sphinxstylestrong{Exercise} The yield expression \sphinxcode{\sphinxupquote{yield ...}} is mistaken in {[}Halterman17{]} to be a statement. It is actually an expression because
\begin{itemize}
\item {} 
The value of a \sphinxcode{\sphinxupquote{yield}} expression is \sphinxcode{\sphinxupquote{None}} by default, but

\item {} 
it can be set by the \sphinxcode{\sphinxupquote{generator.send}} method.

\end{itemize}

Add the document string to the following function. In particular, explain the effect of calling the method \sphinxcode{\sphinxupquote{send}} on the returned generator.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}r \PYGZhy{}h 500
def fibonacci\PYGZus{}sequence(Fn, Fn1, stop):
    \PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION
    \PYGZsq{}\PYGZsq{}\PYGZsq{}Return a generator that generates Fibonacci numbers
    starting from Fn and Fn1 to stop (exclusive). 
    generator.send(value) sets next number to value.\PYGZsq{}\PYGZsq{}\PYGZsq{}
    \PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION
    while Fn \PYGZlt{} stop:
        value = yield Fn
        if value is not None: 
            Fn1 = value  \PYGZsh{} set next number to the value of yield expression
        Fn, Fn1 = Fn1, Fn1 + Fn 
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fd7e807d438\PYGZgt{}
\end{sphinxVerbatim}


\section{Optional Arguments}
\label{\detokenize{Lecture6/More on Functions:optional-arguments}}
\sphinxstylestrong{How to make function arguments optional?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{fibonacci\PYGZus{}sequence}\PYG{p}{(}\PYG{n}{Fn}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Fn1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{stop}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{while} \PYG{n}{stop} \PYG{o+ow}{is} \PYG{k+kc}{None} \PYG{o+ow}{or} \PYG{n}{Fn} \PYG{o}{\PYGZlt{}} \PYG{n}{stop}\PYG{p}{:}
        \PYG{n}{value} \PYG{o}{=} \PYG{k}{yield} \PYG{n}{Fn}
        \PYG{n}{Fn}\PYG{p}{,} \PYG{n}{Fn1} \PYG{o}{=} \PYG{n}{Fn1}\PYG{p}{,} \PYG{n}{Fn1} \PYG{o}{+} \PYG{n}{Fn}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{fib} \PYG{o+ow}{in} \PYG{n}{fibonacci\PYGZus{}sequence}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fib}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} with all arguments specified}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0
1
1
2
3
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{fib} \PYG{o+ow}{in} \PYG{n}{fibonacci\PYGZus{}sequence}\PYG{p}{(}\PYG{n}{stop}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fib}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} with default Fn=0, Fn1=1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0
1
1
2
3
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{stop=5}} is called a \sphinxhref{https://docs.python.org/3/glossary.html\#term-keyword-argument}{keyword argument}. Unlike \sphinxcode{\sphinxupquote{positional arguments}}, it specifies the name of the argument explicitly.

\sphinxstylestrong{Exercise} \sphinxcode{\sphinxupquote{stop}} is an \sphinxhref{https://docs.python.org/3/tutorial/controlflow.html\#default-argument-values}{optional argument} with the \sphinxstyleemphasis{default value} \sphinxcode{\sphinxupquote{None}}. What is the behavior of the following code?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{fib} \PYG{o+ow}{in} \PYG{n}{fibonacci\PYGZus{}sequence}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fib}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{fib} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10}\PYG{p}{:}  
        \PYG{k}{break}  \PYG{c+c1}{\PYGZsh{} Will this be executed?}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
5
1
6
7
13
\end{sphinxVerbatim}

With the default value of \sphinxcode{\sphinxupquote{None}}, the while loop becomes an infinite loop. The generator will keep generating the next Fibonacci number without any bound on the order. In particular, \sphinxcode{\sphinxupquote{fibonacci\_sequence(5)}} creates an unstoppable (default) generator with base case \sphinxcode{\sphinxupquote{Fn=5}} (specified) and \sphinxcode{\sphinxupquote{Fn1=1}} (default).

Rules for specifying arguments:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Keyword arguments must be after all positional arguments.

\item {} 
Duplicate assignments to an argument are not allowed.

\end{enumerate}

E.g., the following results in error:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fibonacci\PYGZus{}sequence}\PYG{p}{(}\PYG{n}{stop}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{  File}\PYG{n+nn}{ \PYGZdq{}\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}27\PYGZhy{}c4b4809b18c1\PYGZgt{}\PYGZdq{}}\PYG{g+gt}{, line }\PYG{l+m+mi}{1}
    \PYG{n}{fibonacci\PYGZus{}sequence}\PYG{p}{(}\PYG{n}{stop}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
                               \PYG{o}{\PYGZca{}}
\PYG{n+ne}{SyntaxError}: positional argument follows keyword argument
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fibonacci\PYGZus{}sequence}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Fn}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{28}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{n}{db5e024912c}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n}{fibonacci\PYGZus{}sequence}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Fn}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n+ne}{TypeError}: fibonacci\PYGZus{}sequence() got multiple values for argument \PYGZsq{}Fn\PYGZsq{}
\end{sphinxVerbatim}

The following shows that the behavior of \sphinxcode{\sphinxupquote{range}} is different.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{count} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} counts from 1 to 10 in steps of 2}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{count} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} default step=1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{count} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} default start=0, step=1}
\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{stop}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} fails}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1 3 5 7 9 
1 2 3 4 5 6 7 8 9 
0 1 2 3 4 5 6 7 8 9 
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{29}\PYG{o}{\PYGZhy{}}\PYG{n}{f3395132058b}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{7} \PYG{k}{for} \PYG{n}{count} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{8}     \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} default start=0, step=1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{9} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{stop}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} fails}

\PYG{n+ne}{TypeError}: range() takes no keyword arguments
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{range}} takes only positional arguments.However, the first positional argument has different intepretations (\sphinxcode{\sphinxupquote{start}} or \sphinxcode{\sphinxupquote{stop}}) depending on the number of arguments (2 or 1).

\sphinxcode{\sphinxupquote{range}} is indeed NOT a generator.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}class \PYGZsq{}type\PYGZsq{}\PYGZgt{} \PYGZlt{}class \PYGZsq{}range\PYGZsq{}\PYGZgt{}
\end{sphinxVerbatim}


\section{Variable number of arguments}
\label{\detokenize{Lecture6/More on Functions:variable-number-of-arguments}}
We can simulate the behavior of range by having a \sphinxhref{https://docs.python.org/3.4/tutorial/controlflow.html\#arbitrary-argument-lists}{variable number of arguments}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}arguments}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Take any number of arguments and prints them\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{args (}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{): }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)}\PYG{p}{,}\PYG{n}{args}\PYG{p}{)}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{kwargs (}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{): }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{,}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{print\PYGZus{}arguments}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{stop}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}k\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{greeting}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{*}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
args (\PYGZlt{}class \PYGZsq{}tuple\PYGZsq{}\PYGZgt{}): (0, 10, 2)
kwargs (\PYGZlt{}class \PYGZsq{}dict\PYGZsq{}\PYGZgt{}): \PYGZob{}\PYGZsq{}start\PYGZsq{}: 1, \PYGZsq{}stop\PYGZsq{}: 2\PYGZcb{}
8 *
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{args}} is a tuple of positional arguments.

\item {} 
\sphinxcode{\sphinxupquote{kwargs}} is a dictionary of keyword arguments.

\end{itemize}

\sphinxcode{\sphinxupquote{*}} and \sphinxcode{\sphinxupquote{**}} are \sphinxstyleemphasis{unpacking operators} for tuple/list and dictionary respectively:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{args} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{kwargs} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{start}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{stop}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}
\PYG{n}{print\PYGZus{}arguments}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
args (\PYGZlt{}class \PYGZsq{}tuple\PYGZsq{}\PYGZgt{}): (0, 10, 2)
kwargs (\PYGZlt{}class \PYGZsq{}dict\PYGZsq{}\PYGZgt{}): \PYGZob{}\PYGZsq{}start\PYGZsq{}: 1, \PYGZsq{}stop\PYGZsq{}: 2\PYGZcb{}
\end{sphinxVerbatim}

The following function converts all the arguments to a string.It will be useful later on.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{argument\PYGZus{}string}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Return the string representation of the list of arguments.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{return} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{p}{[}
        \PYG{o}{*}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}!r\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{args}\PYG{p}{]}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} arguments}
        \PYG{o}{*}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{=}\PYG{l+s+si}{\PYGZob{}!r\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
          \PYG{k}{for} \PYG{n}{k}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} keyword arguments}
    \PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{argument\PYGZus{}string}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{stop}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}(0, 10, 2, start=1, stop=2)\PYGZsq{}
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Redefine \sphinxcode{\sphinxupquote{fibonacci\_sequence}} so that the positional arguments depend on the number of arguments:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{fibonacci\PYGZus{}sequence}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Return a generator that generates Fibonacci numbers}
\PYG{l+s+sd}{    starting from Fn and Fn1 to stop (exclusive). }
\PYG{l+s+sd}{    generator.send(value) sets next number to value.}
\PYG{l+s+sd}{    }
\PYG{l+s+sd}{    fibonacci\PYGZus{}sequence(stop)}
\PYG{l+s+sd}{    fibonacci\PYGZus{}sequence(Fn,Fn1)}
\PYG{l+s+sd}{    fibonacci\PYGZus{}sequence(Fn,Fn1,stop)}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n}{Fn}\PYG{p}{,} \PYG{n}{Fn1}\PYG{p}{,} \PYG{n}{stop} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kc}{None}  \PYG{c+c1}{\PYGZsh{} default values}

    \PYG{c+c1}{\PYGZsh{} handle different number of arguments}
    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)} \PYG{o+ow}{is} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
        \PYG{n}{stop} \PYG{o}{=} \PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
    \PYG{k}{elif} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)} \PYG{o+ow}{is} \PYG{l+m+mi}{2}\PYG{p}{:}
        \PYG{n}{Fn}\PYG{p}{,} \PYG{n}{Fn1} \PYG{o}{=} \PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{k}{elif} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2}\PYG{p}{:}
        \PYG{n}{Fn}\PYG{p}{,} \PYG{n}{Fn1}\PYG{p}{,} \PYG{n}{stop} \PYG{o}{=} \PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
    
    \PYG{k}{while} \PYG{n}{stop} \PYG{o+ow}{is} \PYG{k+kc}{None} \PYG{o+ow}{or} \PYG{n}{Fn} \PYG{o}{\PYGZlt{}} \PYG{n}{stop}\PYG{p}{:}
        \PYG{n}{value} \PYG{o}{=} \PYG{k}{yield} \PYG{n}{Fn}
        \PYG{k}{if} \PYG{n}{value} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:} 
            \PYG{n}{Fn1} \PYG{o}{=} \PYG{n}{value}  \PYG{c+c1}{\PYGZsh{} set next number to the value of yield expression}
        \PYG{n}{Fn}\PYG{p}{,} \PYG{n}{Fn1} \PYG{o}{=} \PYG{n}{Fn1}\PYG{p}{,} \PYG{n}{Fn1} \PYG{o}{+} \PYG{n}{Fn}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{fib} \PYG{o+ow}{in} \PYG{n}{fibonacci\PYGZus{}sequence}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} default Fn=0, Fn=1}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fib}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0
1
1
2
3
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{fib} \PYG{o+ow}{in} \PYG{n}{fibonacci\PYGZus{}sequence}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} default stop=None}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fib}\PYG{p}{)}  
    \PYG{k}{if} \PYG{n}{fib}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{5}\PYG{p}{:}
        \PYG{k}{break}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1
2
3
5
8
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{args} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{fib} \PYG{o+ow}{in} \PYG{n}{fibonacci\PYGZus{}sequence}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} default stop=None}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fib}\PYG{p}{)} 
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1
2
3
\end{sphinxVerbatim}


\section{Decorator}
\label{\detokenize{Lecture6/More on Functions:decorator}}
\sphinxstylestrong{What is function decoration?}\sphinxstylestrong{Why decorate a function?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{fibonacci}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Returns the Fibonacci number of order n.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{global} \PYG{n}{count}\PYG{p}{,} \PYG{n}{depth}
    \PYG{n}{count} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{depth} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}:\PYGZgt{}3\PYGZcb{}}\PYG{l+s+s1}{: }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{fibonacci(}\PYG{l+s+si}{\PYGZob{}!r\PYGZcb{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{|}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{depth}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
    
    \PYG{n}{value} \PYG{o}{=} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{k}{else} \PYG{l+m+mi}{1} \PYG{k}{if} \PYG{n}{n} \PYG{o}{==} \PYG{l+m+mi}{1} \PYG{k}{else} \PYG{l+m+mi}{0}
    
    \PYG{n}{depth} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{if} \PYG{n}{depth} \PYG{o+ow}{is} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} recursion done}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Done}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{count} \PYG{o}{=} \PYG{l+m+mi}{0}  \PYG{c+c1}{\PYGZsh{} reset count for subsequent recursions}
    \PYG{k}{return} \PYG{n}{value}


\PYG{n}{count}\PYG{p}{,} \PYG{n}{depth} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  1: fibonacci(0)
Done
0
  1: fibonacci(1)
Done
1
  1: fibonacci(2)
  2: |fibonacci(1)
  3: |fibonacci(0)
Done
1
  1: fibonacci(3)
  2: |fibonacci(2)
  3: ||fibonacci(1)
  4: ||fibonacci(0)
  5: |fibonacci(1)
Done
2
  1: fibonacci(4)
  2: |fibonacci(3)
  3: ||fibonacci(2)
  4: |||fibonacci(1)
  5: |||fibonacci(0)
  6: ||fibonacci(1)
  7: |fibonacci(2)
  8: ||fibonacci(1)
  9: ||fibonacci(0)
Done
3
  1: fibonacci(5)
  2: |fibonacci(4)
  3: ||fibonacci(3)
  4: |||fibonacci(2)
  5: ||||fibonacci(1)
  6: ||||fibonacci(0)
  7: |||fibonacci(1)
  8: ||fibonacci(2)
  9: |||fibonacci(1)
 10: |||fibonacci(0)
 11: |fibonacci(3)
 12: ||fibonacci(2)
 13: |||fibonacci(1)
 14: |||fibonacci(0)
 15: ||fibonacci(1)
Done
5
\end{sphinxVerbatim}

The code decorates the \sphinxcode{\sphinxupquote{fibonacci}} function by printing each recursive call and the depth of the call stack.The decoration is useful in showing the efficiency of the function, but it rewrites the function definition.

\sphinxstylestrong{How to decorate a function without changing its code?}
\begin{itemize}
\item {} 
What if the decorations are temporary and should be removed later?

\item {} 
Go through the source codes of all decorated functions to remove the decorations?

\item {} 
When updating a piece of code, switch back and forth between original and decorated codes?

\end{itemize}

What about defining a new function that calls and decorates the original function?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{fibonacci}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Returns the Fibonacci number of order n.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{return} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{k}{else} \PYG{l+m+mi}{1} \PYG{k}{if} \PYG{n}{n} \PYG{o+ow}{is} \PYG{l+m+mi}{1} \PYG{k}{else} \PYG{l+m+mi}{0}

\PYG{k}{def} \PYG{n+nf}{fibonacci\PYGZus{}decorated}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Returns the Fibonacci number of order n.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{global} \PYG{n}{count}\PYG{p}{,} \PYG{n}{depth}
    \PYG{n}{count} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{depth} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}:\PYGZgt{}3\PYGZcb{}}\PYG{l+s+s1}{: }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{fibonacci(}\PYG{l+s+si}{\PYGZob{}!r\PYGZcb{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{|}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{depth}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
    
    \PYG{n}{value} \PYG{o}{=} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    
    \PYG{n}{depth} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{if} \PYG{n}{depth} \PYG{o+ow}{is} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} recursion done}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Done}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{count} \PYG{o}{=} \PYG{l+m+mi}{0}  \PYG{c+c1}{\PYGZsh{} reset count for subsequent recursions}
    \PYG{k}{return} \PYG{n}{value}


\PYG{n}{count}\PYG{p}{,} \PYG{n}{depth} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fibonacci\PYGZus{}decorated}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}    
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  1: fibonacci(0)
Done
0
  1: fibonacci(1)
Done
1
  1: fibonacci(2)
Done
1
  1: fibonacci(3)
Done
2
  1: fibonacci(4)
Done
3
  1: fibonacci(5)
Done
5
\end{sphinxVerbatim}

We want \sphinxcode{\sphinxupquote{fibonacci}} to call \sphinxcode{\sphinxupquote{fibonacci\_decorated}} instead.What about renaming \sphinxcode{\sphinxupquote{fibonacci\_decorated}} to \sphinxcode{\sphinxupquote{fibonacci}}?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fibonacci} \PYG{o}{=} \PYG{n}{fibonacci\PYGZus{}decorated}
\PYG{n}{count}\PYG{p}{,} \PYG{n}{depth} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{n}{fibonacci\PYGZus{}decorated}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\end{sphinxVerbatim}

(If you are faint\sphinxhyphen{}hearted, don’t run the above code.)

We want \sphinxcode{\sphinxupquote{fibonacci\_decorated}} to call the original \sphinxcode{\sphinxupquote{fibonacci}}.

The solution is to capture the original \sphinxcode{\sphinxupquote{fibonacci}} in a closure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{functools}


\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}function\PYGZus{}call}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Return a decorator that prints function calls.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n+nd}{@functools}\PYG{o}{.}\PYG{n}{wraps}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} give wrapper the identity of f and more}
    \PYG{k}{def} \PYG{n+nf}{wrapper}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{nonlocal} \PYG{n}{count}\PYG{p}{,} \PYG{n}{depth}
        \PYG{n}{count} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{n}{depth} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{n}{call} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{,} \PYG{n}{argument\PYGZus{}string}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}:\PYGZgt{}3\PYGZcb{}}\PYG{l+s+s1}{:}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{|}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{depth}\PYG{p}{,} \PYG{n}{call}\PYG{p}{)}\PYG{p}{)}

        \PYG{n}{value} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} wrapper calls f}

        \PYG{n}{depth} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{k}{if} \PYG{n}{depth} \PYG{o+ow}{is} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Done}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
            \PYG{n}{count} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{k}{return} \PYG{n}{value}

    \PYG{n}{count}\PYG{p}{,} \PYG{n}{depth} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
    \PYG{k}{return} \PYG{n}{wrapper}  \PYG{c+c1}{\PYGZsh{} return the decorated function}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{print\_function\_call}} takes in \sphinxcode{\sphinxupquote{f}} and returns \sphinxcode{\sphinxupquote{wrapper}}, which captures and decorates \sphinxcode{\sphinxupquote{f}}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{wrapper}} expects the same set of arguments for \sphinxcode{\sphinxupquote{f}},

\item {} 
returns the same value returned by \sphinxcode{\sphinxupquote{f}} on the arguments, but

\item {} 
can execute additional codes before and after calling \sphinxcode{\sphinxupquote{f}} to print the function call.

\end{itemize}

By redefining \sphinxcode{\sphinxupquote{fibonacci}} as the returned \sphinxcode{\sphinxupquote{wrapper}}, the original \sphinxcode{\sphinxupquote{fibonacci}} captured by \sphinxcode{\sphinxupquote{wrapper}} calls \sphinxcode{\sphinxupquote{wrapper}} as desired.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{fibonacci}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{k}{else} \PYG{l+m+mi}{1} \PYG{k}{if} \PYG{n}{n} \PYG{o+ow}{is} \PYG{l+m+mi}{1} \PYG{k}{else} \PYG{l+m+mi}{0}


\PYG{n}{fibonacci} \PYG{o}{=} \PYG{n}{print\PYGZus{}function\PYGZus{}call}\PYG{p}{(}
    \PYG{n}{fibonacci}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} so original fibonnacci calls wrapper}
\PYG{n}{fibonacci}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  1:fibonacci(5)
  2:|fibonacci(4)
  3:||fibonacci(3)
  4:|||fibonacci(2)
  5:||||fibonacci(1)
  6:||||fibonacci(0)
  7:|||fibonacci(1)
  8:||fibonacci(2)
  9:|||fibonacci(1)
 10:|||fibonacci(0)
 11:|fibonacci(3)
 12:||fibonacci(2)
 13:|||fibonacci(1)
 14:|||fibonacci(0)
 15:||fibonacci(1)
Done
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
5
\end{sphinxVerbatim}

The redefinition does not change the original \sphinxcode{\sphinxupquote{fibonacci}} captured by \sphinxcode{\sphinxupquote{wrapper}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{inspect}
\PYG{k}{for} \PYG{n}{cell} \PYG{o+ow}{in} \PYG{n}{fibonacci}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}closure\PYGZus{}\PYGZus{}}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{callable}\PYG{p}{(}\PYG{n}{cell}\PYG{o}{.}\PYG{n}{cell\PYGZus{}contents}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{inspect}\PYG{o}{.}\PYG{n}{getsource}\PYG{p}{(}\PYG{n}{cell}\PYG{o}{.}\PYG{n}{cell\PYGZus{}contents}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
def fibonacci(n):
    return fibonacci(n \PYGZhy{} 1) + fibonacci(n \PYGZhy{} 2) if n \PYGZgt{} 1 else 1 if n is 1 else 0
\end{sphinxVerbatim}

Python provides the syntatic sugar below to simplify the redefinition.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@print\PYGZus{}function\PYGZus{}call}
\PYG{k}{def} \PYG{n+nf}{fibonacci}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{k}{else} \PYG{l+m+mi}{1} \PYG{k}{if} \PYG{n}{n} \PYG{o+ow}{is} \PYG{l+m+mi}{1} \PYG{k}{else} \PYG{l+m+mi}{0}


\PYG{n}{fibonacci}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  1:fibonacci(5)
  2:|fibonacci(4)
  3:||fibonacci(3)
  4:|||fibonacci(2)
  5:||||fibonacci(1)
  6:||||fibonacci(0)
  7:|||fibonacci(1)
  8:||fibonacci(2)
  9:|||fibonacci(1)
 10:|||fibonacci(0)
 11:|fibonacci(3)
 12:||fibonacci(2)
 13:|||fibonacci(1)
 14:|||fibonacci(0)
 15:||fibonacci(1)
Done
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
5
\end{sphinxVerbatim}

There are many techniques used in the above decorator.

\sphinxstylestrong{Why use a variable number of arguments in \sphinxcode{\sphinxupquote{wrapper}}}

To decorate any function with possibly different number of arguments.

\sphinxstylestrong{Why decorate the wrapper with \sphinxcode{\sphinxupquote{@functools.wraps(f)}}?}
\begin{itemize}
\item {} 
Ensures some attributes (such as \sphinxcode{\sphinxupquote{\_\_name\_\_}}) of the wrapper function is the same as those of \sphinxcode{\sphinxupquote{f}}.

\item {} 
Add useful attributes. E.g., \sphinxcode{\sphinxupquote{\_\_wrapped\_\_}} stores the original function so we can undo the decoration.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fibonacci}\PYG{p}{,} \PYG{n}{fibonacci\PYGZus{}decorated} \PYG{o}{=} \PYG{n}{fibonacci}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}wrapped\PYGZus{}\PYGZus{}}\PYG{p}{,} \PYG{n}{fibonacci}  \PYG{c+c1}{\PYGZsh{} recover}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{original fibonacci:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fibonacci}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{fibonacci} \PYG{o}{=} \PYG{n}{fibonacci\PYGZus{}decorated}  \PYG{c+c1}{\PYGZsh{} decorate}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{decorated fibonacci:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fibonacci}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
original fibonacci:
5
decorated fibonacci:
  1:fibonacci(5)
  2:|fibonacci(4)
  3:||fibonacci(3)
  4:|||fibonacci(2)
  5:||||fibonacci(1)
  6:||||fibonacci(0)
  7:|||fibonacci(1)
  8:||fibonacci(2)
  9:|||fibonacci(1)
 10:|||fibonacci(0)
 11:|fibonacci(3)
 12:||fibonacci(2)
 13:|||fibonacci(1)
 14:|||fibonacci(0)
 15:||fibonacci(1)
Done
5
\end{sphinxVerbatim}

\sphinxstylestrong{How to use decorator to improve recursion?}

We can also use a decorator to make recursion more efficient by caching the return values.\sphinxcode{\sphinxupquote{cache}} is a dictionary where \sphinxcode{\sphinxupquote{cache{[}n{]}}} stores the computed value of \(F_n\) to avoid redundant computations.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{caching}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Return a decorator that caches a function with a single argument.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n+nd}{@functools}\PYG{o}{.}\PYG{n}{wraps}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{wrapper}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{n} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{cache}\PYG{p}{:}
            \PYG{n}{cache}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{read from cache}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{cache}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}

    \PYG{n}{cache} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{n}{wrapper}\PYG{o}{.}\PYG{n}{clear\PYGZus{}cache} \PYG{o}{=} \PYG{k}{lambda} \PYG{p}{:} \PYG{n}{cache}\PYG{o}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} add method to clear cache}
    \PYG{k}{return} \PYG{n}{wrapper}


\PYG{n+nd}{@print\PYGZus{}function\PYGZus{}call}
\PYG{n+nd}{@caching}
\PYG{k}{def} \PYG{n+nf}{fibonacci}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{k}{else} \PYG{l+m+mi}{1} \PYG{k}{if} \PYG{n}{n} \PYG{o}{==} \PYG{l+m+mi}{1} \PYG{k}{else} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fibonacci}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{fibonacci}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{fibonacci}\PYG{o}{.}\PYG{n}{clear\PYGZus{}cache}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fibonacci}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  1:fibonacci(5)
  2:|fibonacci(4)
  3:||fibonacci(3)
  4:|||fibonacci(2)
  5:||||fibonacci(1)
  6:||||fibonacci(0)
  7:|||fibonacci(1)
read from cache
  8:||fibonacci(2)
read from cache
  9:|fibonacci(3)
read from cache
Done
  1:fibonacci(5)
read from cache
Done
  1:fibonacci(5)
  2:|fibonacci(4)
  3:||fibonacci(3)
  4:|||fibonacci(2)
  5:||||fibonacci(1)
  6:||||fibonacci(0)
  7:|||fibonacci(1)
read from cache
  8:||fibonacci(2)
read from cache
  9:|fibonacci(3)
read from cache
Done
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
5
\end{sphinxVerbatim}

A method \sphinxcode{\sphinxupquote{clear\_cache}} is added to the wrapper to clear the cache.\sphinxcode{\sphinxupquote{lambda <argument list> : <expression>}}is called a \sphinxhref{https://docs.python.org/3/reference/expressions.html\#lambda}{\sphinxstyleemphasis{lambda} expression}, which conveniently defines an \sphinxstyleemphasis{anonymous function}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{fibonacci}\PYG{o}{.}\PYG{n}{clear\PYGZus{}cache}\PYG{p}{)}\PYG{p}{,} \PYG{n}{fibonacci}\PYG{o}{.}\PYG{n}{clear\PYGZus{}cache}\PYG{o}{.}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(function, \PYGZsq{}\PYGZlt{}lambda\PYGZgt{}\PYGZsq{})
\end{sphinxVerbatim}


\section{Module}
\label{\detokenize{Lecture6/More on Functions:module}}
\sphinxstylestrong{How to create a module?}

To create a module, simply put the code in a python source file \sphinxcode{\sphinxupquote{<module name>.py}} in
\begin{itemize}
\item {} 
the current directory, or

\item {} 
a python \sphinxstyleemphasis{site\sphinxhyphen{}packages} directory in system path.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}/home/chungc/cs1302/CS1302ICP/Lecture6\PYGZsq{}, \PYGZsq{}/home/chungc/anaconda3/lib/python37.zip\PYGZsq{}, \PYGZsq{}/home/chungc/anaconda3/lib/python3.7\PYGZsq{}, \PYGZsq{}/home/chungc/anaconda3/lib/python3.7/lib\PYGZhy{}dynload\PYGZsq{}, \PYGZsq{}\PYGZsq{}, \PYGZsq{}/home/chungc/anaconda3/lib/python3.7/site\PYGZhy{}packages\PYGZsq{}, \PYGZsq{}/home/chungc/anaconda3/lib/python3.7/site\PYGZhy{}packages/IPython/extensions\PYGZsq{}, \PYGZsq{}/home/chungc/.ipython\PYGZsq{}]
\end{sphinxVerbatim}

For example, to create a module for generating Fibonacci numbers:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{more} fibonacci.py
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{fibonacci} \PYG{k}{as} \PYG{n+nn}{fib} \PYG{c+c1}{\PYGZsh{} as statement shortens name}
\PYG{n}{help}\PYG{p}{(}\PYG{n}{fib}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Help on module fibonacci:

NAME
    fibonacci \PYGZhy{} Contain functions for generating fibonacci numbers.

FUNCTIONS
    fibonacci(n)
        Returns the Fibonacci number of order n.
    
    fibonacci\PYGZus{}iteration(n)
        Returns the Fibonacci number of order n but without recursion.

FILE
    /home/chungc/cs1302/CS1302ICP/Lecture6/fibonacci.py
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fib}\PYG{o}{.}\PYG{n}{fibonacci}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fib}\PYG{o}{.}\PYG{n}{fibonacci\PYGZus{}iteration}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
5
5
\end{sphinxVerbatim}


\chapter{Lists and Tuples}
\label{\detokenize{Lecture7/Lists and Tuples:lists-and-tuples}}\label{\detokenize{Lecture7/Lists and Tuples::doc}}

\section{Motivation of composite data type}
\label{\detokenize{Lecture7/Lists and Tuples:motivation-of-composite-data-type}}
The following code calculates the average of five numbers:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{average\PYGZus{}five\PYGZus{}numbers}\PYG{p}{(}\PYG{n}{n1}\PYG{p}{,} \PYG{n}{n2}\PYG{p}{,} \PYG{n}{n3}\PYG{p}{,} \PYG{n}{n4}\PYG{p}{,} \PYG{n}{n5}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{n1} \PYG{o}{+} \PYG{n}{n2} \PYG{o}{+} \PYG{n}{n3} \PYG{o}{+} \PYG{n}{n4} \PYG{o}{+} \PYG{n}{n5}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{5}


\PYG{n}{average\PYGZus{}five\PYGZus{}numbers}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
3.0
\end{sphinxVerbatim}

What about using the above function to compute the average household income in Hong Kong.The labor size in Hong Kong in 2018 is close to 4 million.
\begin{itemize}
\item {} 
Should we create a variable to store the income of each individual?

\item {} 
Should we recursively apply the function to groups of five numbers?

\end{itemize}

What we need is
\begin{itemize}
\item {} 
a \sphinxstyleemphasis{composite data type} that can keep a variable numbers of items, so that

\item {} 
we can then define a function that takes an object of the \sphinxstyleemphasis{composite data type},

\item {} 
and returns the average of all items in the object.

\end{itemize}

\sphinxstylestrong{How to store a sequence of items in Python?}

\sphinxcode{\sphinxupquote{tuple}} and \sphinxcode{\sphinxupquote{list}} are two built\sphinxhyphen{}in classes for ordered collections of objects of possibly different types.

Indeed, we have already used tuples and lists before.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
a\PYGZus{}list = \PYGZsq{}1 2 3\PYGZsq{}.split()
a\PYGZus{}tuple = (lambda *args: args)(1,2,3)
a\PYGZus{}list[0] = 0
a\PYGZus{}tuple[0] = 0
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f5e4c877828\PYGZgt{}
\end{sphinxVerbatim}

\sphinxstylestrong{What is the difference between tuple and list?}
\begin{itemize}
\item {} 
List is \sphinxhref{https://docs.python.org/3/library/stdtypes.html\#index-21}{\sphinxstyleemphasis{mutable}} so programmers can change its items.

\item {} 
Tuple is \sphinxhref{https://docs.python.org/3/glossary.html\#term-immutable}{\sphinxstyleemphasis{immutable}} like \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{float}}, and \sphinxcode{\sphinxupquote{str}}, so
\begin{itemize}
\item {} 
programmers can be certain the content stay unchanged, and

\item {} 
Python can preallocate a fixed amount of memory to store its content.

\end{itemize}

\end{itemize}


\section{Constructing sequences}
\label{\detokenize{Lecture7/Lists and Tuples:constructing-sequences}}
\sphinxstylestrong{How to create tuple/list?}

Mathematicians often represent a set of items in two different ways:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxhref{https://en.wikipedia.org/wiki/Set\_(mathematics)\#Roster\_notation}{Roster notation}, which enumerates the elements in the sequence. E.g.,
\$\( \{0, 1, 4, 9, 16, 25, 36, 49, 64, 81\} \)\$

\item {} 
\sphinxhref{https://en.wikipedia.org/wiki/Set-builder\_notation}{Set\sphinxhyphen{}builder notation}, which describes the content using a rule for constructing the elements.
\$\( \{x^2| x\in \mathbb{N}, x< 10 \}, \)\$
namely the set of perfect squares less than 100.

\end{enumerate}

Python also provides two corresponding ways to create a tuple/list:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxhref{https://docs.python.org/3/reference/expressions.html?highlight=literals\#grammar-token-enclosure}{Enclosure}

\item {} 
\sphinxhref{https://docs.python.org/3/reference/expressions.html\#index-12}{Comprehension}

\end{enumerate}

\sphinxstylestrong{How to create a tuple/list by enumerating its items?}

To create a tuple, we enclose a comma separated sequence by parentheses:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 450
empty\PYGZus{}tuple = ()
singleton\PYGZus{}tuple = (0,)   \PYGZsh{} why not (0)?
heterogeneous\PYGZus{}tuple = (singleton\PYGZus{}tuple,
                       (1, 2.0),
                       print)
enclosed\PYGZus{}starred\PYGZus{}tuple = (*range(2),
                          *\PYGZsq{}23\PYGZsq{})
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f5e4c877ba8\PYGZgt{}
\end{sphinxVerbatim}

Note that:
\begin{itemize}
\item {} 
If the enclosed sequence has one term, there must be a comma after the term.

\item {} 
The elements of a tuple can have different types.

\item {} 
The unpacking operator \sphinxcode{\sphinxupquote{*}} can unpack an iterable into a sequence in an enclosure.

\end{itemize}

To create a list, we use square brackets to enclose a comma separated sequence of objects.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 450
empty\PYGZus{}list = []
singleton\PYGZus{}list = [0]  \PYGZsh{} no need to write [0,]
heterogeneous\PYGZus{}list = [singleton\PYGZus{}list, 
                      (1, 2.0), 
                      print]
enclosed\PYGZus{}starred\PYGZus{}list = [*range(2),
                         *\PYGZsq{}23\PYGZsq{}]
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f5e4c877588\PYGZgt{}
\end{sphinxVerbatim}

We can also create a tuple/list from other iterables using the constructors \sphinxcode{\sphinxupquote{tuple}}/\sphinxcode{\sphinxupquote{list}} as well as addition and multiplication similar to \sphinxcode{\sphinxupquote{str}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 950
str2list = list(\PYGZsq{}Hello\PYGZsq{})
str2tuple = tuple(\PYGZsq{}Hello\PYGZsq{})
range2list = list(range(5))
range2tuple = tuple(range(5))
tuple2list = list((1, 2, 3))
list2tuple = tuple([1, 2, 3])
concatenated\PYGZus{}tuple = (1,) + (2, 3)
concatenated\PYGZus{}list = [1, 2] + [3]
duplicated\PYGZus{}tuple = (1,) * 2
duplicated\PYGZus{}list = 2 * [1]
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f5e37fd8128\PYGZgt{}
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Explain the difference between following two expressions. Why a singleton tuple must have a comma after the item.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} 
      \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{sep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
6
(3, 3)
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{(1+2)*2}} evaluates to \sphinxcode{\sphinxupquote{6}} but \sphinxcode{\sphinxupquote{(1+2,)*2}} evaluates to \sphinxcode{\sphinxupquote{(3,3)}}.
\begin{itemize}
\item {} 
The parentheses in \sphinxcode{\sphinxupquote{(1+2)}} indicate the addition needs to be performed first, but

\item {} 
the parentheses in \sphinxcode{\sphinxupquote{(1+2,)}} creates a tuple.

\end{itemize}

Hence, singleton tuple must have a comma after the item to differentiate these two use cases.

\sphinxstylestrong{How to use a rule to construct a tuple/list?}

We can specify the rule using a \sphinxhref{https://docs.python.org/3/reference/expressions.html\#index-12}{comprehension},which we have used in a generator expression.E.g., the following is a python one\sphinxhyphen{}liner that returns a generator for prime numbers.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
all\PYG{o}{?}
\PYG{n}{prime\PYGZus{}sequence} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{stop}\PYG{p}{:} \PYG{p}{(}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{stop}\PYG{p}{)}
                               \PYG{k}{if} \PYG{n+nb}{all}\PYG{p}{(}\PYG{n}{x} \PYG{o}{\PYGZpc{}} \PYG{n}{divisor} \PYG{k}{for} \PYG{n}{divisor} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{o}{*}\PYG{n}{prime\PYGZus{}sequence}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
\end{sphinxVerbatim}

There are two comprehensions used:
\begin{itemize}
\item {} 
In \sphinxcode{\sphinxupquote{all(x \% divisor for divisor in range(2, x))}}, the comprehension creates a generator of remainders to the function \sphinxcode{\sphinxupquote{all}}, which returns true if all the remainders are \sphinxcode{\sphinxupquote{True}} in boolean expression.

\item {} 
In the return value \sphinxcode{\sphinxupquote{(x for x in range(2, stop) if ...)}} of the anonymous function, the comprehension creates a generator of numbers from 2 to \sphinxcode{\sphinxupquote{stop\sphinxhyphen{}1}} that satisfy the condition of the \sphinxcode{\sphinxupquote{if}} clause.

\end{itemize}

\sphinxstylestrong{Exercise} Use comprehension to define a function \sphinxcode{\sphinxupquote{composite\_sequence}} that takes a non\sphinxhyphen{}negative integer \sphinxcode{\sphinxupquote{stop}} and returns a generator of composite numbers strictly smaller than \sphinxcode{\sphinxupquote{stop}}. Use \sphinxcode{\sphinxupquote{any}} instead of \sphinxcode{\sphinxupquote{all}} to check if a number is composite.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
any\PYG{o}{?}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
\PYG{n}{composite\PYGZus{}sequence} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{stop}\PYG{p}{:} \PYG{p}{(}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{stop}\PYG{p}{)}
                               \PYG{k}{if} \PYG{n+nb}{any}\PYG{p}{(}\PYG{n}{x} \PYG{o}{\PYGZpc{}} \PYG{n}{divisor} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{k}{for} \PYG{n}{divisor} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{o}{*}\PYG{n}{composite\PYGZus{}sequence}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
4 6 8 9 10 12 14 15 16 18 20 21 22 24 25 26 27 28 30 32 33 34 35 36 38 39 40 42 44 45 46 48 49 50 51 52 54 55 56 57 58 60 62 63 64 65 66 68 69 70 72 74 75 76 77 78 80 81 82 84 85 86 87 88 90 91 92 93 94 95 96 98 99
\end{sphinxVerbatim}

We can construct a list instead of a generator using comprehension:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Use the list constructor}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}      \PYG{c+c1}{\PYGZsh{} Enclose comprehension by brackets}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
\end{sphinxVerbatim}

We can also use comprehension to construct a tuple:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{tuple}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Use the tuple constructor}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(0, 1, 4, 9, 16, 25, 36, 49, 64, 81)
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Explain the difference between the following expressions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
      \PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}generator object \PYGZlt{}genexpr\PYGZgt{} at 0x7f5e37ff4408\PYGZgt{}
(0, 1, 4, 9, 16, 25, 36, 49, 64, 81)
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
The first is a generator expression, not a tuple.

\item {} 
The second is a tuple constructed by enclosing the sequence from unpacking the generator.There must be a comma after the generator since there is only one enclosed term, even though that term generates multiple items.

\end{itemize}

\sphinxstylestrong{Exercise} Explain the difference between the following expressions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
      \PYG{p}{[}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{arg}\PYG{p}{:} \PYG{n}{arg}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{sep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[\PYGZlt{}generator object \PYGZlt{}genexpr\PYGZgt{} at 0x7f5e37ff44f8\PYGZgt{}]
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
In the second expression, the comprehension provided as an argument to a function becomes a generator object,which is returned by the anonymous function and enclosed to form the singleton list.

\item {} 
In the first expression, the comprehension is not converted to a generator.

\end{itemize}

With list comprehension, we can simulate a sequence of biased coin flips.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{random} \PYG{k}{as} \PYG{n}{rand}
\PYG{n}{p} \PYG{o}{=} \PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} unknown bias}
\PYG{n}{coin\PYGZus{}flips} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{if} \PYG{n}{rand}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{p} \PYG{k}{else} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Chance of head:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Coin flips:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{o}{*}\PYG{n}{coin\PYGZus{}flips}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Chance of head: 0.12076730849725259
Coin flips: T T T T H T T T T T T T T T T T T T H T T T H T T T T T T T T T T T T T T T T T T T T T T T T T T H T T T T T T T T T T T H H T T H T T T T T T T T T T T T T H T T T H T T T T T H T H T T T T T H H T T T T T T H T T T T T T T H T T H T H T T T T T T T T H T T T H T T T T T T T T T T T T H T T T T T T H H H T T T T T T T T T T T H T T T H T T T T T T T T T T T T T T H T T T T T T T T T T T T T T T T T T T T T T T T T H T T T T T T T T T H T T T H T T T H T H T T T T T T T T T T T T T T T T T T T H T T T T T T T T H T T T T H T T T H T T T T T T T T T T T H T T T T T T T T H T T T T T T T T T T T T T T T H T T T T T T H T T T T T T T T T T T T T H T T T T T T T H T T T T T T H T T T T T T H T T T T T T T T T T H T T T T T T T T T T H T T H T T T T H H T T T T T H T T T T T T T T T T T T T T T T H T T T H T T T T T T T T T T T T T T T T T T T T T T T T T T H T T T H H T T H T T T T T T T T T T T T T T T T T T H T T T H T T T T T T T T T T T T T T T T T T T T H T T T T H T T T H T T T T T T T T T T T T T T T T T T T T H T T T T T T T T T T T T T T H T T T T T T T T T T T T T T T T T T T T T T H T T T T T H T T T T T T T T T T H T T T T T T T T T T T T T T T T T T T H T T T T T T H T T T H T T T T T T T H T T T T T T H T T T T T T T H T T T T T T H T T T T T T T T T T H T T T T H T T T H T T T T H T T H H H H T T T T T T H T T T T T T H T T T T T T T T H T T T T T T T T T T T T T T T T H T T T T T T T T H T T T H T T T T T T H H T T T H T T T T H T T T T H T T T T T T T T T H T T T T T T T T H T T T 
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
T T T T T H T T T T T T T T T H H T T H T T T T T T T T T T T T T H T T T T T T T H T H T T T H T T T T T H T T T T T T T T T T H T T H T T T T T T T T T T T T T T T T T T T H T T T T H T H T T T T T T T T T H T T T H T T T T H T H T T T H T T H T T T T T T T T T T T T T T T T H T T T T T T T H T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T H T T T T H T T T T T T T T T T T H T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T H T T H T T T T T
\end{sphinxVerbatim}

We can then estimate the bias by the fraction of heads coming up.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{average}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{o}{/}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}

\PYG{n}{head\PYGZus{}indicators} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{k}{if} \PYG{n}{outcome} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{else} \PYG{l+m+mi}{0} \PYG{k}{for} \PYG{n}{outcome} \PYG{o+ow}{in} \PYG{n}{coin\PYGZus{}flips}\PYG{p}{]}
\PYG{n}{fraction\PYGZus{}of\PYGZus{}heads} \PYG{o}{=} \PYG{n}{average}\PYG{p}{(}\PYG{n}{head\PYGZus{}indicators}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fraction of heads:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fraction\PYGZus{}of\PYGZus{}heads}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Fraction of heads: 0.12
\end{sphinxVerbatim}

Note that \sphinxcode{\sphinxupquote{sum}} and \sphinxcode{\sphinxupquote{len}} returns the sum and length of the sequence.

\sphinxstylestrong{Exercise} Define a function \sphinxcode{\sphinxupquote{variance}} that takes in a sequence \sphinxcode{\sphinxupquote{seq}} and returns the \sphinxhref{https://en.wikipedia.org/wiki/Variance}{variance} of the sequence.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{variance}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{return} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{seq}\PYG{p}{)}\PYG{o}{/}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{average}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}

\PYG{n}{delta} \PYG{o}{=} \PYG{p}{(}\PYG{n}{variance}\PYG{p}{(}\PYG{n}{head\PYGZus{}indicators}\PYG{p}{)}\PYG{o}{/}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{head\PYGZus{}indicators}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{95}\PYG{l+s+si}{\PYGZpc{} c}\PYG{l+s+s1}{onfidence interval: [}\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s1}{,}\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s1}{]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{delta}\PYG{p}{,}\PYG{n}{p}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{delta}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
95\PYGZpc{} confidence interval: [0.10,0.14]
\end{sphinxVerbatim}


\section{Selecting items in a sequence}
\label{\detokenize{Lecture7/Lists and Tuples:selecting-items-in-a-sequence}}
\sphinxstylestrong{How to traverse a tuple/list?}

Instead of calling the dunder method directly, we can use a for loop to iterate over all the items in order.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{a}\PYG{p}{:} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{item}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 1 2 3 4 
\end{sphinxVerbatim}

To do it in reverse, we can use the \sphinxcode{\sphinxupquote{reversed}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
reversed\PYG{o}{?}
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{o}{*}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n+nb}{reversed}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{:} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{item}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
4 3 2 1 0 
\end{sphinxVerbatim}

We can also traverse multiple tuples/lists simultaneously by \sphinxcode{\sphinxupquote{zip}}ping them.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
zip\PYG{o}{?}
\PYG{n}{a} \PYG{o}{=} \PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n+nb}{reversed}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{item1}\PYG{p}{,} \PYG{n}{item2} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{item1}\PYG{p}{,}\PYG{n}{item2}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 4
1 3
2 2
3 1
4 0
\end{sphinxVerbatim}

\sphinxstylestrong{How to select an item in a sequence?}

Sequence objects such as \sphinxcode{\sphinxupquote{str}}/\sphinxcode{\sphinxupquote{tuple}}/\sphinxcode{\sphinxupquote{list}} implements the \sphinxhref{https://docs.python.org/3/reference/datamodel.html\#object.\_\_getitem\_\_}{\sphinxstyleemphasis{getter method} \sphinxcode{\sphinxupquote{\_\_getitem\_\_}}} to return their items.

We can select an item by \sphinxhref{https://docs.python.org/3/reference/expressions.html\#subscriptions}{subscription}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{a}} is a list and \sphinxcode{\sphinxupquote{i}} is an integer index.

A non\sphinxhyphen{}negative index indicates the distance from the beginning.
\begin{equation*}
\begin{split}\boldsymbol{a} = (a_0, ... , a_{n-1})\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Length:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{First element:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Second element:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Last element:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} IndexError}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
Length: 10
First element: 0
Second element: 1
Last element: 9
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{IndexError}\PYG{g+gWhitespace}{                                }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8793}\PYG{n}{aa5ed482}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{5} \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Second element:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{6} \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Last element:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{7} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} IndexError}

\PYG{n+ne}{IndexError}: tuple index out of range
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{a{[}i{]}}} with \sphinxcode{\sphinxupquote{i >= len(a)}} results in an \sphinxcode{\sphinxupquote{IndexError}}.

A negative index represents a negative offset from an imaginary element one past the end of the sequence.
\begin{equation*}
\begin{split}\begin{aligned} \boldsymbol{a} &= (a_0, ... , a_{n-1})\\
& = (a_{-n}, ..., a_{-1})
\end{aligned}\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{o}{*}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Last element:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Second last element:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{First element:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} IndexError}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Last element: 9
Second last element: 8
First element: 0
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{IndexError}\PYG{g+gWhitespace}{                                }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{21}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{n}{f6376dfba21}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{4} \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Second last element:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{5} \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{First element:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{6} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} IndexError}

\PYG{n+ne}{IndexError}: list index out of range
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{a{[}i{]}}} with \sphinxcode{\sphinxupquote{i < \sphinxhyphen{}len(a)}} results in an \sphinxcode{\sphinxupquote{IndexError}}.

\sphinxstylestrong{How to select multiple items?}

We can use a \sphinxhref{https://docs.python.org/3/reference/expressions.html\#slicings}{slicing} to select a range of items:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{p}{[}\PYG{n}{start}\PYG{p}{:}\PYG{n}{stop}\PYG{p}{]}
\PYG{n}{a}\PYG{p}{[}\PYG{n}{start}\PYG{p}{:}\PYG{n}{stop}\PYG{p}{:}\PYG{n}{step}\PYG{p}{]}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{a}} is a list;
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{start}} is an integer representing the index of the starting item in the selection;

\item {} 
\sphinxcode{\sphinxupquote{stop}} is an integer that is one larger than the index of the last item in the selection; and

\item {} 
\sphinxcode{\sphinxupquote{step}} is an integer that specifies the step/stride size through the list.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(1, 2, 3)
(1, 3)
\end{sphinxVerbatim}

The parameters take their default values if missing or equal to None.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{o}{*}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} start defaults to 0}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} stop defaults to len(a)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} step defaults to 1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[0, 1, 2, 3]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 2, 3]
\end{sphinxVerbatim}

They can take negative values.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}  
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[9]
[0, 1, 2, 3, 4, 5, 6, 7, 8]
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
\end{sphinxVerbatim}

They can also take a mixture of negative and postive values.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}      \PYG{c+c1}{\PYGZsh{} equal [a[\PYGZhy{}1], a[0]]?}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}      \PYG{c+c1}{\PYGZsh{} equal []?}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} equal [a[1], a[0]]?}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{:}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} result in IndexError like subscription?}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[]
[1, 2, 3, 4, 5, 6, 7, 8]
[]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{sphinxVerbatim}

We can now implement a practical sorting algorithm called \sphinxhref{https://en.wikipedia.org/wiki/Quicksort}{quicksort} to sort a sequence.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}


\PYG{k}{def} \PYG{n+nf}{quicksort}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Return a sorted list of items from seq.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}
    \PYG{n}{i} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{pivot}\PYG{p}{,} \PYG{n}{others} \PYG{o}{=} \PYG{n}{seq}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{*}\PYG{n}{seq}\PYG{p}{[}\PYG{p}{:}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{o}{*}\PYG{n}{seq}\PYG{p}{[}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{p}{]}
    \PYG{n}{left} \PYG{o}{=} \PYG{n}{quicksort}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{others} \PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZlt{}} \PYG{n}{pivot}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{right} \PYG{o}{=} \PYG{n}{quicksort}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{others} \PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{pivot}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{return} \PYG{p}{[}\PYG{o}{*}\PYG{n}{left}\PYG{p}{,} \PYG{n}{pivot}\PYG{p}{,} \PYG{o}{*}\PYG{n}{right}\PYG{p}{]}


\PYG{n}{seq} \PYG{o}{=} \PYG{p}{[}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{,} \PYG{n}{quicksort}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[79, 39, 32, 63, 22, 22, 73, 93, 58, 76]
[22, 22, 32, 39, 58, 63, 73, 76, 79, 93]
\end{sphinxVerbatim}

The above recursion creates a sorted list as \sphinxcode{\sphinxupquote{{[}*left, pivot, *right{]}}} where
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{pivot}} is a randomly picked an item in \sphinxcode{\sphinxupquote{seq}},

\item {} 
\sphinxcode{\sphinxupquote{left}} is the sorted list of items smaller than \sphinxcode{\sphinxupquote{pivot}}, and

\item {} 
\sphinxcode{\sphinxupquote{right}} is the sorted list of items no smaller than \sphinxcode{\sphinxupquote{pivot}}.

\end{itemize}

The base case happens when \sphinxcode{\sphinxupquote{seq}} contains at most one item, in which case \sphinxcode{\sphinxupquote{seq}} is already sorted.

There is a built\sphinxhyphen{}in function \sphinxcode{\sphinxupquote{sorted}} for sorting a sequence. It uses the \sphinxhref{https://en.wikipedia.org/wiki/Timsort}{Timsort} algorithm.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sorted\PYG{o}{?}
\PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[22, 22, 32, 39, 58, 63, 73, 76, 79, 93]
\end{sphinxVerbatim}


\section{Mutating a list}
\label{\detokenize{Lecture7/Lists and Tuples:mutating-a-list}}
For list (but not tuple), subscription and slicing can also be used as the target of an assignment operation to mutate the list.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
b = [*range(10)]  \PYGZsh{} aliasing
b[::2] = b[:5]
b[0:1] = b[:5]
b[::2] = b[:5]  \PYGZsh{} fails
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f5e37ff6748\PYGZgt{}
\end{sphinxVerbatim}

Last assignment fails because \sphinxcode{\sphinxupquote{{[}::2{]}}} with step size not equal to \sphinxcode{\sphinxupquote{1}} is an \sphinxstyleemphasis{extended slice}, which can only be assigned to a list of equal size.

\sphinxstylestrong{What is the difference between mutation and aliasing?}

In the previous code:
\begin{itemize}
\item {} 
The first assignment \sphinxcode{\sphinxupquote{b = {[}*range(10){]}}} is aliasing, which gives the list the target name/identifier \sphinxcode{\sphinxupquote{b}}.

\item {} 
Other assignments such as \sphinxcode{\sphinxupquote{b{[}::2{]} = b{[}:5{]}}} are mutations that \sphinxhref{https://docs.python.org/3/reference/simple\_stmts.html\#assignment-statements}{calls \sphinxcode{\sphinxupquote{\_\_setitem\_\_}}} because the target \sphinxcode{\sphinxupquote{b{[}::2{]}}} is not an identifier.

\end{itemize}

\sphinxstylestrong{Exercise} Explain the outcome of the following checks of equivalence?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 400
a = [10, 20, 30, 40]
b = a
print(\PYGZsq{}a is b? \PYGZob{}\PYGZcb{}\PYGZsq{}.format(a is b))
print(\PYGZsq{}\PYGZob{}\PYGZcb{} == \PYGZob{}\PYGZcb{}? \PYGZob{}\PYGZcb{}\PYGZsq{}.format(a, b, a == b))
b[1:3] = b[2:0:\PYGZhy{}1]
print(\PYGZsq{}\PYGZob{}\PYGZcb{} == \PYGZob{}\PYGZcb{}? \PYGZob{}\PYGZcb{}\PYGZsq{}.format(a, b, a == b))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f5e37ff6ac8\PYGZgt{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{a is b}} and \sphinxcode{\sphinxupquote{a == b}} returns \sphinxcode{\sphinxupquote{True}} because the assignment \sphinxcode{\sphinxupquote{b = a}} makes \sphinxcode{\sphinxupquote{b}} an alias of the same object \sphinxcode{\sphinxupquote{a}} points to.

\item {} 
In particular, the operation\sphinxcode{\sphinxupquote{b{[}1:3{]} = b{[}2:0:\sphinxhyphen{}1{]}}} affects the same list \sphinxcode{\sphinxupquote{a}} points to.

\end{itemize}

\sphinxstylestrong{Why mutate a list?}

The following is another implementation of \sphinxcode{\sphinxupquote{composite\_sequence}} that takes advantage of the mutability of list.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sieve\PYGZus{}composite\PYGZus{}sequence}\PYG{p}{(}\PYG{n}{stop}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{is\PYGZus{}composite} \PYG{o}{=} \PYG{p}{[}\PYG{k+kc}{False}\PYG{p}{]} \PYG{o}{*} \PYG{n}{stop}  \PYG{c+c1}{\PYGZsh{} initialization}
    \PYG{k}{for} \PYG{n}{factor} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{stop}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{is\PYGZus{}composite}\PYG{p}{[}\PYG{n}{factor}\PYG{p}{]}\PYG{p}{:} \PYG{k}{continue}
        \PYG{k}{for} \PYG{n}{multiple} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{factor}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{stop}\PYG{p}{,}\PYG{n}{factor}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{is\PYGZus{}composite}\PYG{p}{[}\PYG{n}{multiple}\PYG{p}{]} \PYG{o}{=} \PYG{k+kc}{True}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{stop}\PYG{p}{)} \PYG{k}{if} \PYG{n}{is\PYGZus{}composite}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{sieve\PYGZus{}composite\PYGZus{}sequence}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{:} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
4 6 8 9 10 12 14 15 16 18 20 21 22 24 25 26 27 28 30 32 33 34 35 36 38 39 40 42 44 45 46 48 49 50 51 52 54 55 56 57 58 60 62 63 64 65 66 68 69 70 72 74 75 76 77 78 80 81 82 84 85 86 87 88 90 91 92 93 94 95 96 98 99 
\end{sphinxVerbatim}

The algorithm
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
changes \sphinxcode{\sphinxupquote{is\_composite{[}x{]}}} from \sphinxcode{\sphinxupquote{False}} to \sphinxcode{\sphinxupquote{True}} if \sphinxcode{\sphinxupquote{x}} is a multiple of a smaller number \sphinxcode{\sphinxupquote{factor}}, and

\item {} 
returns a generator that generates composite numbers according to \sphinxcode{\sphinxupquote{is\_composite}}.

\end{enumerate}

\sphinxstylestrong{Exercise} Is \sphinxcode{\sphinxupquote{sieve\_composite\_sequence}} more efficient than your solution \sphinxcode{\sphinxupquote{composite\_sequence}}? Why?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{composite\PYGZus{}sequence}\PYG{p}{(}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{:} \PYG{k}{pass}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{sieve\PYGZus{}composite\PYGZus{}sequence}\PYG{p}{(}\PYG{l+m+mi}{1000000}\PYG{p}{)}\PYG{p}{:} \PYG{k}{pass}
\end{sphinxVerbatim}

The line \sphinxcode{\sphinxupquote{if is\_composite{[}factor{]}: continue}} avoids the redundant computations of checking composite factors.

\sphinxstylestrong{Exercise} Note that the multiplication operation \sphinxcode{\sphinxupquote{*}} is the most efficient way to \sphinxhref{https://www.geeksforgeeks.org/python-which-is-faster-to-initialize-lists/}{initialize a 1D list with a specified size}, but we should not use it to initialize a 2D list. Fix the following code so that \sphinxcode{\sphinxupquote{a}} becomes \sphinxcode{\sphinxupquote{{[}{[}1, 0{]}, {[}0, 1{]}{]}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 250
a = [[0] * 2] * 2
a[0][0] = a[1][1] = 1
print(a)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f5e37fe92b0\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[1, 0], [0, 1]]
\end{sphinxVerbatim}


\section{Different methods to operate on a sequence}
\label{\detokenize{Lecture7/Lists and Tuples:different-methods-to-operate-on-a-sequence}}
The following compares the lists of public attributes for \sphinxcode{\sphinxupquote{tuple}} and \sphinxcode{\sphinxupquote{list}}.
\begin{itemize}
\item {} 
We determine membership using the \sphinxhref{https://docs.python.org/3/reference/expressions.html\#membership-test-operations}{operator \sphinxcode{\sphinxupquote{in}} or \sphinxcode{\sphinxupquote{not in}}}.

\item {} 
Different from the \sphinxhref{https://docs.python.org/3/reference/compound\_stmts.html\#the-for-statement}{keyword \sphinxcode{\sphinxupquote{in}} in a for loop}, operator \sphinxcode{\sphinxupquote{in}} calls the method \sphinxcode{\sphinxupquote{\_\_contains\_\_}}.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{list\PYGZus{}attributes} \PYG{o}{=} \PYG{n+nb}{dir}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{)}
\PYG{n}{tuple\PYGZus{}attributes} \PYG{o}{=} \PYG{n+nb}{dir}\PYG{p}{(}\PYG{n+nb}{tuple}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Common attributes:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{p}{[}
        \PYG{n}{attr} \PYG{k}{for} \PYG{n}{attr} \PYG{o+ow}{in} \PYG{n}{list\PYGZus{}attributes}
        \PYG{k}{if} \PYG{n}{attr} \PYG{o+ow}{in} \PYG{n}{tuple\PYGZus{}attributes} \PYG{o+ow}{and} \PYG{n}{attr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{!=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tuple\PYGZhy{}specific attributes:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{p}{[}
        \PYG{n}{attr} \PYG{k}{for} \PYG{n}{attr} \PYG{o+ow}{in} \PYG{n}{tuple\PYGZus{}attributes}
        \PYG{k}{if} \PYG{n}{attr} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{list\PYGZus{}attributes} \PYG{o+ow}{and} \PYG{n}{attr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{!=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{List\PYGZhy{}specific attributes:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{p}{[}
        \PYG{n}{attr} \PYG{k}{for} \PYG{n}{attr} \PYG{o+ow}{in} \PYG{n}{list\PYGZus{}attributes}
        \PYG{k}{if} \PYG{n}{attr} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{tuple\PYGZus{}attributes} \PYG{o+ow}{and} \PYG{n}{attr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{!=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Common attributes: count, index
Tuple\PYGZhy{}specific attributes: 
List\PYGZhy{}specific attributes: append, clear, copy, extend, insert, pop, remove, reverse, sort
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
There are no public tuple\sphinxhyphen{}specific attributes, and

\item {} 
all the list\sphinxhyphen{}specific attributes are methods that mutate the list, except \sphinxcode{\sphinxupquote{copy}}.

\end{itemize}

The common attributes
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{count}} method returns the number of occurrences of a value in a tuple/list, and

\item {} 
\sphinxcode{\sphinxupquote{index}} method returns the index of the first occurrence of a value in a tuple/list.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
a = (1,2,2,4,5)
print(a.index(2))
print(a.count(2))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f5e37ff6f28\PYGZgt{}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{reverse}} method reverses the list instead of returning a reversed list.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
a = [*range(10)]
print(reversed(a))
print(*reversed(a))
print(a.reverse())
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f5e37ff6a20\PYGZgt{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{copy}} method returns a copy of a list.

\item {} 
\sphinxcode{\sphinxupquote{tuple}} does not have the \sphinxcode{\sphinxupquote{copy}} method but it is easy to create a copy by slicing.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 400
a = [*range(10)]
b = tuple(a)
a\PYGZus{}reversed = a.copy()
a\PYGZus{}reversed.reverse()
b\PYGZus{}reversed = b[::\PYGZhy{}1]
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f5e37ff6e48\PYGZgt{}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{sort}} method sorts the list \sphinxstyleemphasis{in place} instead of returning a sorted list.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
import random
a = [random.randint(0,10) for i in range(10)]
print(sorted(a))
print(a.sort())
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f5e37fe90f0\PYGZgt{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{extend}} method that extends a list instead of creating a new concatenated list.

\item {} 
\sphinxcode{\sphinxupquote{append}} method adds an object to the end of a list.

\item {} 
\sphinxcode{\sphinxupquote{insert}} method insert an object to a specified location.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
a = b = [*range(5)]
print(a + b)
print(a.extend(b))
print(a.append(\PYGZsq{}stop\PYGZsq{}))
print(a.insert(0,\PYGZsq{}start\PYGZsq{}))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f5e37fe9160\PYGZgt{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{pop}} method deletes and return the last item of the list.

\item {} 
\sphinxcode{\sphinxupquote{remove}} method removes the first occurrence of a value in the list.

\item {} 
\sphinxcode{\sphinxupquote{clear}} method clears the entire list.

\end{itemize}

We can also use the function \sphinxcode{\sphinxupquote{del}} to delete a selection of a list.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
a = [*range(10)]
del a[::2]
print(a.pop())
print(a.remove(5))
print(a.clear())
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7f5e37fe9940\PYGZgt{}
\end{sphinxVerbatim}


\chapter{Dictionaries and Sets}
\label{\detokenize{Lecture8/Dictionaries and Sets:dictionaries-and-sets}}\label{\detokenize{Lecture8/Dictionaries and Sets::doc}}

\section{Motivation for associative container}
\label{\detokenize{Lecture8/Dictionaries and Sets:motivation-for-associative-container}}
The following code simulates the outcomes from rolling a dice multiple times.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}

\PYG{n}{dice\PYGZus{}rolls} \PYG{o}{=} \PYG{p}{[}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{o}{*}\PYG{n}{dice\PYGZus{}rolls}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
4 5 3 4 6 5 6 2 3 5
\end{sphinxVerbatim}

\sphinxstylestrong{What is the distribution, i.e., fractional counts?}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{distribution} \PYG{o}{=} \PYG{p}{[}\PYG{n}{dice\PYGZus{}rolls}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{o}{/} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{dice\PYGZus{}rolls}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{]}

\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{stem}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{,} \PYG{n}{distribution}\PYG{p}{,} \PYG{n}{use\PYGZus{}line\PYGZus{}collection}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Outcomes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Distribution}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(0.0, 1.0)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Dictionaries and Sets_7_1}.png}

In the above code, \sphinxcode{\sphinxupquote{distribution{[}i{]}}} stores the fractional count of outcome \sphinxcode{\sphinxupquote{i}}.

However, \sphinxcode{\sphinxupquote{distribution{[}0{]}}} is \sphinxcode{\sphinxupquote{0}} because a dice does not have outcome \sphinxcode{\sphinxupquote{0}}. Can we avoid such redundancy?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{distinct\PYGZus{}outcomes} \PYG{o}{=} \PYG{p}{[}
    \PYG{n}{outcome} \PYG{k}{for} \PYG{n}{outcome} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)} \PYG{k}{if} \PYG{n}{dice\PYGZus{}rolls}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{n}{outcome}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}
\PYG{p}{]}
\PYG{n}{distribution} \PYG{o}{=} \PYG{p}{[}
    \PYG{n}{dice\PYGZus{}rolls}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{n}{distinct\PYGZus{}outcomes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{dice\PYGZus{}rolls}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{distinct\PYGZus{}outcomes}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{]}

\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{stem}\PYG{p}{(}\PYG{n}{distinct\PYGZus{}outcomes}\PYG{p}{,} \PYG{n}{distribution}\PYG{p}{,} \PYG{n}{use\PYGZus{}line\PYGZus{}collection}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Outcomes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Distribution}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(0.0, 1.0)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Dictionaries and Sets_10_1}.png}

In the above code,
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{distinct\_outcomes}} stores the list of distinct outcomes, and

\item {} 
\sphinxcode{\sphinxupquote{distribution{[}distinct\_outcomes{[}i{]}{]}}} stores the fractional count of the \sphinxcode{\sphinxupquote{i}}\sphinxhyphen{}th distinct outcome.

\end{itemize}

What about finding the distribution of characters in an article?There are 1,112,064 unicode characters.
\begin{itemize}
\item {} 
How obtain the distribution efficiently without creating an entry for each unicode character?

\item {} 
How to compute the set of distinct characters efficiently without iterating over the set of all unicode characters?

\item {} 
Can we index \sphinxcode{\sphinxupquote{distribution}} directly by the set of distinct characters?

\end{itemize}

What we need is a composite data type that
\begin{itemize}
\item {} 
can keep a set of \sphinxstyleemphasis{unique keys of different types} (such as the characters in our example), and

\item {} 
associate to different keys possibly different \sphinxstyleemphasis{values of any types} such as (the fractional counts of the characters).

\end{itemize}

Such data structure is called an \sphinxhref{https://en.wikipedia.org/wiki/Associative\_containers}{associative container}.

\sphinxstylestrong{How to use associative containers in Python?}

There are two built\sphinxhyphen{}in classes for associative containers:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{set}} can store a set of unique keys of possibly different types.

\item {} 
\sphinxcode{\sphinxupquote{dict}}ionary can store a set of key\sphinxhyphen{}value pairs.

\end{itemize}

We have already used sets and dictionaries before.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 400
a = (lambda **kwargs: kwargs)(start=0, stop=5, step=1)
b = set([1,1,2,3,3,3])
assert len(a) == len(b)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fa62d8f6c88\PYGZgt{}
\end{sphinxVerbatim}

Both \sphinxcode{\sphinxupquote{set}} and \sphinxcode{\sphinxupquote{dict}}
\begin{itemize}
\item {} 
implement \sphinxcode{\sphinxupquote{len}} method that returns the number of keys, and

\item {} 
are mutable, so we can mutate their keys and values.

\end{itemize}


\section{Constructing associative containers}
\label{\detokenize{Lecture8/Dictionaries and Sets:constructing-associative-containers}}
\sphinxstylestrong{How to create set/dictionary?}

Similar to tuple/list, we can use enclosure, constructors, and comprehension.

\sphinxstylestrong{How to create a set/dict by enumerating its keys/values?}

For \sphinxcode{\sphinxupquote{dict}}, enclose a comma\sphinxhyphen{}separated sequence of \sphinxcode{\sphinxupquote{key : value}} pairs by braces \sphinxcode{\sphinxupquote{\{}} and \sphinxcode{\sphinxupquote{\}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 350
empty\PYGZus{}dictionary = \PYGZob{}\PYGZcb{}
a = \PYGZob{}\PYGZsq{}a\PYGZsq{}: 0, \PYGZsq{}b\PYGZsq{}: 1\PYGZcb{}
b = \PYGZob{}**a, \PYGZsq{}c\PYGZsq{}: 0, \PYGZsq{}d\PYGZsq{}: 1\PYGZcb{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fa62d8aeba8\PYGZgt{}
\end{sphinxVerbatim}

For \sphinxcode{\sphinxupquote{set}}, omit \sphinxcode{\sphinxupquote{: value}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
a = \PYGZob{}(1, 2.0), print, *range(2), *\PYGZsq{}23\PYGZsq{}\PYGZcb{}
empty\PYGZus{}set = \PYGZob{}*()\PYGZcb{}  \PYGZsh{} Why not use \PYGZob{}\PYGZcb{}?
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fa62d8aee48\PYGZgt{}
\end{sphinxVerbatim}

We can also create a set/dictionary from other objects using their constructors \sphinxcode{\sphinxupquote{set}}/\sphinxcode{\sphinxupquote{dict}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 550
empty\PYGZus{}set = set()
string2set = set(\PYGZsq{}abc\PYGZsq{})
range2set = set(range(2))
list2set = set([\PYGZsq{}abc\PYGZsq{},range(2)])
set2set = set(list2set)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fa62d8b20f0\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 650
empty\PYGZus{}dict = dict()
enumerate2dict = dict(enumerate(\PYGZsq{}abc\PYGZsq{}))
zip2dict = dict(zip(\PYGZsq{}abc\PYGZsq{},\PYGZsq{}123\PYGZsq{}))
kwargs2dict = dict(one=1,two=2)
dict2dict = dict(kwargs2dict)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fa62d8b22e8\PYGZgt{}
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} \sphinxcode{\sphinxupquote{dict}} also has a \sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict.fromkeys}{\sphinxstyleemphasis{class method} \sphinxcode{\sphinxupquote{fromkeys}}} to construct a dictionary with keys from iterable pointing to a default value. Create a dictionary using \sphinxcode{\sphinxupquote{fromkeys}} with keys being the non\sphinxhyphen{}negative integers smaller than \sphinxcode{\sphinxupquote{100}} and values being \sphinxcode{\sphinxupquote{0}}.

\sphinxstyleemphasis{Hint:} Use \sphinxcode{\sphinxupquote{dict.fromkeys}} since a class method is bound to the class rather than an object of the class.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
dict.fromkeys\PYG{o}{?}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
\PYG{n}{fromkeys\PYGZus{}dict} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{o}{.}\PYG{n}{fromkeys}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}

\PYG{c+c1}{\PYGZsh{} test}
\PYG{k}{assert} \PYG{n+nb}{all}\PYG{p}{(}\PYG{n}{fromkeys\PYGZus{}dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{fromkeys\PYGZus{}dict}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{How to use a rule to construct a set/dictionary?}

The following function uses a one\sphinxhyphen{}line dictionary comprehension to return the distribution of items in a sequence:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{distribute}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{\PYGZob{}}\PYG{n}{k} \PYG{p}{:} \PYG{n}{seq}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{o}{/}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)} \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{set}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{dist} \PYG{o}{=} \PYG{n}{distribute}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{stem}\PYG{p}{(}\PYG{n}{dist}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}   \PYG{c+c1}{\PYGZsh{} set\PYGZhy{}like view of the keys}
             \PYG{n}{dist}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} view of the values}
             \PYG{n}{use\PYGZus{}line\PYGZus{}collection}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Items}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Distribution}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
    
\PYG{n}{plot\PYGZus{}distribution}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{What is the distribution of different characters?}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Dictionaries and Sets_35_0}.png}
\begin{itemize}
\item {} 
The object methods \sphinxcode{\sphinxupquote{keys}} and \sphinxcode{\sphinxupquote{values}} provide a dynamic \sphinxhref{https://docs.python.org/3/glossary.html\#term-dictionary-view}{view} of the keys.

\item {} 
Unlike a copy, subsequent changes to the dictionary are also reflected in a previously returned view.

\item {} 
\sphinxcode{\sphinxupquote{items}} provides a set\sphinxhyphen{}like view of the key\sphinxhyphen{}value pairs.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 500
a = dict(enumerate(\PYGZsq{}abc\PYGZsq{}))
views = a.keys(), a.values(), a.items()
a.pop(1)    \PYGZsh{} remove the key 1 and its associated value
a.popitem() \PYGZsh{} remove and return a key\PYGZhy{}value pair
a.clear()   \PYGZsh{} clear the dictionary
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fa62d839198\PYGZgt{}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{set}} has \sphinxcode{\sphinxupquote{pop}} and \sphinxcode{\sphinxupquote{clear}} but not \sphinxcode{\sphinxupquote{popitem}}. However, \sphinxcode{\sphinxupquote{set.pop}} behaves like \sphinxcode{\sphinxupquote{dict.popitem}} instead of \sphinxcode{\sphinxupquote{dict.pop}}. (Why?)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 250
a = set(\PYGZsq{}abc\PYGZsq{})
a.pop()     \PYGZsh{} remove and return an element
a.clear()   \PYGZsh{} clear the set
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fa62d7f0438\PYGZgt{}
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Use one\sphinxhyphen{}line comprehension to return a set of composite numbers smaller than \sphinxcode{\sphinxupquote{stop}}.

\sphinxstyleemphasis{Hint:} You do not need to worry about duplicate elements for \sphinxcode{\sphinxupquote{set}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{composite\PYGZus{}set}\PYG{p}{(}\PYG{n}{stop}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{return} \PYG{p}{\PYGZob{}}\PYG{n}{x} \PYG{k}{for} \PYG{n}{factor} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{stop}\PYG{p}{)} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{factor}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{stop}\PYG{p}{,}\PYG{n}{factor}\PYG{p}{)}\PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
    
\PYG{n+nb}{print}\PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{composite\PYGZus{}set}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
4 6 8 9 10 12 14 15 16 18 20 21 22 24 25 26 27 28 30 32 33 34 35 36 38 39 40 42 44 45 46 48 49 50 51 52 54 55 56 57 58 60 62 63 64 65 66 68 69 70 72 74 75 76 77 78 80 81 82 84 85 86 87 88 90 91 92 93 94 95 96 98 99
\end{sphinxVerbatim}


\section{Hashability}
\label{\detokenize{Lecture8/Dictionaries and Sets:hashability}}
For \sphinxcode{\sphinxupquote{set}} and \sphinxcode{\sphinxupquote{dict}},
\begin{itemize}
\item {} 
identical keys are merged to the same entry even though

\item {} 
values associated with different keys can be the same.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 350
a = \PYGZob{}0: \PYGZsq{}a\PYGZsq{}, 0.0: \PYGZsq{}b\PYGZsq{}, 2: \PYGZsq{}b\PYGZsq{}\PYGZcb{}
b = \PYGZob{}0j, 0, 0.0, \PYGZsq{}\PYGZsq{}, False\PYGZcb{}
assert 0 == 0.0 == 0j == False != \PYGZsq{}\PYGZsq{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fa62d7f07b8\PYGZgt{}
\end{sphinxVerbatim}

This is implemented efficiently by \sphinxhref{https://docs.python.org/3/glossary.html\#term-hashable}{\sphinxstyleemphasis{hashing}}. A key must be a hashable object which:
\begin{itemize}
\item {} 
has a hash value (returned by \sphinxcode{\sphinxupquote{\_\_hash\_\_}} method) that never changes during its lifetime, and

\item {} 
can be compared (using \sphinxcode{\sphinxupquote{\_\_eq\_\_}} method) to other objects.\sphinxstyleemphasis{Hashable objects which compare equal must have the same hash value.}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{collections}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{k+kc}{False}\PYG{p}{,} \PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{frozenset}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{collections}\PYG{o}{.}\PYG{n}{abc}\PYG{o}{.}\PYG{n}{Hashable}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{ is hashable. E.g., hash(}\PYG{l+s+si}{\PYGZob{}!r\PYGZcb{}}\PYG{l+s+s1}{) == }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{n+nb}{hash}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{ is NOT hashable.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}class \PYGZsq{}int\PYGZsq{}\PYGZgt{} is hashable. E.g., hash(0) == 0
\PYGZlt{}class \PYGZsq{}float\PYGZsq{}\PYGZgt{} is hashable. E.g., hash(0.0) == 0
\PYGZlt{}class \PYGZsq{}complex\PYGZsq{}\PYGZgt{} is hashable. E.g., hash(0j) == 0
\PYGZlt{}class \PYGZsq{}str\PYGZsq{}\PYGZgt{} is hashable. E.g., hash(\PYGZsq{}\PYGZsq{}) == 0
\PYGZlt{}class \PYGZsq{}bool\PYGZsq{}\PYGZgt{} is hashable. E.g., hash(False) == 0
\PYGZlt{}class \PYGZsq{}tuple\PYGZsq{}\PYGZgt{} is hashable. E.g., hash(()) == 3527539
\PYGZlt{}class \PYGZsq{}list\PYGZsq{}\PYGZgt{} is NOT hashable.
\PYGZlt{}class \PYGZsq{}dict\PYGZsq{}\PYGZgt{} is NOT hashable.
\PYGZlt{}class \PYGZsq{}set\PYGZsq{}\PYGZgt{} is NOT hashable.
\PYGZlt{}class \PYGZsq{}frozenset\PYGZsq{}\PYGZgt{} is hashable. E.g., hash(frozenset()) == 133146708735736
\end{sphinxVerbatim}

\sphinxstylestrong{Why the key should be hashable?}\sphinxstylestrong{What is the use of a hash value?}

Associative containers are implemented as \sphinxstyleemphasis{hash tables} for efficient lookup of key values.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}html}
\PYG{p}{\PYGZlt{}}\PYG{n+nt}{iframe} \PYG{n+na}{width}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}912\PYGZdq{}} \PYG{n+na}{height}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}513\PYGZdq{}} \PYG{n+na}{src}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}https://www.youtube.com/embed/LPzN8jgbnvA\PYGZdq{}} \PYG{n+na}{frameborder}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}0\PYGZdq{}} \PYG{n+na}{allow}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}accelerometer; autoplay; clipboard\PYGZhy{}write; encrypted\PYGZhy{}media; gyroscope; picture\PYGZhy{}in\PYGZhy{}picture\PYGZdq{}} \PYG{n+na}{allowfullscreen}\PYG{p}{\PYGZgt{}}\PYG{p}{\PYGZlt{}}\PYG{p}{/}\PYG{n+nt}{iframe}\PYG{p}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

Most mutable objects are not hashable. Why?Mutating a key makes it a different key, which is \sphinxhref{https://hynek.me/articles/hashes-and-equality/}{hard to track}.

\sphinxcode{\sphinxupquote{set}} has an immutable counterpart called \sphinxcode{\sphinxupquote{frozenset}}, but \sphinxcode{\sphinxupquote{dict}} does not have any immutable counterpart. Why?While elements of a set must be hashable and therefore mostly immutable, dictionary values may be of mutable types.

Python also uses dictionary for its global/local frames.Indeed, \sphinxhref{https://stackoverflow.com/questions/8271139/why-is-early-return-slower-than-else}{hash collisions can slow down the lookup process}.

\sphinxstylestrong{Exercise} Why equal objects must have the same hash but different objects may have the same hash? An example is given below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert} \PYG{n+nb}{hash}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb}{hash}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb}{hash}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb}{hash}\PYG{p}{(}\PYG{k+kc}{False}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb}{hash}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o+ow}{and} \PYG{k+kc}{False} \PYG{o}{!=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
To avoid duplicate keys occupying different entries in a hash table.

\item {} 
Hash collision can be detected by \sphinxcode{\sphinxupquote{==}} and handled by \sphinxhref{https://en.wikipedia.org/wiki/Hash\_table\#Collision\_resolution}{collision resolution} techniques. To keep the hash table small, hash collision is unavoidable.

\end{enumerate}


\section{Accessing keys/values}
\label{\detokenize{Lecture8/Dictionaries and Sets:accessing-keys-values}}
\sphinxstylestrong{How to traverse a set/dictionary?}

Set and dictionaries are iterable.The for loop iterates over the keys.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abcde}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abcde}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{n}{element} \PYG{k}{for} \PYG{n}{element} \PYG{o+ow}{in} \PYG{n}{a}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,}\PYG{n}{b}\PYG{p}{[}\PYG{n}{key}\PYG{p}{]}\PYG{p}{)} \PYG{k}{for} \PYG{n}{key} \PYG{o+ow}{in} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} TypeError}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
b c a e d
(0, \PYGZsq{}a\PYGZsq{}) (1, \PYGZsq{}b\PYGZsq{}) (2, \PYGZsq{}c\PYGZsq{}) (3, \PYGZsq{}d\PYGZsq{}) (4, \PYGZsq{}e\PYGZsq{})
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6702302}\PYG{n}{c4a5e}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{3} \PYG{n+nb}{print}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{n}{element} \PYG{k}{for} \PYG{n}{element} \PYG{o+ow}{in} \PYG{n}{a}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{4} \PYG{n+nb}{print}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,}\PYG{n}{b}\PYG{p}{[}\PYG{n}{key}\PYG{p}{]}\PYG{p}{)} \PYG{k}{for} \PYG{n}{key} \PYG{o+ow}{in} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{5} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} TypeError}

\PYG{n+ne}{TypeError}: \PYGZsq{}set\PYGZsq{} object is not subscriptable
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
For the dictionary \sphinxcode{\sphinxupquote{b}}, we used subscription \sphinxcode{\sphinxupquote{b{[}key{]}}} to access the value associated with \sphinxcode{\sphinxupquote{key}}.

\item {} 
Unlike dictionary, set does not implement \sphinxhref{https://docs.python.org/3/reference/datamodel.html\#object.\_\_getitem\_\_}{\sphinxcode{\sphinxupquote{\_\_getitem\_\_}}} and is therefore not subscriptable.

\end{itemize}

Unlike tuple/list, \sphinxcode{\sphinxupquote{b{[}\sphinxhyphen{}1{]}}} does not refer to the value of the last entry. (Dictionary is not ordered.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} KeyError}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{KeyError}\PYG{g+gWhitespace}{                                  }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{21}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{784624678}\PYG{n}{be8}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n}{b}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} KeyError}

\PYG{n+ne}{KeyError}: \PYGZhy{}1
\end{sphinxVerbatim}

The above raises a key error because \sphinxcode{\sphinxupquote{\sphinxhyphen{}1}} is not a key in the dictionary \sphinxcode{\sphinxupquote{b}}.

Dictionary implements the \sphinxhref{https://docs.python.org/3/reference/simple\_stmts.html\#assignment-statements}{\sphinxcode{\sphinxupquote{\_\_setitem\_\_}}} method so we can enter a key value pair to a dictionary using the assignment operator.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{f}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{b}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}f\PYGZsq{}
\end{sphinxVerbatim}

To delete a key, we can use the function \sphinxcode{\sphinxupquote{del}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{del} \PYG{n}{b}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{b}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{KeyError}\PYG{g+gWhitespace}{                                  }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23}\PYG{o}{\PYGZhy{}}\PYG{n}{a57f788767eb}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{k}{del} \PYG{n}{b}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{2} \PYG{n}{b}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{n+ne}{KeyError}: \PYGZhy{}1
\end{sphinxVerbatim}

To avoid key error, we can check if a key is in a dictionary efficiently (due to hashing) using the \sphinxcode{\sphinxupquote{in}} operator.The following is a different implementation of \sphinxcode{\sphinxupquote{distribute}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{distribute}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{dist} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{seq}\PYG{p}{:} 
        \PYG{n}{dist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{dist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{if} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{dist} \PYG{k}{else} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{dist}

\PYG{n}{plot\PYGZus{}distribution}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{What is the distribution of different characters?}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Dictionaries and Sets_69_0}.png}

\sphinxstylestrong{Exercise} Unlike the previous implementation using one\sphinxhyphen{}line dictionary comprehension, the above alternative implementation uses multiple lines of code to build the dictionary incrementally starting from an empty dictionary.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{distribute}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{\PYGZob{}}\PYG{n}{k} \PYG{p}{:} \PYG{n}{seq}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{o}{/}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)} \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{set}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Explain whether the alternative is more efficient.

It is more efficient because
\begin{itemize}
\item {} 
the alternative implementation traverses \sphinxcode{\sphinxupquote{seq}} once with near constant time lookup of the key, but

\item {} 
the list comprehension can traverse \sphinxcode{\sphinxupquote{seq}} a multiple times linear in \sphinxcode{\sphinxupquote{len(seq)}}, since every call to \sphinxcode{\sphinxupquote{seq.count}} has to traverse \sphinxcode{\sphinxupquote{seq}} once.

\end{itemize}

Shorter code needs not be more efficient.

\sphinxstylestrong{Exercise} \sphinxcode{\sphinxupquote{dict}} also has a getter method \sphinxcode{\sphinxupquote{get}} that conveniently returns a default value if the key does not exist. Rewrite the alternative implementation of \sphinxcode{\sphinxupquote{distribute}} to use \sphinxcode{\sphinxupquote{get}} instead of \sphinxcode{\sphinxupquote{in}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
dict.get\PYG{o}{?}
\PYG{k}{def} \PYG{n+nf}{distribute}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{dist} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{seq}\PYG{p}{:} 
        \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
        \PYG{n}{dist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{dist}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
    \PYG{k}{return} \PYG{n}{dist}

\PYG{n}{plot\PYGZus{}distribution}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{What is the distribution of different characters?}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Dictionaries and Sets_73_0}.png}

\sphinxstylestrong{How to traverse in ascending order of the keys?}

We can apply the function \sphinxcode{\sphinxupquote{sorted}} to a set/dictionary to return a sorted list of the keys.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 600
a = set(reversed(\PYGZsq{}abcde\PYGZsq{}))
b = dict(reversed([*enumerate(\PYGZsq{}abcde\PYGZsq{})]))
sorted\PYGZus{}elements = sorted(a)
sorted\PYGZus{}keys = sorted(b)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fa62d7eb7f0\PYGZgt{}
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Re\sphinxhyphen{}implement \sphinxcode{\sphinxupquote{plot\_distribution}} to plot the distribution in ascending order of the keys.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{dist} \PYG{o}{=} \PYG{n}{distribute}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} pyplot.stem(dist.keys(), dist.values(), use\PYGZus{}line\PYGZus{}collection=True)}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{n}{dist\PYGZus{}list} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{dist}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{key} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{p}\PYG{p}{:} \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{pyplot}\PYG{o}{.}\PYG{n}{stem}\PYG{p}{(}\PYG{p}{[}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{dist\PYGZus{}list}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{dist\PYGZus{}list}\PYG{p}{]}\PYG{p}{,} \PYG{n}{use\PYGZus{}line\PYGZus{}collection}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
    \PYG{n}{pyplot}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Items}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{pyplot}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Distribution}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{pyplot}\PYG{o}{.}\PYG{n}{ylim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
    
\PYG{n}{plot\PYGZus{}distribution}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{What is the distribution of different characters?}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{NameError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{27}\PYG{o}{\PYGZhy{}}\PYG{n}{aa27f8ab3ded}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{10}     \PYG{n}{pyplot}\PYG{o}{.}\PYG{n}{ylim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{11} 
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{12} \PYG{n}{plot\PYGZus{}distribution}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{What is the distribution of different characters?}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n+nn}{\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}27\PYGZhy{}aa27f8ab3ded\PYGZgt{}} in \PYG{n+ni}{plot\PYGZus{}distribution}\PYG{n+nt}{(seq)}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{4}     \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{5}     \PYG{n}{dist\PYGZus{}list} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{dist}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{key} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{p}\PYG{p}{:} \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{6}     \PYG{n}{pyplot}\PYG{o}{.}\PYG{n}{stem}\PYG{p}{(}\PYG{p}{[}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{dist\PYGZus{}list}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{dist\PYGZus{}list}\PYG{p}{]}\PYG{p}{,} \PYG{n}{use\PYGZus{}line\PYGZus{}collection}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{7}     \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{8}     \PYG{n}{pyplot}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Items}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n+ne}{NameError}: name \PYGZsq{}pyplot\PYGZsq{} is not defined
\end{sphinxVerbatim}

\sphinxstylestrong{How to add an element to a set and remove an element from it?}

Instead of subscription, \sphinxcode{\sphinxupquote{set}} has the \sphinxcode{\sphinxupquote{add}}/\sphinxcode{\sphinxupquote{discard}}/\sphinxcode{\sphinxupquote{remove}} methods for adding/removing elements.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 400
a = set(\PYGZsq{}abc\PYGZsq{})
a.add(\PYGZsq{}d\PYGZsq{})      
a.discard(\PYGZsq{}a\PYGZsq{})  
a.remove(\PYGZsq{}b\PYGZsq{})
a.clear()
a.discard(\PYGZsq{}a\PYGZsq{})  \PYGZsh{} no error
a.remove(\PYGZsq{}b\PYGZsq{})   \PYGZsh{} KeyError
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fa62d7eb5c0\PYGZgt{}
\end{sphinxVerbatim}


\section{Other operators and methods}
\label{\detokenize{Lecture8/Dictionaries and Sets:other-operators-and-methods}}
Unlike \sphinxcode{\sphinxupquote{str}}/\sphinxcode{\sphinxupquote{tuple}}/\sphinxcode{\sphinxupquote{list}}, \sphinxcode{\sphinxupquote{set}} and \sphinxcode{\sphinxupquote{dict}} do not implement addition \sphinxcode{\sphinxupquote{+}} and multiplication \sphinxcode{\sphinxupquote{*}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{any}\PYG{p}{(}\PYG{n+nb}{hasattr}\PYG{p}{(}\PYG{n}{container}\PYG{p}{,} \PYG{n}{attr}\PYG{p}{)} \PYG{k}{for} \PYG{n}{attr} \PYG{o+ow}{in} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}mult\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{container} \PYG{o+ow}{in} \PYG{p}{(}\PYG{n+nb}{dict}\PYG{p}{,} \PYG{n+nb}{set}\PYG{p}{,} \PYG{n+nb}{frozenset}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Use the unpacking operators \sphinxcode{\sphinxupquote{*}} and \sphinxcode{\sphinxupquote{**}} to concatenate two sets/dictionaries below into a new set/dictionary.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{set1} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{set2} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cde}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
\PYG{n}{concatenated\PYGZus{}set} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{o}{*}\PYG{n}{set1}\PYG{p}{,}\PYG{o}{*}\PYG{n}{set2}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\PYG{n}{concatenated\PYGZus{}set}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}d\PYGZsq{}, \PYGZsq{}e\PYGZsq{}\PYGZcb{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dict1} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{dict2} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{def}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
\PYG{n}{concatenated\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{o}{*}\PYG{o}{*}\PYG{n}{dict1}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{dict2}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\PYG{n}{concatenated\PYGZus{}dict}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}0: \PYGZsq{}a\PYGZsq{}, 1: \PYGZsq{}b\PYGZsq{}, 2: \PYGZsq{}d\PYGZsq{}, 3: \PYGZsq{}e\PYGZsq{}, 4: \PYGZsq{}f\PYGZsq{}\PYGZcb{}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{set}} overloads many other operators:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 550
a, b = \PYGZob{}1,2\PYGZcb{}, \PYGZob{}2,3\PYGZcb{}

union = a | b
assert all(i in union for i in a) and all(i in union for i in b)

intersection = a \PYGZam{} b
assert all(i in a and i in b for i in intersection)

assert intersection \PYGZlt{}= a \PYGZlt{}= union  \PYGZsh{} subset
assert union \PYGZgt{} b \PYGZgt{} intersection    \PYGZsh{} proper superset
assert len(a) + len(b) == len(intersection) + len(union) 

symmetric\PYGZus{}difference = a \PYGZca{} b
assert all((i in a or i in b) and not (i in a and i in b) 
           for i in symmetric\PYGZus{}difference)
assert symmetric\PYGZus{}difference == union \PYGZhy{} intersection
assert set.isdisjoint(intersection, symmetric\PYGZus{}difference)
assert len(union) == len(intersection) + len(symmetric\PYGZus{}difference)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fa62d66cac8\PYGZgt{}
\end{sphinxVerbatim}

The following uses \sphinxcode{\sphinxupquote{\&}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}}} to compare the sets of public attributes for \sphinxcode{\sphinxupquote{set}} and \sphinxcode{\sphinxupquote{dict}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{set\PYGZus{}attributes} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{attr} \PYG{k}{for} \PYG{n}{attr} \PYG{o+ow}{in} \PYG{n+nb}{dir}\PYG{p}{(}\PYG{n+nb}{set}\PYG{p}{)} \PYG{k}{if} \PYG{n}{attr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{!=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{dict\PYGZus{}attributes} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{attr} \PYG{k}{for} \PYG{n}{attr} \PYG{o+ow}{in} \PYG{n+nb}{dir}\PYG{p}{(}\PYG{n+nb}{dict}\PYG{p}{)} \PYG{k}{if} \PYG{n}{attr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{!=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Common attributes:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{set\PYGZus{}attributes} \PYG{o}{\PYGZam{}} \PYG{n}{dict\PYGZus{}attributes}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dict\PYGZhy{}specific attributes:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{dict\PYGZus{}attributes} \PYG{o}{\PYGZhy{}} \PYG{n}{set\PYGZus{}attributes}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{set\PYGZhy{}specific attributes:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{set\PYGZus{}attributes} \PYG{o}{\PYGZhy{}} \PYG{n}{dict\PYGZus{}attributes}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Common attributes: copy, update, pop, clear
dict\PYGZhy{}specific attributes: items, get, popitem, values, fromkeys, setdefault, keys
set\PYGZhy{}specific attributes: issubset, add, remove, symmetric\PYGZus{}difference, difference, intersection, discard, issuperset, union, isdisjoint, intersection\PYGZus{}update, difference\PYGZus{}update, symmetric\PYGZus{}difference\PYGZus{}update
\end{sphinxVerbatim}

For \sphinxcode{\sphinxupquote{set}}, the intersection operation \sphinxcode{\sphinxupquote{\&}} can also be performed by
\begin{itemize}
\item {} 
the class method \sphinxcode{\sphinxupquote{intersection}} which returns the intersection of its arguments, and

\item {} 
the object method \sphinxcode{\sphinxupquote{intersection\_update}} which mutates a set object by intersecting the set with the arguments.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
a = \PYGZob{}0,1,2\PYGZcb{}
b = \PYGZob{}1,2,3\PYGZcb{}
c = set.intersection(a,b,\PYGZob{}2,3,4\PYGZcb{})
a.intersection\PYGZus{}update(b,c)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fa62d66c748\PYGZgt{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
All other set\sphinxhyphen{}specific methods have an associated operator except \sphinxcode{\sphinxupquote{isdisjoint}} as shown below.

\item {} 
The object method for \sphinxcode{\sphinxupquote{union}} is \sphinxcode{\sphinxupquote{update}} not \sphinxcode{\sphinxupquote{union\_update}}.

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
class method
&\sphinxstyletheadfamily 
object method
&\sphinxstyletheadfamily 
operator
\\
\hline
\sphinxcode{\sphinxupquote{union}}
&
\sphinxcode{\sphinxupquote{update}}
&
\sphinxcode{\sphinxupquote{\textbackslash{}| }}
\\
\hline
\sphinxcode{\sphinxupquote{intersection}}
&
\sphinxcode{\sphinxupquote{intersection\_update}}
&
\sphinxcode{\sphinxupquote{\&}}
\\
\hline
\sphinxcode{\sphinxupquote{symmetric\_difference}}
&
\sphinxcode{\sphinxupquote{symmetric\_difference\_update}}
&
\sphinxcode{\sphinxupquote{\textasciicircum{}}}
\\
\hline
\sphinxcode{\sphinxupquote{issubset}}
&

&
\sphinxcode{\sphinxupquote{<=}}
\\
\hline
\sphinxcode{\sphinxupquote{issuperset}}
&

&
\sphinxcode{\sphinxupquote{>=}}
\\
\hline
\sphinxcode{\sphinxupquote{isdisjoint}}
&

&

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxcode{\sphinxupquote{dict}} also has an \sphinxcode{\sphinxupquote{update}} method that can update a dictionary using dictionary, iterables and keyword arguments:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}}\PYG{k}{mytutor} \PYGZhy{}h 300
a = \PYGZob{}\PYGZcb{}
a.update(enumerate(\PYGZsq{}a\PYGZsq{}),b=2)
b = a.copy()
a.update(b,c=3)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.lib.display.IFrame at 0x7fa62d66cac8\PYGZgt{}
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} For \sphinxcode{\sphinxupquote{dict}}, there is also a method called \sphinxhref{https://stackoverflow.com/questions/3483520/use-cases-for-the-setdefault-dict-method}{\sphinxcode{\sphinxupquote{setdefault}}}. Use it to define a function \sphinxcode{\sphinxupquote{group\_by\_type}} that
\begin{itemize}
\item {} 
takes a sequence \sphinxcode{\sphinxupquote{seq}} of objects and

\item {} 
returns a dictionary \sphinxcode{\sphinxupquote{d}} such that \sphinxcode{\sphinxupquote{d{[}repr(t){]}}} returns the list of objects in \sphinxcode{\sphinxupquote{seq}} of type \sphinxcode{\sphinxupquote{t}}

\end{itemize}

If there is no objects of type \sphinxcode{\sphinxupquote{t}}, raise a key error.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{group\PYGZus{}by\PYGZus{}type}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{group} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{seq}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
        \PYG{n}{group}\PYG{o}{.}\PYG{n}{setdefault}\PYG{p}{(}\PYG{n+nb}{repr}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
    \PYG{k}{return} \PYG{n}{group}

\PYG{n}{group\PYGZus{}by\PYGZus{}type}\PYG{p}{(}\PYG{p}{[}\PYG{o}{*}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}
               \PYG{o}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
               \PYG{o}{*}\PYG{p}{[}\PYG{n}{i}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
               \PYG{o}{*}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
               \PYG{o}{*}\PYG{p}{[}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
               \PYG{o}{*}\PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{n}{i}\PYG{p}{\PYGZcb{}} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
               \PYG{o}{*}\PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{n}{i}\PYG{p}{:}\PYG{n}{i}\PYG{p}{\PYGZcb{}} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
               \PYG{n+nb}{print}\PYG{p}{,}\PYG{n+nb}{hash}\PYG{p}{,}
               \PYG{n+nb}{int}\PYG{p}{,}\PYG{n+nb}{str}\PYG{p}{,}\PYG{n+nb}{float}\PYG{p}{,}\PYG{n+nb}{set}\PYG{p}{,}\PYG{n+nb}{dict}\PYG{p}{,}
               \PYG{p}{(}\PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} 
               \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} 
               \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}
               \PYG{n+nb}{zip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
               \PYG{n+nb}{set}\PYG{o}{.}\PYG{n}{add}\PYG{p}{,}
               \PYG{n+nb}{dict}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZdq{}\PYGZlt{}class \PYGZsq{}int\PYGZsq{}\PYGZgt{}\PYGZdq{}: [0, 1, 2],
 \PYGZdq{}\PYGZlt{}class \PYGZsq{}str\PYGZsq{}\PYGZgt{}\PYGZdq{}: [\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}],
 \PYGZdq{}\PYGZlt{}class \PYGZsq{}float\PYGZsq{}\PYGZgt{}\PYGZdq{}: [0.0, 0.5, 1.0],
 \PYGZdq{}\PYGZlt{}class \PYGZsq{}tuple\PYGZsq{}\PYGZgt{}\PYGZdq{}: [(0,), (1,), (2,)],
 \PYGZdq{}\PYGZlt{}class \PYGZsq{}list\PYGZsq{}\PYGZgt{}\PYGZdq{}: [[0], [1], [2]],
 \PYGZdq{}\PYGZlt{}class \PYGZsq{}set\PYGZsq{}\PYGZgt{}\PYGZdq{}: [\PYGZob{}0\PYGZcb{}, \PYGZob{}1\PYGZcb{}, \PYGZob{}2\PYGZcb{}],
 \PYGZdq{}\PYGZlt{}class \PYGZsq{}dict\PYGZsq{}\PYGZgt{}\PYGZdq{}: [\PYGZob{}0: 0\PYGZcb{}, \PYGZob{}1: 1\PYGZcb{}, \PYGZob{}2: 2\PYGZcb{}],
 \PYGZdq{}\PYGZlt{}class \PYGZsq{}builtin\PYGZus{}function\PYGZus{}or\PYGZus{}method\PYGZsq{}\PYGZgt{}\PYGZdq{}: [\PYGZlt{}function print\PYGZgt{},
  \PYGZlt{}function hash(obj, /)\PYGZgt{}],
 \PYGZdq{}\PYGZlt{}class \PYGZsq{}type\PYGZsq{}\PYGZgt{}\PYGZdq{}: [int, str, float, set, dict],
 \PYGZdq{}\PYGZlt{}class \PYGZsq{}generator\PYGZsq{}\PYGZgt{}\PYGZdq{}: [\PYGZlt{}generator object \PYGZlt{}genexpr\PYGZgt{} at 0x7fa62d7688b8\PYGZgt{}],
 \PYGZdq{}\PYGZlt{}class \PYGZsq{}enumerate\PYGZsq{}\PYGZgt{}\PYGZdq{}: [\PYGZlt{}enumerate at 0x7fa62d672948\PYGZgt{}],
 \PYGZdq{}\PYGZlt{}class \PYGZsq{}range\PYGZsq{}\PYGZgt{}\PYGZdq{}: [range(0, 3)],
 \PYGZdq{}\PYGZlt{}class \PYGZsq{}zip\PYGZsq{}\PYGZgt{}\PYGZdq{}: [\PYGZlt{}zip at 0x7fa62d66eb08\PYGZgt{}],
 \PYGZdq{}\PYGZlt{}class \PYGZsq{}method\PYGZus{}descriptor\PYGZsq{}\PYGZgt{}\PYGZdq{}: [\PYGZlt{}method \PYGZsq{}add\PYGZsq{} of \PYGZsq{}set\PYGZsq{} objects\PYGZgt{},
  \PYGZlt{}method \PYGZsq{}copy\PYGZsq{} of \PYGZsq{}dict\PYGZsq{} objects\PYGZgt{}]\PYGZcb{}
\end{sphinxVerbatim}


\chapter{Monte Carlo Simulation and Linear Algebra}
\label{\detokenize{Lecture9/Monte Carlo Simulation and Linear Algebra:monte-carlo-simulation-and-linear-algebra}}\label{\detokenize{Lecture9/Monte Carlo Simulation and Linear Algebra::doc}}

\section{Monte Carlo simulation}
\label{\detokenize{Lecture9/Monte Carlo Simulation and Linear Algebra:monte-carlo-simulation}}
\sphinxstylestrong{What is Monte Carlo simulation?}
\begin{quote}

The name Monte Carlo refers to the \sphinxhref{https://en.wikipedia.org/wiki/Monte\_Carlo\_Casino}{Monte Carlo Casino in Monaco} where Ulam’s uncle would borrow money from relatives to gamble.
\end{quote}

It would be nice to simulate the casino, so Ulam’s uncle did not need to borrow money to go.Actually…,
\begin{itemize}
\item {} 
Monte Carlo is the code name of the secret project for creating the \sphinxhref{https://en.wikipedia.org/wiki/Monte\_Carlo\_method}{hydrogen bomb}.

\item {} 
\sphinxhref{https://en.wikipedia.org/wiki/Stanislaw\_Ulam}{Ulam} worked with \sphinxhref{https://en.wikipedia.org/wiki/John\_von\_Neumann}{John von Neumann} to program the first electronic computer ENIAC to simulate a computational model of a thermonuclear reaction.

\end{itemize}

(See also \sphinxhref{https://permalink.lanl.gov/object/tr?what=info:lanl-repo/lareport/LA-UR-88-9067}{The Beginning of the Monte Carlo Method} for a more detailed account.)

\sphinxstylestrong{How to compute the value of \(\pi\)}?

An application of Monte Carlo simulation is in approximating \(\pi\) using
the \sphinxhref{https://en.wikipedia.org/wiki/Buffon\%27s\_needle\_problem}{Buffon’s needle}.There is \sphinxhref{https://www.khanacademy.org/computer-programming/pi-by-buffons-needle/6695500989890560}{a program} written in javascript to do this.

The javascript program a bit long to digest, so we will use an alternative simulation that is easier to understand/program.

If we uniformly randomly pick a point in a square. What is the chance it is in the inscribed circle, i.e., the biggest circle inside the square?

The chance is the area of the circle divided by the area of the square. Suppose the square has length \(\ell\), then the chance is
\begin{equation*}
\begin{split} \frac{\pi (\ell /2)^2}{ (\ell)^2 } = \frac{\pi}4 \end{split}
\end{equation*}
independent of the length \(\ell\).

\sphinxstylestrong{Exercise} Complete the following function to return an approximation of \(\pi\) as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Simulate the random process of picking a point from a square repeatedly \sphinxcode{\sphinxupquote{n}} times bygenerating the \(x\) and \(y\) coordinates uniformly randomly from a unit interval \([0,1)\).

\item {} 
Compute the fraction of times the point is in the first quadrant of the inscribed circle as shown in the figure below.

\item {} 
Return \(4\) times the fraction as the approximation.

\end{enumerate}



\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}\PYG{o}{,} \PYG{n+nn}{math}

\PYG{k}{def} \PYG{n+nf}{approximate\PYGZus{}pi}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
     \PYG{k}{return} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n+nb}{len}\PYG{p}{(}\PYG{p}{[}\PYG{k+kc}{True} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} 
                   \PYG{k}{if} \PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{n}{n}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Approximate: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{approximate\PYGZus{}pi}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+m+mf}{1e7}\PYG{p}{)}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{Ground truth: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Approximate: 3.1414888
Ground truth: 3.141592653589793
\end{sphinxVerbatim}

\sphinxstylestrong{How accurate is the approximation?}

The following uses a powerful library \sphinxcode{\sphinxupquote{numpy}} for computing to return a \sphinxhref{http://onlinestatbook.com/2/estimation/mean.html\#:~:text=To\%20compute\%20the\%2095\%25\%20confidence,be\%20between\%20the\%20cutoff\%20points.}{\(95\%\)\sphinxhyphen{}confidence interval}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k}{def} \PYG{n+nf}{np\PYGZus{}approximate\PYGZus{}pi}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{in\PYGZus{}circle} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}
    \PYG{n}{mean} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{in\PYGZus{}circle}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{std} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{in\PYGZus{}circle}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{p}{)} \PYG{o}{/} \PYG{n}{n}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mean} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{std}\PYG{p}{,} \PYG{n}{mean} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{std}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{interval} \PYG{o}{=} \PYG{n}{np\PYGZus{}approximate\PYGZus{}pi}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+m+mf}{1e7}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+s1}{95\PYGZpc{}\PYGZhy{}confidence interval: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{interval}\PYG{l+s+si}{\PYGZcb{}}
\PYG{l+s+s1}{Estimate: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{interval}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{:}\PYG{l+s+s1}{.4f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ ± }\PYG{l+s+si}{\PYGZob{}}\PYG{p}{(}\PYG{n}{interval}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{interval}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{l+s+si}{:}\PYG{l+s+s1}{.4f}\PYG{l+s+si}{\PYGZcb{}}
\PYG{l+s+s1}{Ground truth: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
95\PYGZpc{}\PYGZhy{}confidence interval: [3.14097918 3.14305602]
Estimate: 3.1420 ± 0.0010
Ground truth: 3.141592653589793
\end{sphinxVerbatim}

Note that the computation done using \sphinxcode{\sphinxupquote{numpy}} is over \(5\) times faster despite the additional computation of the standard deviation.

There are faster methods to approximate \(\pi\) such as the \sphinxhref{https://en.wikipedia.org/wiki/Chudnovsky\_algorithm}{Chudnovsky\_algorithm}, but Monte\sphinxhyphen{}Carlo method is still useful in more complicated situations.E.g., see the Monte Carlo simulation of a \sphinxhref{https://www.youtube.com/watch?v=-fCVxTTAtFQ}{real\sphinxhyphen{}life situation} in playing basketball:
\begin{quote}

“When down by three and left with only 30 seconds is it better to attempt a hard 3\sphinxhyphen{}point shot or an easy 2\sphinxhyphen{}point shot and get another possession?”   –LeBron James
\end{quote}


\section{Linear Algebra}
\label{\detokenize{Lecture9/Monte Carlo Simulation and Linear Algebra:linear-algebra}}
\sphinxstylestrong{How to solve a linear equation?}

Given the following linear equation in variable \(x\) with real\sphinxhyphen{}valued coefficient \(a\) and \(b\),
\begin{equation*}
\begin{split} a x = b,\end{split}
\end{equation*}
what is the value of \(x\) that satisfies the equation?

\sphinxstylestrong{Exercise} Complete the following function to return either the unique solution of \(x\) or \sphinxcode{\sphinxupquote{None}} if a unique solution does not exist.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{solve\PYGZus{}linear\PYGZus{}equation}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{return} \PYG{n}{b}\PYG{o}{/}\PYG{n}{a} \PYG{k}{if} \PYG{n}{a} \PYG{o}{!=} \PYG{l+m+mi}{0} \PYG{k}{else} \PYG{k+kc}{None}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}

\PYG{k+kn}{import} \PYG{n+nn}{ipywidgets} \PYG{k}{as} \PYG{n+nn}{widgets}
\PYG{n+nd}{@widgets}\PYG{o}{.}\PYG{n}{interact}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{b}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{linear\PYGZus{}equation\PYGZus{}solver}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+s1}{linear equation: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{x = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}
\PYG{l+s+s1}{       solution: x = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{solve\PYGZus{}linear\PYGZus{}equation}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(IntSlider(value=2, description=\PYGZsq{}a\PYGZsq{}, max=5), IntSlider(value=3, description=\PYGZsq{}b\PYGZsq{}, max=5), …
\end{sphinxVerbatim}

\sphinxstylestrong{How to solve multiple linear equations?}

In the general case, we have a system of \(m\) linear equations and \(n\) variables:
\begin{equation*}
\begin{split} \begin{aligned}
a_{00} x_0 + a_{01} x_1 + \dots + a_{0(n-1)} x_{n-1} &= b_0\\
a_{10} x_0 + a_{11} x_1 + \dots + a_{1(n-1)} x_{n-1} &= b_1\\
\vdots\kern2em &= \vdots\\
a_{(m-1)0} x_0 + a_{(m-1)1} x_1 + \dots + a_{(m-1)(n-1)} x_{n-1} &= b_{m-1}\\
\end{aligned}
\end{split}
\end{equation*}
where
\begin{itemize}
\item {} 
\(x_j\) for \(j\in \{0,\dots,n-1\}\) are the variables, and

\item {} 
\(a_{ij}\) and \(b_j\) for \(i\in \{0,\dots,m-1\}\) and \(j\in \{0,\dots,n-1\}\) are the coefficients.

\end{itemize}

A fundamental problem in linear algebra is to compute the unique solution to the system if it exists.

We will consider the simpler 2\sphinxhyphen{}by\sphinxhyphen{}2 system with 2 variables and 2 equations:
\begin{equation*}
\begin{split} \begin{aligned}
a_{00} x_0 + a_{01} x_1 &= b_0\\
a_{10} x_0 + a_{11} x_1 &= b_1.
\end{aligned}
\end{split}
\end{equation*}
To get an idea of the solution, suppose
\begin{equation*}
\begin{split}a_{00}=a_{11}=1, a_{01} = a_{10} = 0.\end{split}
\end{equation*}
The system of equations become
\begin{equation*}
\begin{split} \begin{aligned}
x_0 \hphantom{+ x_1} &= b_0\\
\hphantom{x_0 +}  x_1 &= b_1,
\end{aligned}
\end{split}
\end{equation*}
which gives the solution directly.

What about \(a_{00}=a_{11}=2\) instead?
\begin{equation*}
\begin{split} \begin{aligned}
2x_0 \hphantom{+ x_1} &= b_0\\
\hphantom{2x_0 +}  2x_1 &= b_1,
\end{aligned}\end{split}
\end{equation*}
To obtain the solution, we simply divide both equations by 2:
\begin{equation*}
\begin{split} \begin{aligned}
x_0 \hphantom{+ x_1} &= \frac{b_0}2\\
\hphantom{x_0 +}  x_1 &= \frac{b_1}2.
\end{aligned}
\end{split}
\end{equation*}
What if \(a_{01}=2\) instead?
\begin{equation*}
\begin{split} \begin{aligned}
2x_0 + 2x_1 &= b_0\\
\hphantom{2x_0 +}  2x_1 &= b_1\\
\end{aligned}
\end{split}
\end{equation*}
The second equation gives the solution of \(x_1\), and we can use the solution in the first equation to solve for \(x_0\). More precisely:
\begin{itemize}
\item {} 
Subtract the second equation from the first one:

\end{itemize}
\begin{equation*}
\begin{split} \begin{aligned}
2x_0 \hphantom{+2x_1} &= b_0 - b_1\\
\hphantom{2x_0 +}  2x_1 &= b_1\\
\end{aligned}
\end{split}
\end{equation*}\begin{itemize}
\item {} 
Divide both equation by 2:

\end{itemize}
\begin{equation*}
\begin{split} \begin{aligned}
x_0 \hphantom{+ x_1} &= \frac{b_0 - b_1}2\\
\hphantom{x_0 +}  x_1 &= \frac{b_1}2\\
\end{aligned}
\end{split}
\end{equation*}
The above operations are called \sphinxstyleemphasis{row operations} in linear algebra: each row is an equation.A system of linear equations can be solved by the linear operations of
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
multiplying an equation by a constant, and

\item {} 
subtracting one equation from another.

\end{enumerate}

How to write a program to solve a general 2\sphinxhyphen{}by\sphinxhyphen{}2 system? We will use the \sphinxcode{\sphinxupquote{numpy}} library.


\subsection{Creating \sphinxstyleliteralintitle{\sphinxupquote{numpy}} arrays}
\label{\detokenize{Lecture9/Monte Carlo Simulation and Linear Algebra:creating-numpy-arrays}}
\sphinxstylestrong{How to store the coefficients?}

In linear algebra, a system of equations such as
\begin{equation*}
\begin{split} \begin{aligned}
a_{00} x_0 + a_{01} x_1 &= b_0\\
a_{10} x_0 + a_{11} x_1 &= b_1
\end{aligned}
\end{split}
\end{equation*}
is written concisely in \sphinxstyleemphasis{matrix} form as \( \mathbf{A} \mathbf{x} = \mathbf{b} \):
\begin{equation*}
\begin{split}\overbrace{\begin{bmatrix}
a_{00} & a_{01}\\
a_{10} & a_{11}
\end{bmatrix}}^{\mathbf{A}}
\overbrace{
\begin{bmatrix}
x_0\\
x_1
\end{bmatrix}}
^{\mathbf{x}}
= \overbrace{\begin{bmatrix}
b_0\\
b_1
\end{bmatrix}}^{\mathbf{b}},
\end{split}
\end{equation*}
where
\( \mathbf{A} \mathbf{x}\) is the \sphinxstyleemphasis{matrix multiplication}
\begin{equation*}
\begin{split} \mathbf{A} \mathbf{x} = \begin{bmatrix}
a_{00} x_0 + a_{01} x_1\\
a_{10} x_0 + a_{11} x_1
\end{bmatrix}.
\end{split}
\end{equation*}
We say that \(\mathbf{A}\) is a \sphinxhref{https://en.wikipedia.org/wiki/Matrix\_(mathematics)}{\sphinxstyleemphasis{matrix}} and its dimension/shape is \(2\)\sphinxhyphen{}by\sphinxhyphen{}\(2\):
\begin{itemize}
\item {} 
The first dimension/axis has size \(2\). We also say that the matrix has \(2\) rows.

\item {} 
The second dimension/axis has size \(2\). We also say that the matrix has \(2\) columns.
\(\mathbf{x}\) and \(\mathbf{b}\) are called column vectors, which are matrices with one column.

\end{itemize}

Consider the example
\$\( \begin{aligned}
2x_0 + 2x_1 &= 1\\
\hphantom{2x_0 +}  2x_1 &= 1,
\end{aligned}\)\(
or in matrix form with
\)\( \begin{aligned}
\mathbf{A}&=\begin{bmatrix}
a_{00} & a_{01} \\
a_{10} & a_{11} 
\end{bmatrix} 
= \begin{bmatrix}
2 & 2 \\
0 & 2 
\end{bmatrix}\\
\mathbf{b}&=\begin{bmatrix}
b_0\\
b_1
\end{bmatrix} = \begin{bmatrix}
1\\
1
\end{bmatrix}\end{aligned}\)\$

Instead of using \sphinxcode{\sphinxupquote{list}} to store the matrix, we will use a \sphinxcode{\sphinxupquote{numpy}} array.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{2.}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([[2., 2.],
        [0., 2.]]),
 array([1., 1.]))
\end{sphinxVerbatim}

Compared to \sphinxcode{\sphinxupquote{list}}, \sphinxcode{\sphinxupquote{numpy}} array is often more efficient and has more useful attributes.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{array\PYGZus{}attributes} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{n}{attr} \PYG{k}{for} \PYG{n}{attr} \PYG{o+ow}{in} \PYG{n+nb}{dir}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)} \PYG{k}{if} \PYG{n}{attr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{list\PYGZus{}attributes} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{n}{attr} \PYG{k}{for} \PYG{n}{attr} \PYG{o+ow}{in} \PYG{n+nb}{dir}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{)} \PYG{k}{if} \PYG{n}{attr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{Common attributes:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{o}{*}\PYG{p}{(}\PYG{n}{array\PYGZus{}attributes} \PYG{o}{\PYGZam{}} \PYG{n}{list\PYGZus{}attributes}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{Array\PYGZhy{}specific attributes:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{*}\PYG{p}{(}\PYG{n}{array\PYGZus{}attributes} \PYG{o}{\PYGZhy{}} \PYG{n}{list\PYGZus{}attributes}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{List\PYGZhy{}specific attributes:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{o}{*}\PYG{p}{(}\PYG{n}{list\PYGZus{}attributes} \PYG{o}{\PYGZhy{}} \PYG{n}{array\PYGZus{}attributes}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Common attributes:
 copy sort

Array\PYGZhy{}specific attributes:
 compress nbytes tobytes var shape ravel choose squeeze round all astype newbyteorder conjugate tolist imag flags cumprod flat argmax searchsorted mean data view setflags cumsum swapaxes ctypes put take argmin std diagonal ndim any dumps tostring item conj real dtype dump tofile reshape max argpartition dot argsort strides flatten sum nonzero itemset clip size partition base ptp itemsize min prod trace byteswap getfield repeat fill T transpose resize setfield

List\PYGZhy{}specific attributes:
 reverse extend append remove pop count index insert clear
\end{sphinxVerbatim}

The following attributes give the dimension/shape, number of dimensions, size, and datatype.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{array} \PYG{o+ow}{in} \PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{array}\PYG{l+s+si}{\PYGZcb{}}
\PYG{l+s+s1}{    shape: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{array}\PYG{o}{.}\PYG{n}{shape}\PYG{l+s+si}{\PYGZcb{}}
\PYG{l+s+s1}{    ndim: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{array}\PYG{o}{.}\PYG{n}{ndim}\PYG{l+s+si}{\PYGZcb{}}
\PYG{l+s+s1}{    size: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{array}\PYG{o}{.}\PYG{n}{size}\PYG{l+s+si}{\PYGZcb{}}
\PYG{l+s+s1}{    dtype: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{array}\PYG{o}{.}\PYG{n}{dtype}\PYG{l+s+si}{\PYGZcb{}}
\PYG{l+s+s1}{    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[2. 2.]
 [0. 2.]]
    shape: (2, 2)
    ndim: 2
    size: 4
    dtype: float64
    
[1. 1.]
    shape: (2,)
    ndim: 1
    size: 2
    dtype: float64
    
\end{sphinxVerbatim}

Note that the function \sphinxcode{\sphinxupquote{len}} only returns the size of the first dimension:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert} \PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{==} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
2
\end{sphinxVerbatim}

Unlike \sphinxcode{\sphinxupquote{list}}, every \sphinxcode{\sphinxupquote{numpy}} array has a data type. For efficient computation/storage, numpy implements different data types with different storage sizes:
\begin{itemize}
\item {} 
integer: \sphinxcode{\sphinxupquote{int8}}, \sphinxcode{\sphinxupquote{int16}}, \sphinxcode{\sphinxupquote{int32}}, \sphinxcode{\sphinxupquote{int64}}, \sphinxcode{\sphinxupquote{uint8}}, …

\item {} 
float: \sphinxcode{\sphinxupquote{float16}}, \sphinxcode{\sphinxupquote{float32}}, \sphinxcode{\sphinxupquote{float64}}, …

\item {} 
complex: \sphinxcode{\sphinxupquote{complex64}}, \sphinxcode{\sphinxupquote{complex128}}, …

\item {} 
boolean: \sphinxcode{\sphinxupquote{bool8}}

\item {} 
Unicode: \sphinxcode{\sphinxupquote{string}}

\item {} 
Object: \sphinxcode{\sphinxupquote{object}}

\end{itemize}

E.g., \sphinxcode{\sphinxupquote{int64}} is the 64\sphinxhyphen{}bit integer. Unlike \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{int64}} has a range.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
np.int64\PYG{o}{?}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{range: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{int64}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{63}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ to }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{int64}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{63}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{int64}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{63}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} overflow error}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
range: \PYGZhy{}9223372036854775808 to 9223372036854775807
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{OverflowError}\PYG{g+gWhitespace}{                             }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{9}\PYG{o}{\PYGZhy{}}\PYG{n}{b5ecbde7f9e9}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{n}{get\PYGZus{}ipython}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{run\PYGZus{}line\PYGZus{}magic}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pinfo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{np.int64}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2} \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{range: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{int64}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{63}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ to }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{int64}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{63}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{3} \PYG{n}{np}\PYG{o}{.}\PYG{n}{int64}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{63}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} overflow error}

\PYG{n+ne}{OverflowError}: Python int too large to convert to C long
\end{sphinxVerbatim}

We can use the \sphinxcode{\sphinxupquote{astype}} method to convert the data type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A\PYGZus{}int64} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}       \PYG{c+c1}{\PYGZsh{} converts to int64 by default}
\PYG{n}{A\PYGZus{}float32} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float32}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} converts to float32}
\PYG{k}{for} \PYG{n}{array} \PYG{o+ow}{in} \PYG{n}{A\PYGZus{}int64}\PYG{p}{,} \PYG{n}{A\PYGZus{}float32}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{array}\PYG{p}{,} \PYG{n}{array}\PYG{o}{.}\PYG{n}{dtype}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[2 2]
 [0 2]] int64
[[2. 2.]
 [0. 2.]] float32
\end{sphinxVerbatim}

We have to be careful about assigning items of different types to an array.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A\PYGZus{}int64}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{A\PYGZus{}int64}\PYG{p}{)}
\PYG{n}{A\PYGZus{}int64}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.5}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{A\PYGZus{}int64}\PYG{p}{)}                \PYG{c+c1}{\PYGZsh{} intended assignment fails}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{float}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} will be all floating point numbers}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[1 2]
 [0 2]]
[[0 2]
 [0 2]]
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([1., 1.])
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Create a heterogeneous numpy array to store both integer and strings:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Hint:} There is an numpy data type called \sphinxcode{\sphinxupquote{object}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
np.object\PYG{o}{?}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
\PYG{n}{heterogeneous\PYGZus{}np\PYGZus{}array} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{*}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{o}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{object}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\PYG{n}{heterogeneous\PYGZus{}np\PYGZus{}array}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([0, 1, 2, \PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}], dtype=object)
\end{sphinxVerbatim}

Be careful when creating arrays of \sphinxcode{\sphinxupquote{tuple}}/\sphinxcode{\sphinxupquote{list}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{array} \PYG{o+ow}{in} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{,}
              \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{array}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{shape:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{array}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{length:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{array}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{size:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{array}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[(1, 2) list([3, 4, 5])] 
shape: (2,) length: 2 size: 2
[[1 2]
 [3 4]] 
shape: (2, 2) length: 2 size: 4
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{numpy}} provides many functions to create an array:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
np.zeros\PYG{o}{?}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Dimension can be higher than 2}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([], dtype=float64),
 array([0.]),
 array([[[0., 0., 0., 0.],
         [0., 0., 0., 0.],
         [0., 0., 0., 0.]],
 
        [[0., 0., 0., 0.],
         [0., 0., 0., 0.],
         [0., 0., 0., 0.]]]))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
np.ones\PYG{o}{?}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} initialize values to int 1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([], dtype=int64),
 array([[[1, 1, 1, 1],
         [1, 1, 1, 1],
         [1, 1, 1, 1]],
 
        [[1, 1, 1, 1],
         [1, 1, 1, 1],
         [1, 1, 1, 1]]]))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
np.eye\PYG{o}{?}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} identity matrices}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([], shape=(0, 0), dtype=float64),
 array([[1.]]),
 array([[1., 0.],
        [0., 1.]]),
 array([[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
np.diag\PYG{o}{?}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{diag}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{diag}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{diag}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} diagonal matrices}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([[0]]),
 array([[0, 0],
        [0, 1]]),
 array([[0., 1., 0., 0.],
        [0., 0., 1., 0.],
        [0., 0., 0., 1.],
        [0., 0., 0., 0.]]))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
np.empty\PYG{o}{?}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} create array faster without initialization}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([], dtype=float64),
 array([[[ 94852514792576,               0, 140173244071472,
          140173241675144],
         [140173170760144, 140173170760200, 140173231958064,
          140173171104432],
         [140173171105048, 140173171105104, 140173171104824,
          140173214579376]],
 
        [[140173171109360, 140173170697200, 140173231740104,
          140173170697264],
         [140173242276584, 140173171115248, 140173231954368,
          140173171111232],
         [140173171109680, 140173170696752, 140173170696944,
          140173234814792]]]))
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{numpy}} also provides functions to build an array using rules.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
np.arange\PYG{o}{?}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mf}{4.5}\PYG{p}{,}\PYG{l+m+mf}{5.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} like range but allow non\PYGZhy{}integer parameters}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([0, 1, 2, 3, 4]), array([4]), array([4.5, 5. ]))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
np.linspace\PYG{o}{?}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} can specify number of points instead of step}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([4.        , 4.02040816, 4.04081633, 4.06122449, 4.08163265,
        4.10204082, 4.12244898, 4.14285714, 4.16326531, 4.18367347,
        4.20408163, 4.2244898 , 4.24489796, 4.26530612, 4.28571429,
        4.30612245, 4.32653061, 4.34693878, 4.36734694, 4.3877551 ,
        4.40816327, 4.42857143, 4.44897959, 4.46938776, 4.48979592,
        4.51020408, 4.53061224, 4.55102041, 4.57142857, 4.59183673,
        4.6122449 , 4.63265306, 4.65306122, 4.67346939, 4.69387755,
        4.71428571, 4.73469388, 4.75510204, 4.7755102 , 4.79591837,
        4.81632653, 4.83673469, 4.85714286, 4.87755102, 4.89795918,
        4.91836735, 4.93877551, 4.95918367, 4.97959184, 5.        ]),
 array([4. , 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5. ]),
 array([4. , 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5. ]))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
np.fromfunction\PYG{o}{?}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{fromfunction}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{:} \PYG{n}{i} \PYG{o}{*} \PYG{n}{j}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} can initialize using a function}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[0., 0., 0., 0.],
       [0., 1., 2., 3.],
       [0., 2., 4., 6.]])
\end{sphinxVerbatim}

We can also reshape an array using the \sphinxcode{\sphinxupquote{reshape}} method/function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{array} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{)}
array.reshape\PYG{o}{?}
\PYG{p}{(}\PYG{n}{array}\PYG{p}{,} 
 \PYG{n}{array}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}      \PYG{c+c1}{\PYGZsh{} last axis index changes fastest}
 \PYG{n}{array}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}     \PYG{c+c1}{\PYGZsh{} size of last axis calculated automatically}
 \PYG{n}{array}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{order}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} first axis index changes fastest}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23]),
 array([[[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11]],
 
        [[12, 13, 14, 15],
         [16, 17, 18, 19],
         [20, 21, 22, 23]]]),
 array([[[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11]],
 
        [[12, 13, 14, 15],
         [16, 17, 18, 19],
         [20, 21, 22, 23]]]),
 array([[[ 0,  6, 12, 18],
         [ 2,  8, 14, 20],
         [ 4, 10, 16, 22]],
 
        [[ 1,  7, 13, 19],
         [ 3,  9, 15, 21],
         [ 5, 11, 17, 23]]]))
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{flatten}} is a special case of reshaping an array to one dimension.(Indeed, \sphinxcode{\sphinxupquote{flatten}} returns a copy of the array but \sphinxcode{\sphinxupquote{reshape}} returns a dynamic view whenever possible.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{array} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{array}\PYG{p}{,} \PYG{n}{array}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{array}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{array}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{n}{order}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([[[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11]],
 
        [[12, 13, 14, 15],
         [16, 17, 18, 19],
         [20, 21, 22, 23]]]),
 array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23]),
 array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23]),
 array([ 0, 12,  4, 16,  8, 20,  1, 13,  5, 17,  9, 21,  2, 14,  6, 18, 10,
        22,  3, 15,  7, 19, 11, 23]))
\end{sphinxVerbatim}

\sphinxstylestrong{Exercise} Correct the following function to print every element of an array line\sphinxhyphen{}by\sphinxhyphen{}line.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}array\PYGZus{}entries\PYGZus{}line\PYGZus{}by\PYGZus{}line}\PYG{p}{(}\PYG{n}{array}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{array}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}array\PYGZus{}entries\PYGZus{}line\PYGZus{}by\PYGZus{}line}\PYG{p}{(}\PYG{n}{array}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{array}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
    
\PYG{n}{print\PYGZus{}array\PYGZus{}entries\PYGZus{}line\PYGZus{}by\PYGZus{}line}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Operating on \sphinxstyleliteralintitle{\sphinxupquote{numpy}} arrays}
\label{\detokenize{Lecture9/Monte Carlo Simulation and Linear Algebra:operating-on-numpy-arrays}}
\sphinxstylestrong{How to verify the solution of a system of linear equations?}

Before solving the system of linear equations, let us try to verify a solution to the equations:
\begin{equation*}
\begin{split} \begin{aligned}
2x_0 + 2x_1 &= 1\\
\hphantom{2x_0 +}  2x_1 &= 1
\end{aligned}
\end{split}
\end{equation*}
\sphinxcode{\sphinxupquote{numpy}} provides the function \sphinxcode{\sphinxupquote{matmul}} and the operator \sphinxcode{\sphinxupquote{@}} for matrix multiplication.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{matmul}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)} \PYG{o}{==} \PYG{n}{b}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{A} \PYG{o}{@} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{)} \PYG{o}{==} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[False False]
[ True  True]
\end{sphinxVerbatim}

Note that the comparison on \sphinxcode{\sphinxupquote{numpy}} arrays returns a boolean array instead of a boolean value, unlike the comparison operations on lists.

To check whether all items are true, we use the \sphinxcode{\sphinxupquote{all}} method.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{matmul}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)} \PYG{o}{==} \PYG{n}{b}\PYG{p}{)}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{(}\PYG{n}{A} \PYG{o}{@} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{)} \PYG{o}{==} \PYG{n}{b}\PYG{p}{)}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
True
\end{sphinxVerbatim}

\sphinxstylestrong{How to concatenate arrays?}

We will operate on an augmented matrix of the coefficients:
\begin{equation*}
\begin{split} \begin{aligned} \mathbf{C} &= \begin{bmatrix}
\mathbf{A} & \mathbf{b}
\end{bmatrix}\\
&= \begin{bmatrix}
a_{00} & a_{01} & b_0 \\
a_{10} & a_{11} & b_1
\end{bmatrix} 
\end{aligned}
\end{split}
\end{equation*}
\sphinxcode{\sphinxupquote{numpy}} provides functions to create block matrices:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
np.block\PYG{o}{?}
\PYG{n}{C} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{block}\PYG{p}{(}\PYG{p}{[}\PYG{n}{A}\PYG{p}{,}\PYG{n}{b}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} reshape to ensure same ndim}
\PYG{n}{C}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[2., 2., 1.],
       [0., 2., 1.]])
\end{sphinxVerbatim}

To stack an array along different axes:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{array} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{concat\PYGZus{}array} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{array}\PYG{p}{,}
                     \PYG{n}{np}\PYG{o}{.}\PYG{n}{hstack}\PYG{p}{(}\PYG{p}{(}\PYG{n}{array}\PYG{p}{,}\PYG{n}{array}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}   \PYG{c+c1}{\PYGZsh{} stack along the first axis}
                     \PYG{n}{np}\PYG{o}{.}\PYG{n}{vstack}\PYG{p}{(}\PYG{p}{(}\PYG{n}{array}\PYG{p}{,}\PYG{n}{array}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}                  \PYG{c+c1}{\PYGZsh{} second axis}
                     \PYG{n}{np}\PYG{o}{.}\PYG{n}{concatenate}\PYG{p}{(}\PYG{p}{(}\PYG{n}{array}\PYG{p}{,}\PYG{n}{array}\PYG{p}{)}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}    \PYG{c+c1}{\PYGZsh{} last axis}
                     \PYG{n}{np}\PYG{o}{.}\PYG{n}{stack}\PYG{p}{(}\PYG{p}{(}\PYG{n}{array}\PYG{p}{,}\PYG{n}{array}\PYG{p}{)}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{:}          \PYG{c+c1}{\PYGZsh{} new axis}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{concat\PYGZus{}array}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{shape:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{concat\PYGZus{}array}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[[0 1 2]
  [3 4 5]]] 
shape: (1, 2, 3)
[[[0 1 2]
  [3 4 5]
  [0 1 2]
  [3 4 5]]] 
shape: (1, 4, 3)
[[[0 1 2]
  [3 4 5]]

 [[0 1 2]
  [3 4 5]]] 
shape: (2, 2, 3)
[[[0 1 2 0 1 2]
  [3 4 5 3 4 5]]] 
shape: (1, 2, 6)
[[[[0 1 2]
   [3 4 5]]]


 [[[0 1 2]
   [3 4 5]]]] 
shape: (2, 1, 2, 3)
\end{sphinxVerbatim}

\sphinxstylestrong{How to perform arithmetic operations on a \sphinxcode{\sphinxupquote{numpy}} array?}

To divide all the coefficients by \(2\), we can simply write:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{D} \PYG{o}{=} \PYG{n}{C} \PYG{o}{/} \PYG{l+m+mi}{2}
\PYG{n}{D}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[1. , 1. , 0.5],
       [0. , 1. , 0.5]])
\end{sphinxVerbatim}

Note that the above does not work for \sphinxcode{\sphinxupquote{list}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{C}\PYG{o}{.}\PYG{n}{tolist}\PYG{p}{(}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2} \PYG{c+c1}{\PYGZsh{} deep convert to list}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}\PYG{n}{f30faff9f2c}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n}{C}\PYG{o}{.}\PYG{n}{tolist}\PYG{p}{(}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2} \PYG{c+c1}{\PYGZsh{} deep convert to list}

\PYG{n+ne}{TypeError}: unsupported operand type(s) for /: \PYGZsq{}list\PYGZsq{} and \PYGZsq{}int\PYGZsq{}
\end{sphinxVerbatim}

Arithmetic operations on \sphinxcode{\sphinxupquote{numpy}} arrays apply if the arrays have compatible dimensions. Two dimensions are compatible when
\begin{itemize}
\item {} 
they are equal, except for

\item {} 
components equal to 1.

\end{itemize}

\sphinxcode{\sphinxupquote{numpy}} uses \sphinxhref{https://numpy.org/doc/stable/user/basics.broadcasting.html\#general-broadcasting-rules}{broadcasting rules} to stretch the axis of size 1 up to match the corresponding axis in other arrays.\sphinxcode{\sphinxupquote{C / 2}} is a example where the second operand \(2\) is broadcasted to a \(2\)\sphinxhyphen{}by\sphinxhyphen{}\(2\) matrix before the elementwise division. Another example is as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{three\PYGZus{}by\PYGZus{}one} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{one\PYGZus{}by\PYGZus{}four} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+si}{\PYGZob{}}\PYG{n}{three\PYGZus{}by\PYGZus{}one}\PYG{l+s+si}{\PYGZcb{}}
\PYG{l+s+s1}{*}
\PYG{l+s+si}{\PYGZob{}}\PYG{n}{one\PYGZus{}by\PYGZus{}four}\PYG{l+s+si}{\PYGZcb{}}
\PYG{l+s+s1}{==}
\PYG{l+s+si}{\PYGZob{}}\PYG{n}{three\PYGZus{}by\PYGZus{}one} \PYG{o}{*} \PYG{n}{one\PYGZus{}by\PYGZus{}four}\PYG{l+s+si}{\PYGZcb{}}
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[0]
 [1]
 [2]]
*
[[0 1 2 3]]
==
[[0 0 0 0]
 [0 1 2 3]
 [0 2 4 6]]
\end{sphinxVerbatim}

Next, to subtract the second row of the coefficients from the first row:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{D}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{D}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{D}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{D}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[1. , 0. , 0. ],
       [0. , 1. , 0.5]])
\end{sphinxVerbatim}

Notice the use of commas to index different dimensions instead of using multiple brackets:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert} \PYG{p}{(}\PYG{n}{D}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{==} \PYG{n}{D}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Using this indexing technique, it is easy extract the last column as the solution to the system of linear equations:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{D}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{x}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([0. , 0.5])
\end{sphinxVerbatim}

This gives the desired solution \(x_0=0\) and \(x_1=0.5\) for
\begin{equation*}
\begin{split} \begin{aligned}
2x_0 + 2x_1 &= 1\\
\hphantom{2x_0 +}  2x_1 &= 1\\
\end{aligned}\end{split}
\end{equation*}
\sphinxcode{\sphinxupquote{numpy}} provides many \sphinxhref{https://numpy.org/doc/stable/reference/arrays.indexing.html\#advanced-indexing}{convenient ways} to index an array.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{B} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{B}\PYG{p}{,} \PYG{n}{B}\PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} selecting the corners using integer array}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([[0, 1, 2],
        [3, 4, 5]]),
 array([2, 3]))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{B} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{B}\PYG{p}{,} \PYG{n}{B}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{B}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{B}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{B}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} pay attention to the last two cases}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([[[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11]],
 
        [[12, 13, 14, 15],
         [16, 17, 18, 19],
         [20, 21, 22, 23]]]),
 array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]]),
 array([[ 4,  5,  6,  7],
        [ 8,  9, 10, 11]]),
 array([ 6, 11]),
 array([[ 6, 11],
        [18, 23]]))
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert} \PYG{p}{(}\PYG{n}{B}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{==} \PYG{n}{B}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{B}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} ... expands to selecting all elements of all previous dimensions}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[ 3,  7, 11],
       [15, 19, 23]])
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{B}\PYG{p}{[}\PYG{n}{B}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{5}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} indexing using boolean array}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([ 6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
       23])
\end{sphinxVerbatim}

Finally, the following function solves a system of 2 linear equations with 2 variables.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{solve\PYGZus{}2\PYGZus{}by\PYGZus{}2\PYGZus{}system}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Returns the unique solution of the linear system, if exists, }
\PYG{l+s+sd}{    else returns None.\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n}{C} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{hstack}\PYG{p}{(}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{b}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:} \PYG{n}{C} \PYG{o}{=} \PYG{n}{C}\PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}
    \PYG{k}{if} \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:} \PYG{k}{return} \PYG{k+kc}{None}
    \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{/} \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{*} \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{k}{if} \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:} \PYG{k}{return} \PYG{k+kc}{None}
    \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{/} \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{*} \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{C}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} tests}
\PYG{k}{for} \PYG{n}{A} \PYG{o+ow}{in} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}
          \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
          \PYG{n}{np}\PYG{o}{.}\PYG{n}{stack}\PYG{p}{(}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
          \PYG{n}{np}\PYG{o}{.}\PYG{n}{stack}\PYG{p}{(}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A=}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{A}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{b=}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{x=}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{solve\PYGZus{}2\PYGZus{}by\PYGZus{}2\PYGZus{}system}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
A=[[1. 0.]
 [0. 1.]]
b=[1. 1.]
x=[1. 1.]

A=[[1. 1.]
 [1. 1.]]
b=[1. 1.]
x=None

A=[[1. 1.]
 [0. 0.]]
b=[1. 1.]
x=None

A=[[1. 0.]
 [1. 0.]]
b=[1. 1.]
x=None
\end{sphinxVerbatim}


\subsection{Universal functions}
\label{\detokenize{Lecture9/Monte Carlo Simulation and Linear Algebra:universal-functions}}
Why does the first line of code below return two arrays but the second code return only one array? Shouldn’t the first line of code return the following?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
       \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fromfunction}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{:}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fromfunction}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{:}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([[0, 0, 0],
       [1, 1, 1]]), array([[0, 1, 2],
       [0, 1, 2]]))
[[0 0 0]
 [0 1 2]]
\end{sphinxVerbatim}

From the documentation, \sphinxcode{\sphinxupquote{fromfunction}} applies the given function to the two arrays as arguments.
\begin{itemize}
\item {} 
The first line of code returns a tuple of the arrays.

\item {} 
The second line of code multiplies the two arrays to give one array, according to how multiplication works for numpy arrays.

\end{itemize}

Indeed, \sphinxcode{\sphinxupquote{numpy}} implements \sphinxhref{https://numpy.org/doc/stable/reference/ufuncs.html}{universal/vectorized functions/operators} that take arrays as arguments and perform operations with appropriate broadcasting rules. The following is an example that uses the universal function \sphinxcode{\sphinxupquote{np.sin}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{n+nd}{@widgets}\PYG{o}{.}\PYG{n}{interact}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{b}\PYG{o}{=}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}sin}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{x}\PYG{o}{+}\PYG{n}{b}\PYG{o}{*}\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} np.sin, *, + are universal functions}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{sin(ax+b}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{pi)\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}x\PYGZdl{} (radian)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
interactive(children=(IntSlider(value=1, description=\PYGZsq{}a\PYGZsq{}, max=5), FloatSlider(value=0.0, description=\PYGZsq{}b\PYGZsq{}, max=…
\end{sphinxVerbatim}

In addition to making the code shorter, universal functions are both efficient and flexible. (Recall the Monte Carlo simulation to approximate \(\pi\).)

\sphinxstylestrong{Exercise} Explain how the Monte Carlo simulation work using universal functions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{np\PYGZus{}approximate\PYGZus{}pi}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{in\PYGZus{}circle} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}
    \PYG{n}{mean} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{in\PYGZus{}circle}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{std} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{in\PYGZus{}circle}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{p}{)} \PYG{o}{/} \PYG{n}{n}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mean} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{std}\PYG{p}{,} \PYG{n}{mean} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{std}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{random.random}} generates a numpy array for \(n\) points in the unit square randomly.

\item {} 
\sphinxcode{\sphinxupquote{sum}} sums up the element along the last axis to give the squared distance.

\item {} 
\sphinxcode{\sphinxupquote{<}} returns the boolean array indicating whether each point is in the first quadrant of the inscribed circle.

\item {} 
\sphinxcode{\sphinxupquote{mean}} and \sphinxcode{\sphinxupquote{std}} returns the mean and standard deviation of the boolean array with True and False interpreted as 1 and 0 respectively.

\end{itemize}


\chapter{Review Questions}
\label{\detokenize{Review/Review Questions:review-questions}}\label{\detokenize{Review/Review Questions::doc}}

\section{Dictionaries and Sets}
\label{\detokenize{Review/Review Questions:dictionaries-and-sets}}
\sphinxstylestrong{Exercise (Concatenate two dictionaries with precedence)} Define a function \sphinxcode{\sphinxupquote{concat\_two\_dicts}} that accepts two arguments of type \sphinxcode{\sphinxupquote{dict}} such that \sphinxcode{\sphinxupquote{concat\_two\_dicts(a, b)}} will return a new dictionary containing all the items in \sphinxcode{\sphinxupquote{a}} and the items in \sphinxcode{\sphinxupquote{b}} that have different keys than those in \sphinxcode{\sphinxupquote{a}}.  The input dictionaries should not be mutated.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{concat\PYGZus{}two\PYGZus{}dicts}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{return} \PYG{p}{\PYGZob{}}\PYG{o}{*}\PYG{o}{*}\PYG{n}{b}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{a}\PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}tests}
\PYG{n}{a}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{30}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{n}{b}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{40}\PYG{p}{\PYGZcb{}}
\PYG{n}{a\PYGZus{}copy} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{b\PYGZus{}copy} \PYG{o}{=} \PYG{n}{b}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{assert} \PYG{n}{concat\PYGZus{}two\PYGZus{}dicts}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{20}\PYG{p}{\PYGZcb{}}
\PYG{k}{assert} \PYG{n}{concat\PYGZus{}two\PYGZus{}dicts}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{20}\PYG{p}{\PYGZcb{}}
\PYG{k}{assert} \PYG{n}{a} \PYG{o}{==} \PYG{n}{a\PYGZus{}copy} \PYG{o+ow}{and} \PYG{n}{b} \PYG{o}{==} \PYG{n}{b\PYGZus{}copy}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN HIDDEN TESTS}
\PYG{n}{a}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{30}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{n}{b}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{20}\PYG{p}{\PYGZcb{}}
\PYG{n}{a\PYGZus{}copy} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{b\PYGZus{}copy} \PYG{o}{=} \PYG{n}{b}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{assert} \PYG{n}{concat\PYGZus{}two\PYGZus{}dicts}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{20}\PYG{p}{\PYGZcb{}}
\PYG{k}{assert} \PYG{n}{concat\PYGZus{}two\PYGZus{}dicts}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{20}\PYG{p}{\PYGZcb{}}
\PYG{k}{assert} \PYG{n}{a} \PYG{o}{==} \PYG{n}{a\PYGZus{}copy} \PYG{o+ow}{and} \PYG{n}{b} \PYG{o}{==} \PYG{n}{b\PYGZus{}copy}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END HIDDEN TESTS}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\{**dict1,**dict2\}}} creates a new dictionary by unpacking the dictionaries \sphinxcode{\sphinxupquote{dict1}} and \sphinxcode{\sphinxupquote{dict2}}.

\item {} 
By default, \sphinxcode{\sphinxupquote{dict2}} overwrites \sphinxcode{\sphinxupquote{dict1}} if they have identical keys.

\end{itemize}

\sphinxstylestrong{Exercise (Count characters)} Define a function \sphinxcode{\sphinxupquote{count\_characters}} which
\begin{itemize}
\item {} 
accepts a string and counts the numbers of each character in the string, and

\item {} 
returns a dictionary that stores the results.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{count\PYGZus{}characters}\PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{n}{counts} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{k}{for} \PYG{n}{char} \PYG{o+ow}{in} \PYG{n}{string}\PYG{p}{:}
        \PYG{n}{counts}\PYG{p}{[}\PYG{n}{char}\PYG{p}{]} \PYG{o}{=} \PYG{n}{counts}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{char}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}
    \PYG{k}{return} \PYG{n}{counts}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} tests}
\PYG{k}{assert} \PYG{n}{count\PYGZus{}characters}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abcbabc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}
\PYG{k}{assert} \PYG{n}{count\PYGZus{}characters}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{aababcccabc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN HIDDEN TESTS}
\PYG{k}{assert} \PYG{n}{count\PYGZus{}characters}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abcdefgabc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}
\PYG{k}{assert} \PYG{n}{count\PYGZus{}characters}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ab43cb324abc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END HIDDEN TESTS}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Create an empty dictionary \sphinxcode{\sphinxupquote{counts}}.

\item {} 
Use a \sphinxcode{\sphinxupquote{for}} loop to iterate over each character of \sphinxcode{\sphinxupquote{string}} to count their numbers of occurrences.

\item {} 
The \sphinxcode{\sphinxupquote{get}} method of \sphinxcode{\sphinxupquote{dict}} can initialize the count of a new character before incrementing it.

\end{itemize}

\sphinxstylestrong{Exercise (Count non\sphinxhyphen{}Fibonacci numbers)} Define a function \sphinxcode{\sphinxupquote{count\_non\_fibs}} that
\begin{itemize}
\item {} 
accepts a container as an argument, and

\item {} 
returns the number of items in the container that are not \sphinxhref{https://en.wikipedia.org/wiki/Fibonacci\_number}{fibonacci numbers}.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{count\PYGZus{}non\PYGZus{}fibs}\PYG{p}{(}\PYG{n}{container}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{def} \PYG{n+nf}{fib\PYGZus{}sequence\PYGZus{}inclusive}\PYG{p}{(}\PYG{n}{stop}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Fn}\PYG{p}{,} \PYG{n}{Fn1} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
        \PYG{k}{while} \PYG{n}{Fn} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{stop}\PYG{p}{:}
            \PYG{k}{yield} \PYG{n}{Fn}
            \PYG{n}{Fn}\PYG{p}{,} \PYG{n}{Fn1} \PYG{o}{=} \PYG{n}{Fn1}\PYG{p}{,} \PYG{n}{Fn} \PYG{o}{+} \PYG{n}{Fn1}

    \PYG{n}{non\PYGZus{}fibs} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{n}{container}\PYG{p}{)}
    \PYG{n}{non\PYGZus{}fibs}\PYG{o}{.}\PYG{n}{difference\PYGZus{}update}\PYG{p}{(}\PYG{n}{fib\PYGZus{}sequence\PYGZus{}inclusive}\PYG{p}{(}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{container}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{non\PYGZus{}fibs}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} tests}
\PYG{k}{assert} \PYG{n}{count\PYGZus{}non\PYGZus{}fibs}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}
\PYG{k}{assert} \PYG{n}{count\PYGZus{}non\PYGZus{}fibs}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{144}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+m+mi}{76}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{\PYGZcb{}}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{3}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN HIDDEN TESTS}
\PYG{k}{assert} \PYG{n}{count\PYGZus{}non\PYGZus{}fibs}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{34}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{\PYGZcb{}}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}
\PYG{k}{assert} \PYG{n}{count\PYGZus{}non\PYGZus{}fibs}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END HIDDEN TESTS}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Create a set of Fibonacci numbers up to the maximum of the items in the container.

\item {} 
Use \sphinxcode{\sphinxupquote{difference\_update}} method of \sphinxcode{\sphinxupquote{set}} to create a set of items in the container but not in the set of Fibonacci numbers.

\end{itemize}

\sphinxstylestrong{Exercise (Calculate total salaries)} Suppose \sphinxcode{\sphinxupquote{salary\_dict}} contains information about the name, salary, and working time about employees in a company. An example of \sphinxcode{\sphinxupquote{salary\_dict}} is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{salary\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}
     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{John}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{salary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{15000}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{working\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{20}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{salary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{16000}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{working\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{13}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jack}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{salary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{15500}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{working\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{15}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Define a function \sphinxcode{\sphinxupquote{calculate\_total}} that accepts \sphinxcode{\sphinxupquote{salary\_dict}} as an argument, and returns a \sphinxcode{\sphinxupquote{dict}} that uses the same keys in \sphinxcode{\sphinxupquote{salary\_dict}} but the total salaries as their values.  The total salary of an employee is obtained by multiplying his/her salary and his/her working\_time.
E.g.,, for the \sphinxcode{\sphinxupquote{salary\_dict}} example above, \sphinxcode{\sphinxupquote{calculate\_total(salary\_dict)}} should return

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{300000}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{208000}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{232500}\PYG{p}{\PYGZcb{}}\PYG{o}{.}
\end{sphinxVerbatim}

where the total salary of \sphinxcode{\sphinxupquote{emp1}} is \(15000 \times 20 = 300000\).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{calculate\PYGZus{}total}\PYG{p}{(}\PYG{n}{salary\PYGZus{}dict}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{return} \PYG{p}{\PYGZob{}}
        \PYG{n}{emp}\PYG{p}{:} \PYG{n}{record}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{salary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{n}{record}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{working\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{emp}\PYG{p}{,} \PYG{n}{record} \PYG{o+ow}{in} \PYG{n}{salary\PYGZus{}dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} tests}
\PYG{n}{salary\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}
     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{John}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{salary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{15000}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{working\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{20}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{salary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{16000}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{working\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{13}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jack}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{salary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{15500}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{working\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{15}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}
\PYG{k}{assert} \PYG{n}{calculate\PYGZus{}total}\PYG{p}{(}\PYG{n}{salary\PYGZus{}dict}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{300000}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{208000}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{232500}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN HIDDEN TESTS}
\PYG{n}{salary\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}
     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{John}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{salary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{15000}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{working\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{20}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{salary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{16000}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{working\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{13}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jack}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{salary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{15500}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{working\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{15}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
     \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Bob}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{salary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{20000}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{working\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k}{assert} \PYG{n}{calculate\PYGZus{}total}\PYG{p}{(}\PYG{n}{salary\PYGZus{}dict}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{300000}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{208000}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{232500}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{200000}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END HIDDEN TESTS}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Use \sphinxcode{\sphinxupquote{items}} method of \sphinxcode{\sphinxupquote{dict}} to return the list of key values pairs, and

\item {} 
use a dictionary comprehension to create the desired dictionary by iterating through the list of items.

\end{itemize}

\sphinxstylestrong{Exercise (Delete items with value 0 in dictionary)} Define a function \sphinxcode{\sphinxupquote{zeros\_removed}} that
\begin{itemize}
\item {} 
takes a dictionary as an argument,

\item {} 
mutates the dictionary to remove all the keys associated with values equal to \sphinxcode{\sphinxupquote{0}},

\item {} 
and return \sphinxcode{\sphinxupquote{True}} if at least one key is removed else \sphinxcode{\sphinxupquote{False}}.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{zeros\PYGZus{}removed}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{n}{to\PYGZus{}delete} \PYG{o}{=} \PYG{p}{[}\PYG{n}{k} \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{d} \PYG{k}{if} \PYG{n}{d}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{to\PYGZus{}delete}\PYG{p}{:}
        \PYG{k}{del} \PYG{n}{d}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}
    \PYG{k}{return} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{to\PYGZus{}delete}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}


\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Memory\PYGZhy{}efficient but not computationally efficient}
\PYG{c+c1}{\PYGZsh{} def zeros\PYGZus{}removed(d):}
\PYG{c+c1}{\PYGZsh{}     has\PYGZus{}deleted = False}
\PYG{c+c1}{\PYGZsh{}     while True:}
\PYG{c+c1}{\PYGZsh{}         for k in d:}
\PYG{c+c1}{\PYGZsh{}             if d[k] == 0:}
\PYG{c+c1}{\PYGZsh{}                 del d[k]}
\PYG{c+c1}{\PYGZsh{}                 has\PYGZus{}deleted = True}
\PYG{c+c1}{\PYGZsh{}                 break}
\PYG{c+c1}{\PYGZsh{}         else: return has\PYGZus{}deleted}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} tests}
\PYG{n}{d} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}
\PYG{k}{assert} \PYG{n}{zeros\PYGZus{}removed}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)} \PYG{o}{==} \PYG{k+kc}{True}
\PYG{k}{assert} \PYG{n}{zeros\PYGZus{}removed}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)} \PYG{o}{==} \PYG{k+kc}{False}
\PYG{k}{assert} \PYG{n}{d} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN HIDDEN TESTS}
\PYG{n}{d} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{assert} \PYG{n}{zeros\PYGZus{}removed}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)} \PYG{o}{==} \PYG{k+kc}{True}
\PYG{k}{assert} \PYG{n}{zeros\PYGZus{}removed}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)} \PYG{o}{==} \PYG{k+kc}{False}
\PYG{k}{assert} \PYG{n}{d} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END HIDDEN TESTS}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
The main issue is that, for any dicionary \sphinxcode{\sphinxupquote{d}},

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{d}\PYG{p}{:} 
        \PYG{k}{if} \PYG{n}{d}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:} \PYG{k}{del} \PYG{n}{d}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}
\end{sphinxVerbatim}

raises the \sphinxhref{https://www.geeksforgeeks.org/python-delete-items-from-dictionary-while-iterating/}{\sphinxcode{\sphinxupquote{RuntimeError: dictionary changed size during iteration}}}.
\begin{itemize}
\item {} 
One solution is to duplicate the list of keys, but this is memory inefficient especially when the list of keys is large.

\item {} 
Another solution is to record the list of keys to delete before the actual deletion. This is memory efficient if the list of keys to delete is small.

\end{itemize}

\sphinxstylestrong{Exercise (Fuzzy search a set)} Define a function \sphinxcode{\sphinxupquote{search\_fuzzy}} that accepts two arguments \sphinxcode{\sphinxupquote{myset}} and \sphinxcode{\sphinxupquote{word}} such that
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{myset}} is a \sphinxcode{\sphinxupquote{set}} of \sphinxcode{\sphinxupquote{str}}s;

\item {} 
\sphinxcode{\sphinxupquote{word}} is a \sphinxcode{\sphinxupquote{str}}; and

\item {} 
\sphinxcode{\sphinxupquote{search\_fuzzy(myset, word)}} returns \sphinxcode{\sphinxupquote{True}} if \sphinxcode{\sphinxupquote{word}} is in \sphinxcode{\sphinxupquote{myset}} by changing at most one character in \sphinxcode{\sphinxupquote{word}}, and returns \sphinxcode{\sphinxupquote{False}} otherwise.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{search\PYGZus{}fuzzy}\PYG{p}{(}\PYG{n}{myset}\PYG{p}{,} \PYG{n}{word}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{for} \PYG{n}{myword} \PYG{o+ow}{in} \PYG{n}{myset}\PYG{p}{:}
        \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{myword}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{word}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n+nb}{len}\PYG{p}{(}
            \PYG{p}{[}\PYG{k+kc}{True}
             \PYG{k}{for} \PYG{n}{mychar}\PYG{p}{,} \PYG{n}{char} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{myword}\PYG{p}{,} \PYG{n}{word}\PYG{p}{)} \PYG{k}{if} \PYG{n}{mychar} \PYG{o}{!=} \PYG{n}{char}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{k}{return} \PYG{k+kc}{True}
    \PYG{k}{return} \PYG{k+kc}{False}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} tests}
\PYG{k}{assert} \PYG{n}{search\PYGZus{}fuzzy}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dog}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{car}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{k+kc}{True}
\PYG{k}{assert} \PYG{n}{search\PYGZus{}fuzzy}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dog}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fox}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{k+kc}{False}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN HIDDEN TESTS}
\PYG{n}{myset} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dog}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dolphin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rabbit}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{monkey}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tiger}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{assert} \PYG{n}{search\PYGZus{}fuzzy}\PYG{p}{(}\PYG{n}{myset}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lion}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{k+kc}{False}
\PYG{k}{assert} \PYG{n}{search\PYGZus{}fuzzy}\PYG{p}{(}\PYG{n}{myset}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{k+kc}{True}
\PYG{k}{assert} \PYG{n}{search\PYGZus{}fuzzy}\PYG{p}{(}\PYG{n}{myset}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cat }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{k+kc}{False}
\PYG{k}{assert} \PYG{n}{search\PYGZus{}fuzzy}\PYG{p}{(}\PYG{n}{myset}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fox}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{k+kc}{False}
\PYG{k}{assert} \PYG{n}{search\PYGZus{}fuzzy}\PYG{p}{(}\PYG{n}{myset}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ccc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{k+kc}{False}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END HIDDEN TESTS}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Iterate over each word in \sphinxcode{\sphinxupquote{myset}}.

\item {} 
Check whether the length of the word is the same as that of the word in the arguments.

\item {} 
If the above check passes, use a list comprehension check if the words differ by at most one character.

\end{itemize}

\sphinxstylestrong{Exercise (Get keys by value)} Define a function \sphinxcode{\sphinxupquote{get\_keys\_by\_value}} that accepts two arguments \sphinxcode{\sphinxupquote{d}} and \sphinxcode{\sphinxupquote{value}} where \sphinxcode{\sphinxupquote{d}} is a dictionary, and returns a set containing all the keys in \sphinxcode{\sphinxupquote{d}} that have \sphinxcode{\sphinxupquote{value}} as its value. If no key has the query value \sphinxcode{\sphinxupquote{value}}, then return an empty set.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}keys\PYGZus{}by\PYGZus{}value}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{return} \PYG{p}{\PYGZob{}}\PYG{n}{k} \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{d} \PYG{k}{if} \PYG{n}{d}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{==} \PYG{n}{value}\PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} tests}
\PYG{n}{d} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{99}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{John}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{88}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Lucy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{100}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Lily}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{90}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jason}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{89}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jack}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{100}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{assert} \PYG{n}{get\PYGZus{}keys\PYGZus{}by\PYGZus{}value}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{99}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN HIDDEN TESTS}
\PYG{n}{d} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{99}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{John}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{88}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Lucy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{100}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Lily}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{90}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jason}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{89}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jack}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{100}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{assert} \PYG{n}{get\PYGZus{}keys\PYGZus{}by\PYGZus{}value}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{100}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jack}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Lucy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{d} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{99}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{John}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{88}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Lucy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{100}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Lily}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{90}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jason}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{89}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jack}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{100}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{assert} \PYG{n}{get\PYGZus{}keys\PYGZus{}by\PYGZus{}value}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END HIDDEN TESTS}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Use set comprehension to create the set of keys whose associated values is \sphinxcode{\sphinxupquote{value}}.

\end{itemize}

\sphinxstylestrong{Exercise (Count letters and digits)} Define a function \sphinxcode{\sphinxupquote{count\_letters\_and\_digits}} which
\begin{itemize}
\item {} 
take a string as an argument,

\item {} 
returns a dictionary that stores the number of letters and digits in the string using the keys ‘LETTERS’ and ‘DIGITS’ respectively.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{count\PYGZus{}letters\PYGZus{}and\PYGZus{}digits}\PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{n}{check} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LETTERS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n+nb}{str}\PYG{o}{.}\PYG{n}{isalpha}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DIGITS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n+nb}{str}\PYG{o}{.}\PYG{n}{isdigit}\PYG{p}{\PYGZcb{}}
    \PYG{n}{counts} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{o}{.}\PYG{n}{fromkeys}\PYG{p}{(}\PYG{n}{check}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{char} \PYG{o+ow}{in} \PYG{n}{string}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{check}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{check}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]}\PYG{p}{(}\PYG{n}{char}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{counts}\PYG{p}{[}\PYG{n}{t}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{return} \PYG{n}{counts}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{assert} \PYG{n}{count\PYGZus{}letters\PYGZus{}and\PYGZus{}digits}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hello world! 2020}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DIGITS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LETTERS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}
\PYG{k}{assert} \PYG{n}{count\PYGZus{}letters\PYGZus{}and\PYGZus{}digits}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I love CS1302}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DIGITS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LETTERS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN HIDDEN TESTS}
\PYG{k}{assert} \PYG{n}{count\PYGZus{}letters\PYGZus{}and\PYGZus{}digits}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hi CityU see you in 2021}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DIGITS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LETTERS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{15}\PYG{p}{\PYGZcb{}}
\PYG{k}{assert} \PYG{n}{count\PYGZus{}letters\PYGZus{}and\PYGZus{}digits}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{When a dog runs at you, whistle for him. (Philosopher Henry David Thoreau, 1817\PYGZhy{}1862)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DIGITS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LETTERS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{58}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END HIDDEN TESTS}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Use the class method \sphinxcode{\sphinxupquote{fromkeys}} of \sphinxcode{\sphinxupquote{dict}} to initial the dictionary of counts.

\end{itemize}

\sphinxstylestrong{Exercise (Dealers with lowest price)} Suppose \sphinxcode{\sphinxupquote{apple\_price}} is a list in which each element is a \sphinxcode{\sphinxupquote{dict}} recording the dealer and the corresponding price, e.g.,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{apple\PYGZus{}price} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{6799}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
 \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{6749}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
 \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{6798}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
 \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{6749}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\end{sphinxVerbatim}

Define a function \sphinxcode{\sphinxupquote{dealers\_with\_lowest\_price}} that takes \sphinxcode{\sphinxupquote{apple\_price}} as an argument, and returns the \sphinxcode{\sphinxupquote{set}} of dealers providing the lowest price.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{dealers\PYGZus{}with\PYGZus{}lowest\PYGZus{}price}\PYG{p}{(}\PYG{n}{apple\PYGZus{}price}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{n}{dealers} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{n}{lowest\PYGZus{}price} \PYG{o}{=} \PYG{k+kc}{None}
    \PYG{k}{for} \PYG{n}{pricing} \PYG{o+ow}{in} \PYG{n}{apple\PYGZus{}price}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{lowest\PYGZus{}price} \PYG{o}{==} \PYG{k+kc}{None} \PYG{o+ow}{or} \PYG{n}{lowest\PYGZus{}price} \PYG{o}{\PYGZgt{}} \PYG{n}{pricing}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
            \PYG{n}{lowest\PYGZus{}price} \PYG{o}{=} \PYG{n}{pricing}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n}{dealers}\PYG{o}{.}\PYG{n}{setdefault}\PYG{p}{(}\PYG{n}{pricing}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{pricing}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{dealers}\PYG{p}{[}\PYG{n}{lowest\PYGZus{}price}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Shorter code that uses comprehension}
\PYG{c+c1}{\PYGZsh{} def dealers\PYGZus{}with\PYGZus{}lowest\PYGZus{}price(apple\PYGZus{}price):}
\PYG{c+c1}{\PYGZsh{}     lowest\PYGZus{}price = min(pricing[\PYGZsq{}price\PYGZsq{}] for pricing in apple\PYGZus{}price)}
\PYG{c+c1}{\PYGZsh{}     return set(pricing[\PYGZsq{}dealer\PYGZsq{}] for pricing in apple\PYGZus{}price}
\PYG{c+c1}{\PYGZsh{}                if pricing[\PYGZsq{}price\PYGZsq{}] == lowest\PYGZus{}price)}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} tests}
\PYG{n}{apple\PYGZus{}price} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{6799}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
 \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{6749}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
 \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{6798}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
 \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{6749}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{k}{assert} \PYG{n}{dealers\PYGZus{}with\PYGZus{}lowest\PYGZus{}price}\PYG{p}{(}\PYG{n}{apple\PYGZus{}price}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN HIDDEN TESTS}
\PYG{n}{apple\PYGZus{}price} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{6799}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
 \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{6799}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
 \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{6799}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
 \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{6799}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{k}{assert} \PYG{n}{dealers\PYGZus{}with\PYGZus{}lowest\PYGZus{}price}\PYG{p}{(}\PYG{n}{apple\PYGZus{}price}\PYG{p}{)} \PYG{o}{==} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dealer\PYGZus{}D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END HIDDEN TESTS}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Use the class method \sphinxcode{\sphinxupquote{setdefault}} of \sphinxcode{\sphinxupquote{dict}} to create a dictionary that maps different prices to different sets of dealers.

\item {} 
Compute the lowest price at the same time.

\item {} 
Alternatively, use comprehension to find lowest price and then create the desired set of dealers with the lowest price.

\end{itemize}


\section{Lists and Tuples}
\label{\detokenize{Review/Review Questions:lists-and-tuples}}
\sphinxstylestrong{Exercise} (Binary addition) Define a function \sphinxcode{\sphinxupquote{add\_binary}} that
\begin{itemize}
\item {} 
accepts two arguments of type \sphinxcode{\sphinxupquote{str}} which represent two non\sphinxhyphen{}negative binary numbers, and

\item {} 
returns the binary number in \sphinxcode{\sphinxupquote{str}} equal to the sum of the two given binary numbers.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}binary}\PYG{p}{(}\PYG{o}{*}\PYG{n}{binaries}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{def} \PYG{n+nf}{binary\PYGZus{}to\PYGZus{}decimal}\PYG{p}{(}\PYG{n}{binary}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{n}{i} \PYG{o}{*} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{b} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n+nb}{reversed}\PYG{p}{(}\PYG{n}{binary}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{decimal\PYGZus{}to\PYGZus{}binary}\PYG{p}{(}\PYG{n}{decimal}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{(}\PYG{p}{(}\PYG{n}{decimal\PYGZus{}to\PYGZus{}binary}\PYG{p}{(}\PYG{n}{decimal} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{k}{if} \PYG{n}{decimal} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{k}{else} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{+}
                \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{decimal} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)} \PYG{k}{if} \PYG{n}{decimal} \PYG{k}{else} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}
    
    \PYG{k}{return} \PYG{n}{decimal\PYGZus{}to\PYGZus{}binary}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{binary\PYGZus{}to\PYGZus{}decimal}\PYG{p}{(}\PYG{n}{binary}\PYG{p}{)} \PYG{k}{for} \PYG{n}{binary} \PYG{o+ow}{in} \PYG{n}{binaries}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Alternative 1 using recursion}
\PYG{c+c1}{\PYGZsh{} def add\PYGZus{}binary(bin1, bin2, carry=False):}
\PYG{c+c1}{\PYGZsh{}     if len(bin1) \PYGZgt{} len(bin2):}
\PYG{c+c1}{\PYGZsh{}         return add\PYGZus{}binary(bin2, bin1)}
\PYG{c+c1}{\PYGZsh{}     if bin1 == \PYGZsq{}\PYGZsq{}:}
\PYG{c+c1}{\PYGZsh{}         return add\PYGZus{}binary(\PYGZsq{}1\PYGZsq{}, bin2, False) if carry else bin2}
\PYG{c+c1}{\PYGZsh{}     s = int(bin1[\PYGZhy{}1]) + int(bin2[\PYGZhy{}1]) + carry}
\PYG{c+c1}{\PYGZsh{}     return add\PYGZus{}binary(bin1[:\PYGZhy{}1], bin2[:\PYGZhy{}1], s \PYGZgt{} 1) + str(s \PYGZpc{} 2)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Alternatve 2 using iteration}
\PYG{c+c1}{\PYGZsh{} def add\PYGZus{}binary(a, b):}
\PYG{c+c1}{\PYGZsh{}     answer = []}
\PYG{c+c1}{\PYGZsh{}     n = max(len(a), len(b))}
\PYG{c+c1}{\PYGZsh{}     \PYGZsh{} fill necessary \PYGZsq{}0\PYGZsq{} to the beginning to make a and b have the same length}
\PYG{c+c1}{\PYGZsh{}     if len(a) \PYGZlt{} n: a = str(\PYGZsq{}0\PYGZsq{} * (n \PYGZhy{}len(a))) + a }
\PYG{c+c1}{\PYGZsh{}     if len(b) \PYGZlt{} n: b = str(\PYGZsq{}0\PYGZsq{} * (n \PYGZhy{}len(b))) + b}
\PYG{c+c1}{\PYGZsh{}     carry = 0}
\PYG{c+c1}{\PYGZsh{}     for i in range(n\PYGZhy{}1, \PYGZhy{}1, \PYGZhy{}1):}
\PYG{c+c1}{\PYGZsh{}         if a[i] == \PYGZsq{}1\PYGZsq{}: carry += 1}
\PYG{c+c1}{\PYGZsh{}         if b[i] == \PYGZsq{}1\PYGZsq{}: carry += 1}
\PYG{c+c1}{\PYGZsh{}         answer.insert(0, \PYGZsq{}1\PYGZsq{}) if carry \PYGZpc{} 2 == 1 else answer.insert(0, \PYGZsq{}0\PYGZsq{})}
\PYG{c+c1}{\PYGZsh{}         carry //= 2}
\PYG{c+c1}{\PYGZsh{}     if carry == 1: answer.insert(0, \PYGZsq{}1\PYGZsq{})}
\PYG{c+c1}{\PYGZsh{}     answer\PYGZus{}str = \PYGZsq{}\PYGZsq{}.join(answer) \PYGZsh{} you can also use \PYGZdq{}answer\PYGZus{}str = \PYGZsq{}\PYGZsq{};  for x in answer: answer\PYGZus{}str += x\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}     return answerastr}

    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} tests}
\PYG{k}{assert} \PYG{n}{add\PYGZus{}binary}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{assert} \PYG{n}{add\PYGZus{}binary}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{11}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{11}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{110}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{assert} \PYG{n}{add\PYGZus{}binary}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{101}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{101}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1010}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN HIDDEN TESTS}
\PYG{k}{assert} \PYG{n}{add\PYGZus{}binary}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1111}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10001}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{assert} \PYG{n}{add\PYGZus{}binary}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{111110000011}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{110000111}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1000100001010}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END HIDDEN TESTS}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Use comprehension to convert the binary numbers to decimal numbers.

\item {} 
Use comprehension to convert the sum of the decimal numbers to a binary number.

\item {} 
Alternatively, perform bitwise addition using a recursion or iteration.

\end{itemize}

\sphinxstylestrong{Exercise (Even\sphinxhyphen{}digit numbers)} Define a function \sphinxcode{\sphinxupquote{even\_digit\_numbers}}, which finds all numbers between \sphinxcode{\sphinxupquote{lower\_bound}} and \sphinxcode{\sphinxupquote{upper\_bound}} such that each digit of the number is an even number. Please return the numbers as a list.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{even\PYGZus{}digit\PYGZus{}numbers}\PYG{p}{(}\PYG{n}{lower\PYGZus{}bound}\PYG{p}{,} \PYG{n}{upper\PYGZus{}bound}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{return} \PYG{p}{[}
        \PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{lower\PYGZus{}bound}\PYG{p}{,} \PYG{n}{upper\PYGZus{}bound}\PYG{p}{)}
        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n+nb}{any}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} tests}
\PYG{k}{assert} \PYG{n}{even\PYGZus{}digit\PYGZus{}numbers}\PYG{p}{(}\PYG{l+m+mi}{1999}\PYG{p}{,} \PYG{l+m+mi}{2001}\PYG{p}{)} \PYG{o}{==} \PYG{p}{[}\PYG{l+m+mi}{2000}\PYG{p}{]}
\PYG{k}{assert} \PYG{n}{even\PYGZus{}digit\PYGZus{}numbers}\PYG{p}{(}\PYG{l+m+mi}{2805}\PYG{p}{,} \PYG{l+m+mi}{2821}\PYG{p}{)} \PYG{o}{==} \PYG{p}{[}\PYG{l+m+mi}{2806}\PYG{p}{,}\PYG{l+m+mi}{2808}\PYG{p}{,}\PYG{l+m+mi}{2820}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN HIDDEN TESTS}
\PYG{k}{assert} \PYG{n}{even\PYGZus{}digit\PYGZus{}numbers}\PYG{p}{(}\PYG{l+m+mi}{1999}\PYG{p}{,} \PYG{l+m+mi}{2300}\PYG{p}{)} \PYG{o}{==} \PYG{p}{[}\PYG{l+m+mi}{2000}\PYG{p}{,}\PYG{l+m+mi}{2002}\PYG{p}{,}\PYG{l+m+mi}{2004}\PYG{p}{,}\PYG{l+m+mi}{2006}\PYG{p}{,}\PYG{l+m+mi}{2008}\PYG{p}{,}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2022}\PYG{p}{,}\PYG{l+m+mi}{2024}\PYG{p}{,}\PYG{l+m+mi}{2026}\PYG{p}{,}\PYG{l+m+mi}{2028}\PYG{p}{,}\PYG{l+m+mi}{2040}\PYG{p}{,}\PYG{l+m+mi}{2042}\PYG{p}{,}\PYG{l+m+mi}{2044}\PYG{p}{,}\PYG{l+m+mi}{2046}\PYG{p}{,}\PYG{l+m+mi}{2048}\PYG{p}{,}\PYG{l+m+mi}{2060}\PYG{p}{,}\PYG{l+m+mi}{2062}\PYG{p}{,}\PYG{l+m+mi}{2064}\PYG{p}{,}\PYG{l+m+mi}{2066}\PYG{p}{,}\PYG{l+m+mi}{2068}\PYG{p}{,}\PYG{l+m+mi}{2080}\PYG{p}{,}\PYG{l+m+mi}{2082}\PYG{p}{,}\PYG{l+m+mi}{2084}\PYG{p}{,}\PYG{l+m+mi}{2086}\PYG{p}{,}\PYG{l+m+mi}{2088}\PYG{p}{,}\PYG{l+m+mi}{2200}\PYG{p}{,}\PYG{l+m+mi}{2202}\PYG{p}{,}\PYG{l+m+mi}{2204}\PYG{p}{,}\PYG{l+m+mi}{2206}\PYG{p}{,}\PYG{l+m+mi}{2208}\PYG{p}{,}\PYG{l+m+mi}{2220}\PYG{p}{,}\PYG{l+m+mi}{2222}\PYG{p}{,}\PYG{l+m+mi}{2224}\PYG{p}{,}\PYG{l+m+mi}{2226}\PYG{p}{,}\PYG{l+m+mi}{2228}\PYG{p}{,}\PYG{l+m+mi}{2240}\PYG{p}{,}\PYG{l+m+mi}{2242}\PYG{p}{,}\PYG{l+m+mi}{2244}\PYG{p}{,}\PYG{l+m+mi}{2246}\PYG{p}{,}\PYG{l+m+mi}{2248}\PYG{p}{,}\PYG{l+m+mi}{2260}\PYG{p}{,}\PYG{l+m+mi}{2262}\PYG{p}{,}\PYG{l+m+mi}{2264}\PYG{p}{,}\PYG{l+m+mi}{2266}\PYG{p}{,}\PYG{l+m+mi}{2268}\PYG{p}{,}\PYG{l+m+mi}{2280}\PYG{p}{,}\PYG{l+m+mi}{2282}\PYG{p}{,}\PYG{l+m+mi}{2284}\PYG{p}{,}\PYG{l+m+mi}{2286}\PYG{p}{,}\PYG{l+m+mi}{2288}\PYG{p}{]}
\PYG{k}{assert} \PYG{n}{even\PYGZus{}digit\PYGZus{}numbers}\PYG{p}{(}\PYG{l+m+mi}{8801}\PYG{p}{,} \PYG{l+m+mi}{8833}\PYG{p}{)} \PYG{o}{==} \PYG{p}{[}\PYG{l+m+mi}{8802}\PYG{p}{,}\PYG{l+m+mi}{8804}\PYG{p}{,}\PYG{l+m+mi}{8806}\PYG{p}{,}\PYG{l+m+mi}{8808}\PYG{p}{,}\PYG{l+m+mi}{8820}\PYG{p}{,}\PYG{l+m+mi}{8822}\PYG{p}{,}\PYG{l+m+mi}{8824}\PYG{p}{,}\PYG{l+m+mi}{8826}\PYG{p}{,}\PYG{l+m+mi}{8828}\PYG{p}{]}
\PYG{k}{assert} \PYG{n}{even\PYGZus{}digit\PYGZus{}numbers}\PYG{p}{(}\PYG{l+m+mi}{3662}\PYG{p}{,} \PYG{l+m+mi}{4001}\PYG{p}{)} \PYG{o}{==} \PYG{p}{[}\PYG{l+m+mi}{4000}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END HIDDEN TESTS}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Use list comprehension to generate numbers between the bounds, and

\item {} 
use comprehension and the \sphinxcode{\sphinxupquote{any}} function to filter out those numbers containing odd digits.

\end{itemize}

\sphinxstylestrong{Exercise (Maximum subsequence sum)} Define a function \sphinxcode{\sphinxupquote{max\_subsequence\_sum}} that
\begin{itemize}
\item {} 
accepts as an argument a sequence of numbers, and

\item {} 
returns the maximum sum over nonempty contiguous subsequences.

\end{itemize}

E.g., when \sphinxcode{\sphinxupquote{{[}\sphinxhyphen{}6, \sphinxhyphen{}4, 4, 1, \sphinxhyphen{}2, 2{]}}} is given as the argument, the function returns \sphinxcode{\sphinxupquote{5}} because the nonempty subsequence \sphinxcode{\sphinxupquote{{[}4, 1{]}}} has the maximum sum \sphinxcode{\sphinxupquote{5}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{max\PYGZus{}subsequence\PYGZus{}sum}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{} see https://en.wikipedia.org/wiki/Maximum\PYGZus{}subarray\PYGZus{}problem}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{a}\PYG{p}{:}
        \PYG{n}{t} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{t} \PYG{o}{+} \PYG{n}{x}\PYG{p}{)}
        \PYG{n}{s} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{s}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Alternative (less efficient) solution using list comprehension}
\PYG{c+c1}{\PYGZsh{} def max\PYGZus{}subsequence\PYGZus{}sum(a):}
\PYG{c+c1}{\PYGZsh{}     return max(sum(a[i:j]) for i in range(len(a)) for j in range(i,len(a)+1))}

    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} tests}
\PYG{k}{assert} \PYG{n}{max\PYGZus{}subsequence\PYGZus{}sum}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{5}
\PYG{k}{assert} \PYG{n}{max\PYGZus{}subsequence\PYGZus{}sum}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{l+m+mf}{1.4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{l+m+mf}{1.4}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{1.6}\PYG{p}{]}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mf}{5.9}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN HIDDEN TESTS}
\PYG{n}{seq} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{24.81}\PYG{p}{,} \PYG{l+m+mf}{25.74}\PYG{p}{,} \PYG{l+m+mf}{37.29}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.77}\PYG{p}{,} \PYG{l+m+mf}{0.78}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{15.33}\PYG{p}{,} \PYG{l+m+mf}{30.21}\PYG{p}{,} \PYG{l+m+mf}{34.94}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{40.64}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{20.06}\PYG{p}{]}
\PYG{k}{assert} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{max\PYGZus{}subsequence\PYGZus{}sum}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mf}{104.86}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN HIDDEN TESTS}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} test of efficiency}
\PYG{k}{assert} \PYG{n}{max\PYGZus{}subsequence\PYGZus{}sum}\PYG{p}{(}\PYG{p}{[}\PYG{o}{*}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1234567}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{762077221461}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
For a list \([a_0,a_1,\dots]\), let

\end{itemize}
\begin{equation*}
\begin{split}
t_k:=\max_{j<k} \sum_{i=j}^{k-1} a_i = \max\{t_{k-1}+a_{k-1},0\},
\end{split}
\end{equation*}
namely the maximum tail sum of \([a_0,\dots,a_{k-1}]\).
\begin{itemize}
\item {} 
Then, the maximum subsequence sum of \([a_0,\dots,a_{k-1}]\) is

\end{itemize}
\begin{equation*}
\begin{split}
s_k:=\max_{j\leq k} t_j.
\end{split}
\end{equation*}
\sphinxstylestrong{Exercise (Mergesort)} \sphinxstyleemphasis{For this question, do not use the \sphinxcode{\sphinxupquote{sort}} method or \sphinxcode{\sphinxupquote{sorted}} function.}

Define a function called \sphinxcode{\sphinxupquote{merge}} that
\begin{itemize}
\item {} 
takes two sequences sorted in ascending orders, and

\item {} 
returns a sorted list of items from the two sequences.

\end{itemize}

Then, define a function called \sphinxcode{\sphinxupquote{mergesort}} that
\begin{itemize}
\item {} 
takes a sequence, and

\item {} 
return a list of items from the sequence sorted in ascending order.

\end{itemize}

The list should be constructed by
\begin{itemize}
\item {} 
recursive calls to \sphinxcode{\sphinxupquote{mergesort}} the first and second halves of the sequence individually, and

\item {} 
merge the sorted halves.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{merge}\PYG{p}{(}\PYG{n}{left}\PYG{p}{,}\PYG{n}{right}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{if} \PYG{n}{left} \PYG{o+ow}{and} \PYG{n}{right}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{left}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{right}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:} \PYG{n}{left}\PYG{p}{,} \PYG{n}{right} \PYG{o}{=} \PYG{n}{right}\PYG{p}{,} \PYG{n}{left}
        \PYG{k}{return} \PYG{n}{merge}\PYG{p}{(}\PYG{n}{left}\PYG{p}{,}\PYG{n}{right}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{p}{[}\PYG{n}{right}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
    \PYG{k}{return} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{left} \PYG{o+ow}{or} \PYG{n}{right}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{mergesort}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}
    \PYG{n}{i} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{)}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}
    \PYG{k}{return} \PYG{n}{merge}\PYG{p}{(}\PYG{n}{mergesort}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{[}\PYG{p}{:}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{mergesort}\PYG{p}{(}\PYG{n}{seq}\PYG{p}{[}\PYG{n}{i}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} tests}
\PYG{k}{assert} \PYG{n}{merge}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)} \PYG{o}{==} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{k}{assert} \PYG{n}{mergesort}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{==} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN HIDDEN TESTS}
\PYG{k}{assert} \PYG{n}{mergesort}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{==} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END HIDDEN TESTS}
\end{sphinxVerbatim}


\section{More Functions}
\label{\detokenize{Review/Review Questions:more-functions}}
\sphinxstylestrong{Exercise (Arithmetic geometric mean)} Define a function \sphinxcode{\sphinxupquote{arithmetic\_geometric\_mean\_sequence}} which
\begin{itemize}
\item {} 
takes two floating point numbers  \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}} and

\item {} 
returns a generator that generates the tuple \textbackslash{}((a\_n, g\_n)\textbackslash{}) where

\end{itemize}
\begin{equation*}
\begin{split}
\begin{aligned}
a_0 &= x, g_0 = y \\
a_n &= \frac{a_{n-1} + g_{n-1}}2 \quad \text{for }n>0\\
g_n &= \sqrt{a_{n-1} g_{n-1}}
\end{aligned}
\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{arithmetic\PYGZus{}geometric\PYGZus{}mean\PYGZus{}sequence}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN SOLUTION}
    \PYG{n}{a}\PYG{p}{,} \PYG{n}{g} \PYG{o}{=} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}
    \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n}{a}\PYG{p}{,} \PYG{n}{g}
        \PYG{n}{a}\PYG{p}{,} \PYG{n}{g} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a} \PYG{o}{+} \PYG{n}{g}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{g}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END SOLUTION}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} tests}
\PYG{n}{agm} \PYG{o}{=} \PYG{n}{arithmetic\PYGZus{}geometric\PYGZus{}mean\PYGZus{}sequence}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{24}\PYG{p}{)}
\PYG{k}{assert} \PYG{p}{[}\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{agm}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{o}{==} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{15.0}\PYG{p}{,} \PYG{l+m+mf}{12.0}\PYG{p}{)}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} BEGIN HIDDEN TESTS}
\PYG{n}{agm} \PYG{o}{=} \PYG{n}{arithmetic\PYGZus{}geometric\PYGZus{}mean\PYGZus{}sequence}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{400}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{sol}\PYG{p}{,} \PYG{n}{ans} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{agm}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{400}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{250.0}\PYG{p}{,} \PYG{l+m+mf}{200.0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{225.0}\PYG{p}{,} \PYG{l+m+mf}{223.60679774997897}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{224.30339887498948}\PYG{p}{,} \PYG{l+m+mf}{224.30231718318308}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{224.30285802908628}\PYG{p}{,} \PYG{l+m+mf}{224.30285802843423}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{sol}\PYG{p}{,}\PYG{n}{ans}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{assert} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} END HIDDEN TESTS}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Use the \sphinxcode{\sphinxupquote{yield}} expression to return each tuple of \((a_n,g_n)\) efficiently without redundant computations.

\end{itemize}







\renewcommand{\indexname}{Index}
\printindex
\end{document}